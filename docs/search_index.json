[["index.html", "R básico Coleção Estudando o Ambiente R (Volume I) Bem-vindo Sugestões e críticas Livro físico Materiais complamentares Licença", " R básico Coleção Estudando o Ambiente R (Volume I) Ben Dêivide e Diego Arthur 2022-09-28 Bem-vindo Este é um livro digital da coleção Estudando o ambiente R, Volume 1, intitulado R Básico, com o selo Democratizando Conhecimento (DC). O Livro é destinado aos usuários R que objetivam aprofundar o entendimento do ambiente R para seus projetos pessoais e profissionais. O número de leitores que acessaram este livro: Free website hit counter Estatísticas de download do R básico (PDF): Sugestões e críticas Sugestões e críticas sobre o livro podem ser enviadas para livrosdeben@gmail.com. Livro físico O livro físico encontra-se à venda pela Amazon: R básico (Capa comum e Colorido internamente): https://www.amazon.com/dp/6500515994; R básico (Capa comum e Preto e branco internamente): https://www.amazon.com/dp/6500531914 Materiais complamentares Todos os códigos aprensentados no livro, apresentações, a versão digital em PDF, dentre outras informações, podem ser encontrados em: https://bendeivide.github.io/books/eambr01/. Licença Este trabalho está licenciado com uma Licença Creative Commons - Atribuição-NãoComercial 4.0 Internacional. "],["epígrafe.html", "Epígrafe", " Epígrafe A melhor linguagem é a que você domina! (Ben Dêivide) "],["prefácio.html", "Prefácio", " Prefácio A coleção Estudando o ambiente R é fruto de cursos ministrados sobre essa linguagem, bem como consultorias e estudos ao longo dos anos. Em 2005, quando ingressei na academia no curso de Engenharia Agronômica fiquei fascinado com a disciplina de Estatística no segundo semestre do ano corrente. Na sequência, acabo tendo o primeiro contato com o ambiente R, com pouco mais de 9 anos de seu lançamento e redistribuição. Poucos materiais naquela época haviam disponíveis em língua portuguesa. Porém, foi o suficiente para eu entender que estava diante de uma grande ferramenta computacional e estatística, necessária para o entendimento, pois sabia que poderia me gerar além de conhecimento, bons frutos acadêmicos. Hoje, no ano de 2021, usuário há mais de 15 anos dessa linguagem, percebi que me sentia desconfortável, como apenas usário dessa ferramenta de trabalho. E assim, quando queremos aprender algo não há ferramenta melhor do que aprender por ensinar. E assim, lotado no Departamento de Estatística, Física e Matemática (DEFIM), campus Alto Paraopeba, pela Universidade Federal de São João del-Rei (UFSJ), juntamente com o Centro Acadêmico de Engenharia de Telecomunicações (UFSJ), resolvemos em parceria, ministrar nesse momento de pandemia uma sequência de módulos para o curso R, desde o nível Básico até ao módulo Avançado. A ideia desse curso foi apresentar algo diferente relacionado a maioria dos cursos em R, que foi sempre apresentar essa ferramenta dentro dos conceitos da área da Estatística. Apesar de uma coisa ser intrínseca a outra, há muitas particularidades no ambiente R que são complexos, e muitas vezes julgados erroneamente. Um dos exemplos clássicos é que loops em R são lentos e com alto gasto de memória, quando na realiadade, isso ocorre muitas vezes pelo não entendimento do sistema de cópia de objetos nesse ambiente. Ainda mais, o entendimento desses cursos é agravado porque o entendimento sobre a estatística além de um cunho matemático, tem o seu cunho filosófico de como as metodologias foram desenvolvidas, e o entendimento mútuo da Estatística e o ambiente R, podem não ter o conhecimento real que essa potencial ferramenta pode proporcionar, uma vez que muitos assuntos complexos podem estar envolvidos em uma única aula. Assim, desenvolvemos na coleção Estudando o ambiente R os três volumes iniciais, referentes a apenas a linguagem R, sendo Volume I: Nível Básico, Volume II: Nível Intermediário e Volume III: Nível Avançado. Fazendo a alusão dos três livros iniciais sobre a linguagem S de John Chambers, faremos uma explanação sobre assuntos de menor complexidade até noções mais complexas sobre o ambiente R, restringindo apenas a sintaxe e semântica da linguagem. Os volumes subsequentes serão destinados a Documentações no R, Desenvolvimento de pacote R, Gráficos, Banco de dados, Interface Gráfica ao Usuário, Interface R com outras linguagens, dentre outros. Tentando engajar nossos alunos, e agora colegas de trabalho, tenho a parceria no Volume I, de Diego Arthur, uma pessoa que tenta se superar a cada desafio e assunto estudado. Por fim, espero que esse primeiro volume possa servir de referência para os passos iniciais nessa ferramenta tão importante para a área de análise de dados. Ben Dêivide de Oliveira Batista "],["entendendo-a-coleção-estudando-o-ambiente-r.html", "Capítulo 1 Entendendo a coleção Estudando o ambiente R 1.1 Volume I: Nível Básico 1.2 Volume II: Nível Intermediário 1.3 Volume III: Nível Avançado 1.4 Demais volumes 1.5 Referências complementares da Coleção 1.6 Pacotes R utilizados para essa coleção", " Capítulo 1 Entendendo a coleção Estudando o ambiente R A Coleção Estudando o ambiente R não tem como objetivo principal de ensinar análise de dados. Mas sim, proporcionar ao leitor um conhecimento sobre a linguagem R, de modo que se possa usufruir todos os recursos que esse ambiente possa proporcionar. Ainda como complemento, não queremos nesse material, convencê-lo a utilizar a linguagem R, pois a melhor linguagem é aquela que você domina. Contudo, pretendemos mostrar que os recursos utilizados pelo R não estão mais limitados a própria análise de dados. Um exemplo é esse material, que nesse momento usufruímos da própria linguagem para repassar as nossas experiências sem ao menos ter o domínio sobre linguagens do tipo HTML, CSS, JavaScript, dentre outras, necessárias para uma boa renderização de página web. Isso mostra a potencial ferramenta de trabalho que o ambiente R pode ser para a vida profissional. Dessa forma, propormos um entendimento sobre a sintaxe e semântica de como a linguagem R é desenvolvida. Com isso, o leitor será capaz após a leitura dos dois primeiros volumes, de estudar um pouco mais sobre essa ciência que nos últimos anos vem ganhando mais evidência, que é a Estatística. Tudo isso devido ao grande volume de informações obtidos nessa era tecnológica. Juntamente com ela, o R se tornará uma poderosa ferramenta para entender os padrões que estão por trás dos dados, que por sinal, é a moeda valiosa do momento, ou melhor, sempre foi! Aprenderemos também recursos diversos na área da computação, como programação defensiva, desenvolvimento de interfaces gráficas, paralelização, como também recursos na área da estatística sem complexidades teóricas, como o desenvolvimento de gráficos e o uso de banco de dados. Ensinaremos também o desenvolvimento de materiais como artigos, livros, websites, blogs, dashboards. Por fim, chegaremos a maior cobiça de um programador R, desenvolver um pacote. Observem que em muitos momentos utilizamos o artigo o para a linguagem R. Pois é, isso ocorre porque ela também é considerada um software ou ambiente. Daí, também podemos chamá-la de software R, ou preferivelmente, ambiente R. Os módulos dessa coleção terão os três volumes base para o entendimento do ambiente R: Volume I: Nível Básico; Volume II: Nível Intermediário; e Volume III: Nìvel Avançado. A seguir, explanaremos sobre cada um dos módulos. 1.1 Volume I: Nível Básico Esse primeiro volume, que representa o livro corrente, apresenta um breve histórico sobre a linguagem, a sua instalação, bem como os recursos que a IDE1 RStudio, o conhecimento da sintaxe e semântica da linguagem R, compreendendo as estruturas bases da linguagem, sobre o que é um objeto e como construir uma função, o entendimento sobre fluxos de controle. O que é um pacote, carregar e anexar um pacote, e quem são as pessoas que fazem parte da manutenção dessa linguagem, também serão assuntos desse primeiro módulo. Caminhos de busca, ambientes e namespaces, teremos noções básicas. Algo muito interessante, que pode mudar a vida de um programador em R são as boas práticas para a escrita de um código, tema também abordado nesse módulo. A ideia desse volume é proporcionar um entendimento básico, um primeiro contato com a linguagem, fazendo com que o leitor possa dar os primeiros passos, executando as primeiras linhas de comando. Mas também, dando o enfoque com erros tão recorrentes, como o entendimento sobre um objeto, ou o anexo de um pacote no caminho de busca. Temas como esses, dentre outros, serão a forma inicial que encontramos, para que posteriormente, seja dado um aprofundamento sobre a estrutura de um objeto R bem como a sua manipulação, e adicionado a isso, a inserção de como são os paradigmas da programação nesse ambiente. Essa última parte será estudada, no Volume II, apresentado a seguir. 1.2 Volume II: Nível Intermediário O volume II é introduzido com uma melhor caracterização do ambiente R quanto ao seu escopo léxico, como linguagem interpretada, como programação funcional, como programação meta-paradigma, como programação dinâmica; apresentaremos manipulações de objetos em mais detalhe, bem como o surgimento de alguns outros objetos como tibble, cópias de objetos. Uma característica do ambiente R é que a linguagem pode ser orientada a objetos e isso será estudado nesse módulo. Introduziremos ao desenvolvimento de pacotes R, e aprofundaremos sobre os ambientes. Por fim, mostraremos como desenvolver Projeto do RStudio e integrá-los ao GitHub, e dessa forma, introduziremos sobre o sistema Git. Esse talvez seja o maior volume, dentre os três iniciais, porque apenar de não precisarmos entender mais a ideia dos objetos, que foram retratadas no Volume I, a inserção dos paradigmas da programação para este volume, trará uma maior riqueza de características para o R, mostrando a sua versatilidade. Também, daremos um maior detalhamento como manipular objetos, e as otimizações existentes da linguagem, como por exemplo, a modificação no local, que se entendida, poderá perceber que o loop no ambiente R não é lento quanto parece. Ao final desse volume, falaremos sobre como propagar o seu código com o sistema Git na plataforma GitHub, sincronizado com os projetos do RStudio. 1.3 Volume III: Nível Avançado O Volume III, será a total exploração do manual R Internals. Apesar de ser um assunto voltado para membros do R Core Team, pretendemos entender como o R trabalha nos bastidores. Dessa forma, teremos total controle sobre as nossas rotinas. Contudo, para usários que pretendem entender o ambiente R de forma aplicada, pode avançar esse volume para a leitura dos volumes seguintes. 1.4 Demais volumes Os demais volumes compreendem lacunas necessárias para serem abordadas com profundidade, tais como: Documentações no R, Desenvolvimento de pacote R, Gráficos, Banco de dados, Interface Gráfica ao Usuário, Interface R com outras linguagens, dentre outros. 1.5 Referências complementares da Coleção Citaremos alguns livros e materiais utilizados para o desenvolvimento dessa coleção, que alguns podem ser acessados online via bookdown, tais como: An Introduction to R (R Core Team) R Data Import/Export (R Core Team) R Installation and Administration (R Core Team) Writing R Extensions (R Core Team) R Language Definition (R Core Team) R Internals (R Core Team) Advanced R (WICKHAM, 2019) Advanced R Solutions (GROSSER; BUMAN; WICKHAM, 2021) R Packages (WICKHAM, 2015) R for Data Science (WICKHAM; GROLEMUND, 2017) Extending R (CHAMBERS, 2016) Software for Data Analysis: Programming with R (CHAMBERS, 2008) R in a Nutshell (ADLER, 2012) The New S Language (Livro Branco) (BECKER; CHAMBERS; WILKS, 1988) Statistical Models in S (Livro Azul) (CHAMBERS; HASTIE, 1991) Programming with Data (Livro Verde) (CHAMBERS; HASTIE, 1998) Vale salientar que esses três últimos livros, se pudéssemos unir, seria a bíblia do ambiente R. 1.6 Pacotes R utilizados para essa coleção Apresentamos uma lista de pacotes, Tabela 1.1, utilizados ao longo da coleção para os exemplos abordados, como também para o próprio desenvolvimento dos livros. TABELA 1.1: Pacotes a serem instalados para o acompanhamento dos exemplos e exercícios da coleção Estudando o ambiente R. Pacote Finalidade lobstr Estudar a sintaxe do ambiente R codetools Estudar a sintaxe do ambiente R XR Estudar a sintaxe do ambiente R rlang Estudar a sintaxe do ambiente R sloop Compreender interativamente a programação orientada a objetos styler Auxilia no estilo de código formatR Auxilia no estilo de código distill Criação da página web Referências ADLER, J. R in a Nutshell. Sebastopol: OReilly Media, 2012. BECKER, R. A.; CHAMBERS, J. M.; WILKS, A. R. The New S Language: A Programming Environment for Data Analysis and Graphics. Boca Raton, Flórida: CRC Press, 1988. CHAMBERS, J. M. Software for Data Analysis: Programming with R. New York: Springer, 2008. CHAMBERS, J. M. Extending R. Boca Raton, Florida: Chapman; Hall/CRC, 2016. CHAMBERS, J. M.; HASTIE, T. J. Statistical Methods in S. London: Chapman &amp; Hall, 1991. CHAMBERS, J. M.; HASTIE, T. J. Programming with Data: A Guide to the S Language. Ney York: Springer, 1998. GROSSER, M.; BUMAN, H.; WICKHAM, H. Advanced R Solutions. 2nd. ed. Boca Raton, Florida: Chapman; Hall/CRC, 2021. WICKHAM, H. R Packages. 2nd. ed. [s.l.] OReilly Media, 2015. WICKHAM, H. Advanced R. 2nd. ed. Boca Raton, Florida: Chapman; Hall/CRC, 2019. WICKHAM, H.; GROLEMUND, G. R for Data Science. Sebastopol: OReilly Media, 2017. Do inglês, Integrated Development Environment, que significa ambiente de desenvolvimento integrado "],["história-e-instalação-do-r.html", "Capítulo 2 História e instalação do R 2.1 O que é o R ? 2.2 Instalação do R e RStudio", " Capítulo 2 História e instalação do R A linguagem R tem a sua primeira aparição científica publicada em 1996, com o artigo intitulado R: A Language for Data Analysis and Graphics, cujos os autores são os desenvolvedores da linguagem, George Ross Ihaka e Robert Clifford Gentleman. FIGURA 2.1: Criadores do R. Durante a época em que estes professores trabalhavam na Universidade de Auckland, Nova Zelândia, desenvolvendo uma implementação alternativa da lingugagem S, desenvolvida por John Chambers, que comercialmente era o S-PLUS, nasceu em 1991, o projeto da linguagem R , em que em 1993 o projeto é divulgado e em 1995, o primeiro lançamento oficial, como software livre com a licença GNU. Devido a demanda de correções da linguagem que estava acima da capacidade de atualização em tempo real, foi criado em 1997, um grupo central voluntário, responsável por essas atualizações, o conhecido R Development Core Team2, que hoje está em 20 membros (atualizado em 5 de novembro de 2021): Douglas Bates, John Chambers, Peter Delgaard, Robert Gentleman, Kurt Hornik, Ross Ihaka, Tomas Kalibera, Michael Lawrence, Friedrich Leisch, Uwe Ligges, Thomas Lumley, Martin Maechler, Sebastian Meyer, Paul Murrel, Martyn Plummer, Brian Ripley, Deepayan Sarkarm, Duncan Temple Lang, Luke Tierney e Simon Urbanek. Por fim, o CRAN (Comprehensive R Archive Network) foi oficialmente anunciado em 23 de abril de 1997 3. O CRAN é um conjunto de sites (espelhos) que transportam material idêntico, com as contribuições do R de uma forma geral. 2.1 O que é o R ? R é uma linguagem de programação e ambiente de software livre e código aberto (open source). Entendemos4: Software livre: software que respeita a liberdade e sendo de comunidade dos usuários, isto é, os usuários possuem a liberdade de executar, copiar, distribuir, estudar, mudar, melhorar o software. Ainda reforça que um software é livre se os seus usuários possuem quatro liberdades: Liberdade 0 - A liberdade de executar o programa como você desejar, para qualquer propósito; Liberdade 1 - A liberdade de estudar como o programa funciona, e adaptá-la as suas necessidades; Liberdade 2 - A liberdade de redistribuir cópias de modo que você possa ajudar outros; Liberdade 3 - A liberdade de distribuir cópias de suas versões modificadas a outros; Algo que deve estar claro é que um software livre não significa não comercial. Sem esse fim, o software livre não atingiria seus objetivos. Agora perceba que, segundo Richard Stallman, a ideia de software livre faz campanha pela liberdade para os usuários da computação. Por outro lado, o código aberto valoriza principalmente a vantagem prática e não faz campanha por princípios. Código aberto: Para Richard Stallman 6 código aberto apoia critérios um pouco mais flexíveis que os do software livre. Todos os códigos abertos de software livre lançados se qualificariam como código aberto. Quase todos os softwares de código aberto são software livre, mas há exceções, como algumas licenças de código aberto que são restritivas demais, de forma que elas não se qualificam como licenças livres. Nesse contexto, o autor cita muitas situações que diferenciam os dois termos. Vale a pena a leitura. A linguagem R é uma combinação da linguagem S com a semântica de escopo léxico da linguagem Scheme. Dessa forma, a linguagem R se diferencia em dois aspectos principais 7: Gerenciamento de memória: usando as próprias palavras de Ross Ihaka, em R, alocamos uma quantidade fixa de memória na inicialização e a gerenciamos com um coletor de lixo dinâmico. Isso significa que há muito pouco crescimento de heap e, como resultado, há menos problemas de paginação do que os vistos em S. Escopo: na linguagem R, as funções acessam as variáveis criadas pelo o corpo da própria função, como também as variáveis contidas no ambiente que a função foi criada. No caso da linguagem S, isso não ocorre, assim, como por exemplo na linguagem C, em que as funções acessam apenas variáveis definidas globalmente. Vejamos alguns exemplos para entendimento (Se você ainda não está ambientado ao R, estude esse módulo primeiro, e depois reflita sobre esses exemplos). Antes de executar as linhas de comando, instale o pacote lobstr como segue: \\[CODIGO\\] Como a linguagem S é uma linguagem interpretada cuja base é a linguagem FORTRAN, a linguagem R também é uma linguagem interpretada e baseada além da linguagem S, tem como base as linguagens de baixo nível C, FORTRAN e a própria linguagem R. Embora o R tenha uma interface baseada em linhas de comando, existem muitas interfaces gráficas ao usuário com destaque ao RStudio, criado por Joseph J. Allaire, Figura 2.2. FIGURA 2.2: J. J. Allaire, o criador do RStudio Essa interface tornou o R mais popular, pois além de produzir,hoje, pacotes de grande utilização como a família de pacotes tidyverse, rmarkdown, shiny, dentre outros, permite uma eficiente capacidade de trabalho de análise de utilização do R. Uma vez que o RStudio facilita a utilização de muitos recursos por meio de botões, como por exemplo, a criação de um pacote R. Há quem diga que para um iniciante em R, não seja recomendado utilizar o RStudio para o entendimento da linguagem. Cremos, que o problema não é a IDE utilizada, e sim, o caminho onde deseja chegar com a linguagem R. No Brasil, o primeiro espelho do CRAN foi criado na UFPR, pelo grupo do Prof. Paulo Justiniano. Inclusive um dos primeiros materiais mais completos sobre a linguagem R produzidos no Brasil, foi dele, iniciado em 2005, intitulado Introdução ao Ambiente Estatístico R. Vale a pena assistirmos do evento a palestra: R Reflexões: um pouco de história e experiências com o R, proferida pelo Prof. Paulo Justiniano Ribeiro Júnior, no R Day - Encontro nacional de usuários do R, ocorrido em 2018 em Curitiba/UFPR, do qual o vídeo está disponível no Canal (Youtube) LEG UFPR. 2.2 Instalação do R e RStudio Para realizarmos a instalação do ambiente R , uma vez que o RStudio é apenas uma IDE, e sem o R, não há sentido instalá-lo, seguimos os seguintes passos: Instalação do R - https://www.r-project.org, Figura 2.3 e 2.4: FIGURA 2.3: Primeiro passo para Instalação do R FIGURA 2.4: Segundo passo para Instalação do R Instalação do RStudio - https://rstudio.com/products/rstudio/download/#download: Justificamos a utilização do RStudio pela quantidade de recursos disponíveis e a diversidade de usuários R, que hoje o perfil não é apenas de um programador, mas de um usuário que necessita de uma ferramenta estatística para análise de seus dados. Dessa forma, até por questão de praticidade, e de uso pessoal, não deixaremos de repassar o entendimento sobre a linguagem R com o uso do RStudio. Outra coisa importante, é que esses passos para a instalação do R e RStudio se basearam no sistema operacional Windows, mas para detalhes sobre essas instalações em outros sistemas operacionais, acesse: https://bendeivide.github.io/cursor. FIGURA 2.5: Instalação do RStudio "],["como-o-r-trabalha.html", "Capítulo 3 Como o R trabalha? 3.1 Como utilizar o R e o RStudio 3.2 Comandos no R 3.3 Ambiente Global (área de trabalho ou Workspace) 3.4 Arquivos .RData e .Rhistory 3.5 Criando e salvando um script", " Capítulo 3 Como o R trabalha? Iniciamos a discussão por uma afirmação de John McKinley Chambers, do qual afirmou que o R tem três princípios (Chambers 2016): knitr::include_graphics(&quot;img/Criador_S.PNG&quot;) FIGURA 3.1: John Chambers2, o criador da linguagem S. Princípio do Objeto: Tudo que existe em R é um objeto; Princípio da Função: Tudo que acontece no R é uma chamada de função; Princípio da Interface: Interfaces para outros programas são parte do R; Ao longo de todo o curso, para os três módulos, iremos nos referir a esses princípios. Vamos inicialmente observar uma adaptação da ilustração feita por Paradis (2005), mostrando como o R trabalha, Figura 3.2. Toda ação que acontece no R é uma chamada de função (Operadores e funções), que por sua vez é armazenada na forma de um objeto, e este se associa a um nome. A forma de execução de uma função é baseada em argumentos (dados, fórmulas, expressões, etc), que são entradas, ou argumentos padrões que já são pré-estabelecidos na criação da função. Esses tipos de argumentos podem ser modificados na execução da função. Por fim, a saída é o resultado, que é também um objeto, e pode ser usado como argumento de outras funções. knitr::include_graphics(&quot;img/Funcionamento_R.PNG&quot;) FIGURA 3.2: Esquema de como o R funciona. Na Figura 3.2, observamos que todas as ações realizadas sobre os objetos ficam armazenadas na memória ativa do computador. Esses objetos são criados por comandos (teclado ou mouse) através de funções ou operadores (chamada de função), dos quais leem ou escrevem arquivos de dados do disco rígido, ou leem da própria internet. Por fim, o resultado desses objetos podem ser apresentados no console (memória ativa), exportados em formato de imagem, página web, etc. (disco rígido), ou até mesmo ser reaproveitado como argumento de outras funções, porque o resultado também é um objeto. 3.1 Como utilizar o R e o RStudio A primeira ideia que temos sobre a linguagem R é a linha de comando, que é simbolizada pelo prompt de comando &gt;. Este símbolo significa que o R está pronto para receber os comandos do usuário. O prompt de comando está localizado no console do R. Vejamos o console do R a seguir, que é o local que recebe as linhas de comando do usuário, Figura 3.3. O R ao ser iniciado, está pronto para receber as linhas de comando desejadas. Uma forma simples de armazernar os seus comandos é por meio de um script, isto é, um arquivo de texto com extensão .R. Para criar, basta ir em: Arquivo &gt; Novo script. Veremos muitas outras informações ao longo do curso. O RStudio se apresenta como uma interface para facilitar a utilização do R, tendo por padrão quatro quadrantes, demonstrado na Figura 3.4 Muitas coisas na interface do R podem se tornar problemas para os usuários, uma vez que janelas gráficas, janelas de scripts, dentre outras, se sobrepõe. Uma vantagem no RStudio foi essa divisão de quadrantes, que torna muito mais organizado as atividades realizadas no R.De um modo geral, diremos que o primeiro quadrante é responsável pela entrada de dados, comandos, isto é, o input. O segundo quadrante, que é o console do R , representa tanto entrada como saída de informações (input/output). Dependendo as atividades as abas podem aumentar. O terceiro quadrante representa informações básicas como objetos no ambiente global, a memória de comandos na aba History, dentre outras, e também representa entrada como saída de informações (input/output). Por fim, o quarto quadrante é responsável por representação gráficas, instalação de pacotes, renderização de páginas web. knitr::include_graphics(&quot;img/Console_do_R.PNG&quot;) FIGURA 3.3: Console do R (Versão 4.0.3). knitr::include_graphics(&quot;img/Interface_RStudio.PNG&quot;) FIGURA 3.4: Interface do RStudio (Versão 1.4.1103). 3.2 Comandos no R 3.2.1 Console e Prompt de comando Como falado anteriormente, o R é uma linguagem baseada em linhas de comando, e as linhas de comando, são executadas uma de cada vez, no console. Assim que o prompt de comando está visível na tela do console, o R indica que o usuário está pronto para inserir as linhas de comando. O símbolo padrão do prompt de comando é &gt;, porém, ele pode ser alterado. Para isso, use a linha de comando, por exemplo ?? R&gt;options(prompt = &quot;R&gt;&quot;) R&gt;# Toda vez que o console iniciar, começarar por &#39;R&gt;&#39; R&gt;10 ## [1] 10 O conjunto de símbolos que podem ser utilizados no R depende do sistema operacional e do país em que o R está sendo executado. Basicamente, todos os símbolos alfanuméricos podem ser utilizados, mas para evitar problemas quanto ao uso das letras aos nomes, opte pelos caracteres ASCII. A escolha do nome associado a um objeto tem algumas regras: Deve consistir em letras, dígitos, . e _; Os nomes devem ser iniciado por uma letra ou um ponto não seguido de um número, isto é, Ex.: .123, 1n, dentre outros; As letras maiúsculas se distinguem das letras minúsculas; Não pode inicia por _ ou dígito, é retornado um erro no console caso isso ocorra; Não pode usar qualquer uma das palavras reservadas pela linguagem, isto é, TRUE, FALSE, if, for, dentre outras, que pode ser consultado usando o comando ?Reserved(). Um nome que não segue essas regras é chamado de um nome não sintático. Um comando que pode ser usado para converter nomes não sintatícos em nomes sintáticos é make.names. # Nome nao sintatico .123 &lt;- 50 ## Error in 0.123 &lt;- 50 : lado esquerdo da atribuicao inválida (do_set) # Qual a sugestao de nome sintatico para &#39;.123&#39;? make.names(.123) [1] &quot;X0.123&quot; Apesar dessas justificativas, algumas situações como as apresentadas nos exemplos anteriores são possíveis, ver Wickham (2019) na Seção 2.2.1. 3.2.2 Comandos elementares Os comandos elementares podem ser divididos em expressões e atribuições. Por exemplo, podemos estar interessados em resolver a seguinte expressão \\(10+15=25\\). No console quando passamos pelo comando: R&gt;10 + 15 ## [1] 25 No console quando passamos pelo comando do Código R 4.2, o R avalia essa expressão internamente e imprime o resultado na tela, após apertar o botão ENTER do teclado. Esse fato é o que ocorre no segundo princípio mencionado por Chambers (2016), tudo em R acontece por uma chamada de função. Na realidade o símbolo + é uma função interna do R , que chamamos de função primitiva, porque foi implementada em outra linguagem. Assim, esse é o resultado de três objetos (10, +, 15) que são avaliados internamente, do qual a função +(e1, e2) é chamada, e em seguida o resultado é impresso no console. Intrinsecamente, podemos também afirmar que a função print() também trabalha nessa situação, fazendo o papel de imprimir o resultado no console. Do mesmo modo, se houver algum problema em algum dos objetos o retorno da avaliação pode ser uma mensagem de erro. Um caso muito prático é quando utilizamos o separador de casas decimais, sendo a vírgula ,, para os números. Quando na realidade deve ser um ponto ., respeitando o sistema internacional de medidas. A vírgula é utilizada para separar elementos, argumentos em uma função, etc. Vejamos um exemplo no Código R 4.3. 10.5 + 15.5 ## [1] 26 Porém, tem que ficar claro que uma expressão é qualquer comando repassado no console. Este comando é avaliado e seu resultado impresso, há menos que explicitamente o usuário queira tornálo invisível. Caso algum elemento do comando não seja reconhecido pelo R, há um retorno de alguma mensagem em forma de erro ou alerta, tentando indicar o possível problema. Todos esses processos ocorrem na memória ativa do computador, e uma vez o resultado impresso no console, o valor é perdido, há menos que você atribua essa expressão a um nome, que erroneamento usamos o termo: criamos um objeto!. A atribuição dessa expressão será dada pela junção de dois símbolos &lt;-, falado mais a frente. Um comando em forma de atribuição também avalia a sua expressão, um nome se associa ao seu resultado, e o resultado será mostrado, se posteriormente, após a execução você digitar o nome atribuído a esse resultado. Vejamos um exemplo o Código R 4.4. # Foi criado um objeto do tipo caractere e o nome &quot;meu_nome&quot; foi associado a ele # O &#39;R&#39; avalia essa expressão, mas não imprime no console! meu_nome &lt;- &quot;Ben&quot; # Para imprimir o resultado da expressão, digitamos o nome &quot;meu_nome&quot; no console # e apertamos o botão ENTER do teclado! meu_nome ## [1] &quot;Ben&quot; 3.2.3 Execução de comandos Quando inserimos um comando no console, executamos uma linha de comando por vez ou separados por ; em uma mesma linha. Vejamos o Código # Uma linha de comando por vez meu_nome &lt;- &quot;Ben&quot; # Criamos e associamos um nome ao objeto meu_nome # Imprimos o objeto ## [1] &quot;Ben&quot; # Tudo em uma linha de comando meu_nome &lt;- &quot;Ben&quot;; meu_nome ## [1] &quot;Ben&quot; Se um comando for muito grande e não couber em uma linha, ou caso deseje completar um comando em mais de uma linha, após a primeira linha haverá o símbolo + iniciando a linha seguinte ao invés do símbolo de prompt de comando (&gt;), até que o comando esteja sintaticamente completo. Vejamos o Código R 4.6, a seguir. # Uma linha de comando em mais de uma linha (10 + 10) / 2 ## [1] 10 Por fim, todas linhas de comando quando iniciam pelo símbolo jogo da velha, # indica um comentário e essa linha de comando não é avaliada pelo console, apenas impressa na tela. E ainda, as linhas de comandos no console são limitadas a aproximadamente 4095 bytes (não caracteres). 3.2.4 Chamada e correção de comandos anteriores Uma vez que um comando foi executado no console, esse comando por ser recuperado usando as teclas de setas para cima e para baixo do teclado, recuperando os comandos anteriorermente executados, e que os caracteres podem ser alterados usando as teclas esquerda e direita do teclado, removidas com o botão Delete ou Backspace do teclado, ou acrescentadas digitando os caracteres necessários. Uma outra forma de completar determinados comandos já existentes, como por exemplo, uma função que já existe nas bibliotecas de instalação do R, usando o botão Tab do teclado. O usuário começa digitando as iniciais, e para completar o nome aperta a tecla Tab. Posteriormente, basta completar a linha de comando e apertar ENTER para executá-la. Para entender mais detalhes, acesse o link: https://youtu.be/0MRPmVsPvk4, e veja em vídeo-aula mais detalhes. Esses recursos no RStudio são mais dinâmicos e vão mais além. Por exemplo, quando usamos um objeto do tipo função, estes apresentam o que chamamos de argumento(s) dentro do parêntese de uma função, do qual são elementos necessários, para que a função seja executada corretamente. Nesse caso, ao inseri o nome dessas funções no console, usando o RStudio, ao iniciá-la com a abertura do parêntese, abre-se uma janela informando todos os argumentos possíveis dessa função. Isso torna muito dinâmico escrever linhas de comando, porque não precisaremos estar lembrando do nome dos argumentos de uma função, mas apenas entender o objetivo dessa função. Para entender mais detalhes, acesse o link: https://youtu.be/KL3WAB_GFNI, e veja em vídeo-aula mais detalhes. 3.3 Ambiente Global (área de trabalho ou Workspace) Quando usamos um comando de atribuição no console, o R armazena o nome associado ao objeto criado na área de trabalho (Workspace), que nós chamamos de Ambiente Global. Teremos uma seção introdutória na seção Ambientes e caminhos de busca, mas entendamos inicialmente que o objetivo de um ambiente é associar um conjunto de nomes a um conjunto de valores. Vejamos o Código R 4.7. # Nomes criados no ambiente x &lt;- 10 - 6; y &lt;- 10 + 4; w &lt;- &quot;Maria Isabel&quot; # Verificando o nomes contidos no ambiente global ls() ## [1] &quot;meu_nome&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; Observemos que todos os objetos criados até o momento estão listados, e o que é mais surpreendente é que ambientes podem conter outros ambientes e até mesmo se conterem. Observe o objeto meu_nome é um ambiente e está contido no Ambiente global. Será sempre dessa forma que recuperaremos um objeto criado no console do R . Caso contrário, se no console esse comando não for de atribuição esse objeto é perdido. 3.4 Arquivos .RData e .Rhistory Ao final do que falamos até agora, todo o processo ao inserir linhas de comando do console, e desejarmos finalizar os trabalhos do ambiente R , dois arquivos são criados, sob a instrução do usuário em querer aceitar ou não, um .RData e outro .Rhistory, cujas finalidades são: .RData: salvar todos os objetos criados que estão atualmente disponíveis; .Rhistory: salvar todas as linhas de comandos inseridas no console. Ao iniciar o R no mesmo diretório onde esses arquivos foram salvos, é carregado toda a sua área de trabalho anteriormente, bem como o histórico das linhas de comando utilizadas anteriormente. 3.5 Criando e salvando um script A melhor forma de armazenarmos nossas linhas de código inseridas no console é criando um Script. Este é um arquivo de texto com a extensão .R. Uma vez criada, poderemos ao final salvar o arquivo e guardá-lo para utilizar futuramente. No R , ao ser iniciado poderemos ir no menu em Arquivo &gt; Novo script. Posteriormente, pode ser inserido as linhas de comando, executadas no console pela tecla de atalho F5. As janelas do Script e console possivelmente ficarão sobrepostas. Para uma melhor utilização, estas janelas podem ficar lado a lado, configurando-as no menu em Janelas &gt; Dividir na horizontal (ou Dividir lado a lado). No RStudio, poderemos criar um Script no menu em File &gt; New File &gt; R Script, ou diretamente no ícone abaixo da opção File no menu, cujo o símbolo é um arquivo com o símbolo + em verde, que é o ícone do New File, e escolher R Script. Esse arquivo abrirá no primeiro quadrante na interface do RStudio. Para salvar, devemos clicar no botão com o símbolo de disquete (R/RStudio), escolher o nome do arquivo e o diretório onde o arquivo será armazenado no seu computador. Algumas ressalvas devem ser feitas: Escolha sempre um nome sem caracteres especiais, com acentos, etc.; Escolha sempre um nome curto ou abreviado, que identifique a finalidade das linhas de comando escritas; Evite espaços se o nome do arquivo for composto. Para isso, use o símbolo underline _; Quando escrever um código, evite também escrever caracteres especiais, exceto em casos de necessidade, como imprimir um texto na tela, títulos na criação de gráficos, dentre outras. Nos referimos especificamente, nos comentários do código. Um ponto bem interessante é o diretório. Quando criamos um Script a primeira vez, e trabalhamos nele a pós a criação, muitos erros podem ser encontrados de início. Um problema clássico é a importação de dados. O usuário tem um conjunto de de dados e deseja fazer a importação para o R , porém, mesmo com todos os comandos corretos, o console retorna um erro, informando que não existe esse arquivo que contém os dados para serem informados. Isso é devido ao diretório de trabalho atual. Para verificar qual o diretório que está trabalhando no momento, use a linha de comando: getwd() Para alterar o diretório de trabalho, o usuário deve usar a seguinte função setwd(Aqui, deve ser apontado para o local desejado!). Supomos que salvamos o nosso Script em C:_scripts_r. Assim, usamos a função setwd() e ao apontarmos o local, as barras devem ser inseridas de modo invertido, isto é, setwd(C:/meu_scripts_r), além de estar entre aspas. No RStudio , isso pode ser feito em Session &gt; Set Working Directory &gt; To Source File Location. Isso levará ao diretório corrente do Script. Se desejar escolher outro diretório, vá em Session &gt; Set Working Directory &gt; Choose Directory. Porém, uma vez criado um Script, e utilizado novamente, se o usuário estiver abrindo o RStudio também naquele primeiro momento, por padrão, o diretório de trabalho corrente será o mesmo do diretório do Script. Isso acaba otimizando o trabalho. Devemos nos atentar também, quando trabalhamos utilizando Scripts ou arquivos de banco de dados, em locais diferentes do diretório corrente. Um outro recurso interessante é a função source(), que tem o objetivo de executar todas as linhas de comando de um Script sem precisar abri-lo. Isso pode ser útil, quando criamos funções para as nossas atividades, porém elas não se encontram no Script de trabalho para o momento. Assim, podemos criar um Script auxiliar que armazenas todas as funções criadas para as análises desejadas, e no Script corrente, poderemos chamá-las sem precisar abri o Script auxiliar. Todos os objetos passam a estar disponíveis no ambiente global. Por fim, algo de muita importância para um programador e usuário de linguagem, comente suas linhas de comando. Mas faça isso a partir do primeiro dia em que foi desenvolvido o primeiro Script. Isso criará um hábito, uma vez que o arquivo não está sendo criado apenas para um momento, mas para futuras consultas. E quando voltamos a Scripts com muitas linhas de comando, principalmente depois de algum tempo, e sem comentários, possivelmente você passará alguns instantes para tentar entender o que foi escrito. Outra coisa importante, é a boa prática de escrita de um código, Capítulo ??, e o RStudio nos proporciona algumas ferramentas interessantes. Mas isso será visto mais a frente. Fonte da foto: Retirada de sua página pessoal, https://statweb.stanford.edu/~jmc4/ "],["objetos-e-estrutura-de-dados.html", "Capítulo 4 Objetos e estrutura de dados 4.1 Atributos 4.2 Coersão 4.3 Tipo de objetos", " Capítulo 4 Objetos e estrutura de dados 4.1 Atributos 4.1.1 Atributos intrínsecos 4.2 Coersão 4.3 Tipo de objetos 4.3.1 Vetores 4.3.1.1 Vetores escalares 4.3.1.2 Vetores longos 4.3.1.3 Manipulando vetores 4.3.2 Matrizes bidimensionais 4.3.3 Matrizes multidimensionais 4.3.4 Listas 4.3.5 Quadro de dados 4.3.6 Funções 4.3.6.1 Estruturas de controle 4.3.6.2 Como criar funções 4.3.6.3 Escopo léxico "],["importação-e-exportação-de-dados.html", "Capítulo 5 Importação e exportação de dados 5.1 Introdução 5.2 Preparação dos dados 5.3 Importando dados 5.4 Exportando dados", " Capítulo 5 Importação e exportação de dados 5.1 Introdução A importação/exportação de dados era algo que em poucas linhas conseguíamos explicar sobre o ambiente R , no sentido de análise de dados. Entretanto, observando o terceiro princípio do R, afirmado por Chambers (2016): Interfaces para outros programas são parte do R. Hoje é uma realidade a interação que o ambiente R tem com outras interfaces (programas, linguagens, etc.). A facilidade em utilizar outras linguagens dentro do ambiente R torna assim mais complexo a importação/exportação de dados, uma vez que o objetivo do R , apesar do R Core Team ainda limitar a sua definição como o ambiente para a computação estatística, a ferramenta se tornou tão versátil, que hoje torna humilde essa definição. Para mais detalhes acesse o manual ??R Data Import/Export (R CORE TEAM, 2021a). Um outro fator e tema atual é a era dos grandes bancos de dados (Big Data), do qual se tem um grande conjunto de variáveis e necessitamos fazer a importação por APIs1 ,por exemplo, ou outras vias. Temas como esses, serão abordados em outros volumes da coleção Estudando o Ambiente R. Nesse momento, limitaremos esse assunto ao objetivo de termos um conjunto de dados em arquivos de texto (extensões do tipo .txt, .csv, .xls), formato binário (.xls ou .xlsx) ou digitados manualmente pelo teclado do computador. Assim, a primeira forma de como os dados estão dispostos, precisaremos importá-los e armazená-los em um quadro de dados (data frame), para que esteja disponível na área de trabalho (ambiente global) do R , e dessa forma, possamos utilizá-lo. Ao final do tratamento dos dados, podemos exportar essas informações para arquivos externos, e daí também, usaremos os arquivos de textos e o formato binário (.xls), mensionados anteriormente. 5.2 Preparação dos dados A primeira coisa que devemos entender quando desejamos construir o arquivo de dados, é entender que sempre organizaremos as variáveis em colunas, com os seus valores em linhas, Figura ??fig:bdados). Sempre a primeira linha das colunas representarar o nome das variáveis. Esse é outro ponto importante, pois devemos ter a noção que alguma linguagem irá ler esse banco de dados. Assim, quanto mais caracteres diferentes do padrão ASCII, mais difícil será a leitura desses dados. Assim, sugerimos alguns padrões: Evitem símbolos fora do padrão alfanumérico; Evitem mistura de letras minúsculas com letras maiúsculas. Isso facilitará o acesso a essas variáveis. Contudo, lembremos do padrão de nomes sintéticos permissíveis observados na seção 3.3.2; Lembremos que o banco de dados será utilizado para que um programa faça a sua leitura, portanto, deixemos a formatação da apresentação dos dados para arquivos específico. Sendo assim, evitem comentários nesses arquivos, ou qualquer outro tipo de informação que não seja o banco de dados; Evitem palavras longas, por exemplo, segundavariavel (má escolha), segvar (boa escolha), seg_var (boa escolha); Evitem palavras compostas com espaço entre elas. Para isso use o símbolo _, por exemplo, var 2 (má escolha), var2 (boa escolha), var_2 (boa escolha); knitr::include_graphics(&quot;img/Modelo_Estrutural_Banco_Dados.png&quot;) FIGURA 5.1: Modelo estrutural de um banco de dados. 5.3 Importando dados A função primária responável pela importação de dados é a função scan(). Por exemplo, funções como read.table(), read.csv() e read.delim(), usam a função scan() em seu algoritmo. A primeira ideia sobre importação de dados pode ser inserindo-os pelo teclado no próprio ambiente R . Para isso, usaremos a função scan(), isto é, &gt; # Criando e inserido os elementos do objeto dados &gt; x &lt;- scan() Após executado essa linha de comando, aparecerá no console 1: que significa, digitar o primeiro valor do objeto x, e depois clicar em ENTER. Depois 2:, que significa digitar o segundo valor, e clicar em ENTER. Depois de inserido todos os valores necessários, aperte a tecla ENTER duas vezes no console, para sair da função scan(). O mais tradicional é usar programa para criação de banco de dados e deixá-lo pronto para o R lê-lo. O tipo de arquivo de texto que melhor controla a separação de variáveis é com a extensão .csv, uma vez que separamos as variáveis por ;, é o padrão. O arquivo de texto com extensão .txt, geralmente usa espaços. Isso acaba gerando problema de leitura no R , porque muitos usuários usam nomes de variáveis muito grandes, palavras compostas, de forma a desalinhar as colunas das variáveis. Daí, como a separação das variáveis é por meio de espaços, acaba gerando problema de leitura. Uma outra forma, é fazer importação de dados gerados pelo próprio R , extensão .RData. Temos a opção de usar um editor de banco de dados para essas extensões por meio de programas como MS Excel, Libre Office, dentre outros. Estes exportam arquivos binários do tipo .xls, .xlsx, dentre outros. Uma sugestão para diminuir complicações, é exportar os bancos de dados para arquivos de texto sitados acima, que também é possível ser exportado por esses programas. Isso evita a necessidade de ser instalado mais pacotes e dor de cabeça. Porém, para quem ainda deseja enfrentar, sugerimos a leitura do pacote readr, como exemplo, porém existem diversos outros pacotes para este mesmo fim. Uma vez que o banco de dados está pronto, a leitura destes pode ser feita por alguns caminhos. Mostraremos o mais trivial que é o botão Import Dataset, terceiro quadrante, aba Environment, na IDE do RStudio , como observado na Figura 5.2. knitr::include_graphics(&quot;img/Importando_Dados_01.png&quot;) FIGURA 5.2: Usando o RStudio para importar dados Posteriormente, indique o arquivo para leitura. Aparece algumas opções de tipo de arquivo. Em nosso caso, usaremos a opção From Text (base), que significa realizar a leitura para os tipos de arquivo .txt ou .csv. Daí os passos seguintes são: Escolher o arquivo para leitura dos dados Figura 5.2; Configurar a leitura do banco de dados. Uma prévia pode ser vista no quadro Data Frame. Se for visualizado, algum problema, isso significa que deve ser informado opções adicionais como separador de variáveis (Separator), símbolo para casas decimais (Decimal), dentre outras opções. Por fim, digitar o nome associado ao objeto (Name) que será criado do tipo quadro de dados (data frame), e clicar no botão Import Figura 5.3; Uma vez inserido, o RStudio apresenta a linha de comando utilizada para importar os dados no console (2º quadrante), o conjunto de dados (1º quadrante), e a ligação entre o nome e o objeto no ambiente global (3º quadrante), Figura 5.4; A outra forma é utilizar linhas de comando. Para isso utilizaremos a função read.table(). Antes de importarmos o banco de dados, algo interessante é inserir o arquivo de dados no diretório de trabalho no ambiente R . Para verificar o ambiente de trabalho use a função getwd(). Para alterar o local do ambiente de trabalho use setwd(). Se esse procedimento não for realizado, o usuário deve informar na função read.table(), o local exato do arquivo de texto. Vamos usar como diretório o local C:. Lembre-se que no R , a barra deve ser invertida. Vamos inserir nesse diretório três arquivos alfafa.txt, datast1980.txt e producao.csv. Os três conjuntos de dados são: knitr::include_graphics(&quot;img/Importando_Dados_02.png&quot;) FIGURA 5.3: Usando o RStudio para importar dados knitr::include_graphics(&quot;img/Importando_Dados_03.png&quot;) FIGURA 5.4: Usando o RStudio para importar dados knitr::include_graphics(&quot;img/Importando_Dados_04.png&quot;) FIGURA 5.5: Usando o RStudio para importar dados TRAT BLOCO PROD A I 2.89 A II 2.88 A III 1.88 A IV 2.90 A V 2.20 A VI 2.65 B I 1.58 B II 1.28 B III 1.22 B IV 1.21 B V 1.30 B VI 1.66 C I 2.29 C II 2.98 C III 1.55 C IV 1.95 C V 1.15 C VI 1.12 D I 2.56 D II 2.00 D III 1.82 D IV 2.20 D V 1.33 D VI 1.00 trt y 1 19,4 1 32,6 1 27,0 1 32,1 1 33,0 2 17,7 2 24,8 2 27,9 2 25,2 2 24,3 3 17,0 3 19,4 3 9,1 3 11,9 3 15,8 4 20,7 4 21,0 4 20,5 4 18,8 4 18,6 5 14,3 5 14,4 5 11,8 5 11,6 5 14,2 6 17,3 6 19,4 6 19,1 6 16,9 6 20,8 X y 1 6.7 2 7.9 3 9.1 4 6.6 5 7.5 6 8.8 7 7.7 8 7.6 9 6.5 10 7.9 11 8.7 12 6.2 13 7.9 14 7.4 15 9.7 16 6.2 17 4.9 18 5.6 19 7 20 6 Vejamos as linhas de comando para importar os dados, Código R 5.1. &gt; # Diretorio &gt; getwd() &gt; # Mudadando para o diretorio de interesse &gt; setwd(&quot;C:/cursor&quot;) &gt; # Verificando os arquivos no diretorio de trabalho &gt; list.files() &gt; # Importando os dados apontando para o diretorio do arquivo &gt; dados1 &lt;- read.table(file = &quot;C:/cursor/alfafa.txt&quot;, header = TRUE) &gt; # Considerando que o arquivo esta no diretorio de &gt; # trabalho, isto eh, getwd() &gt; dados2 &lt;- read.table(&quot;alfafa.txt&quot;, header = TRUE) &gt; # Importando os dados com decimais com &#39;,&#39; apontando para o diretorio do &gt; arquivo &gt; dados3 &lt;- read.table(file = &quot;C:/cursor/dadost1980.txt&quot;, header = TRUE, dec = + &quot;,&quot;) &gt; # Considerando que o arquivo esta no diretorio de &gt; # trabalho, isto eh, getwd() &gt; dados4 &lt;- read.table(file = &quot;dadost1980.txt&quot;, header = TRUE, dec = &quot;,&quot;) &gt; # Importando os dados com decimais &#39;,&#39;, e separados por &#39;;&#39; apontando para o diretorio do arquivo &gt; dados5 &lt;- read.table(file = &quot;C:/cursor/producao.csv&quot;, header = TRUE, dec = + &quot;,&quot;, sep = &quot;;&quot;) &gt; # Considerando que o arquivo esta no diretorio de &gt; # trabalho, isto eh, getwd() &gt; dados6 &lt;- read.table(file = &quot;producao.csv&quot;, header = TRUE, dec = &quot;,&quot;, sep = + &quot;;&quot;) &gt; # Importando da internet &gt; dados7 &lt;- read.table(file = + &quot;https://raw.githubusercontent.com/bendeivide/book-eambr01/main/files/ + alfafa.txt&quot;, header = TRUE) Na última linha de comando, mostramos que também é possível importar dados de arquivos de texto da internet, e claro considerando que o usuário está com acesso a internet no momento da importação. E um recurso interessante que pode ser feito, principalmente para este caso, é salvar o banco de dados em um arquivo de dados no .RData. Dessa forma, todos os dados, inclusive os importados da internet serão agora armazenados nesse tipo de arquivo, e não precisaremos, nesse caso, de acesso a internet. Para salvar, usamos a função save(). Para carregar os dados e armazenálo no ambiente global, usamos a função load(), Código R 5.2. &gt; # Diretorio &gt; getwd() &gt; &gt; # Verificando os arquivos do diretorio de trabalho &gt; list.files() &gt; &gt; # Importando os dados da internet &gt; dados7 &lt;- read.table(file = + &quot;https://raw.githubusercontent.com/bendeivide/book-eambr01/main/files/alfafa.txt&quot;, header = TRUE) &gt; &gt; # Salvando em &#39;.RData&#39; &gt; save(dados7, file = &quot;alfafa.RData&quot;) &gt; &gt; # Carregando &#39;.RData&#39; para o ambiente global &gt; load(&quot;alfafa.RData&quot;) Percebemos que as extensões .txt e .csv são idênticos, exceto pela estrutura de como os dados estão dispostos. Para comprovar isso, o usuário manualmente poderá mudar a extensão de um arquivo do tipo .csv para um arquivo .txt e observar em um bloco de notas. Até agora, usamos as funções no R, em algumas situações, sem apresentar os argumentos dessas funções dentro dos parênteses. Isso porque quando inserimos os valores dos argumentos na posição correta destes, não precisaremos inserir o nome dos argumentos. Por exemplo, já usamos anteriormente a função mean() que calcula a média de um conjunto de valores, por exemplo, valores &lt;- 1:10. Temos como primeiro argumento para essa função o x que representa um objeto R que recebe os valores para o cálculo. Assim, como sabemos que x é o primeiro argumento dessa função, podemos omitir o seu nome e calcular a média por mean(valores), que é o mesmo que mean(x = valores). Para mais detalhes, ?mean(), como também, para mais detalhes sobre a função read.table(), use ?read.table() 5.4 Exportando dados "],["funções-no-r.html", "Capítulo 6 Funções no R 6.1 Introdução 6.2 O que é uma função no R? 6.3 Estrutura básica de uma função 6.4 Funções em pacotes 6.5 Chamadas de funções 6.6 Estruturas de controle 6.7 Criando funções 6.8 Escopo léxico", " Capítulo 6 Funções no R 6.1 Introdução Mais uma vez, nos reportamos aos princípios do R (CHAMBERS, 2016), mais especificamente ao segundo princípio, Tudo que acontece no R é uma chamada de função. Quando associamos um nome a um objeto (x &lt;- 10) pelo símbolo de atribuição (&lt;-), o que temos é uma chamada de função realizando esse processo, isto é, &lt;-(x, 10). Ao digitar x no console e posteriormente apertando o botão ENTER do teclado, nos bastidores, estamos na realidade chamando a função print(x) para imprimir o valor que o nome se associa. Desde coisas básicas como essas, até coisas mais complexas, temos sempre por trás uma chamada de função. 6.2 O que é uma função no R? Os princípios falados por Chambers (2016) são interligados, principalmente os dois primeiros, porque apesar de tudo que acontece no R ser uma chamada de função, a função é um objeto, com estrutura definida como qualquer outro objeto, de modo function()1 ,assim como os vetores. Ainda mais, dizemos que a linguagem R tem um estilo funcional, devido a esse fato. Mais isso é assunto para o Volume II. A ideia de função aqui não é pensada como uma relação matemática, mas como um sistema que tem uma entrada e saída. Podemos ter funções no ambiente R que organiza dados, e não operações matemáticas por exemplo. Vejamos a função sort() do pacote base que ordena de forma crescente ou descrescente um conjunto de valores, como pode ser observado no Código R 6.1. As funções de modo closure (funções criadas por meio de function(), do qual o seu modo pode ser verificado por typeof()), apresenta três estruturas básicas: argumento, corpo e ambiente, que será abordada a seguir. 6.3 Estrutura básica de uma função As funções podem ser dividas em três componentes: Argumentos, função formals(), Corpo, função body() e Ambiente, função environment(). Para o caso das funções primitivas, escritas na linguagem C, essa regra foge a excessão, e será detalhado no Volume II. Dizemos que funções são primitivas de modo builtin ou special. Para verificarmos a tipagem desses objetos, devemos sempre usar typeof() ou invés de mode(). &gt; # Vetor &gt; y &lt;- c(5, 3, 4); y ## [1] 5 3 4 &gt; # Funcao &gt; sort(x = y) ## [1] 3 4 5 &gt; # Argumentos da funcao sort &gt; formals(sort) ## $x ## ## ## $decreasing ## [1] FALSE ## ## $... &gt; # Corpo da funcao &gt; body(sort) ## { ## if (!is.logical(decreasing) || length(decreasing) != 1L) ## stop(&quot;&#39;decreasing&#39; must be a length-1 logical vector.\\nDid you intend to set &#39;partial&#39;?&quot;) ## UseMethod(&quot;sort&quot;) ## } &gt; # Ambiente &gt; environment(sort) ## &lt;environment: namespace:base&gt; Nesse caso, os argumentos x, decreascing e , são nomes que aguardam receber objetos para a execução da função sort(). Nem todos os argumentos necessitam receber objetos, a estes chamamos de argumentos padrão, como o caso do argumento decreascing com padrão igual a FALSE, que significa que o ordenamento dos dados será de forma não-decrescente. Observe que na função sort() entramos apenas com o argumento x = y, não precisando inserir decreascing = FALSE. Agora, para modificar o argumento padrão, basta acrescentar a alteração na função, isto é, &gt; # Funcao &gt; sort(x = y, decreasing = TRUE) ## [1] 5 4 3 O  é um argumento especial e significa que pode conter qualquer número de argumentos. Geralmente é utilizado em uma função quando não se sabe o número exato de argumentos. Veremos ainda nesse capítulo mais sobre esse argumento. O próximo item é o corpo da função. É nele que inserirmos as instruções, isto é, as linhas de comandos necessárias a que se destina a sua criação. Uma outra forma de acessarmos o corpo das funções é digitar no console apenas o seu nome sem o parêntese, isto é, sort. Por fim, o ambiente que no caso da função sort() representa o ambiente do pacote base, isto é, o namespace base. 6.4 Funções em pacotes Podemos observar que essas funções utilizadas até agora, não foram criadas pelo usuário. Estas funções vieram do que chamamos de pacotes2. Alguns pacotes estão disponíveis quando instalamos o R , dizemos que estes são os pacotes nativos do R , para a linguagem. O principal pacote deles é o base. Os demais pacotes desenvolvidos podem ser obtidos via CRAN, e falaremos mais adiante. O ambiente R apresenta uma versatilidade de manuais para a linguagem. Por exemplo, para verificar informações sobre um determinado pacote como o base, use help(package = base). A função help() pode ser utilizada para funções de pacotes anexados. Por exemplo, help(sort). Uma outra função que pode ser usada para procurar por funções com determinado parte de nome é apropos(), isto é, para o exemplo anterior, temos apropost(sort). O pacote base sempre estará anexado, isto é, disponível no caminho de busca para a utilização. Para os que não estão anexados, a função help deve informar o nome da função que necessita de ajuda, bem como o seu pacote. Por exemplo, temos uma função read.dbf() do pacote foreign, Base do R , porém, esse pacote não está anexado3 ao inicializar o R. Assim, caso não seja anexado o pacote, basta executar library(foreign) no console. A ajuda sobre a função pode ser realizada com help(read.dbf, package = foreign). Outras sintaxes para a função help() é usar ? antes do nome de uma função de um pacote anexado, isto é, ?sort() para o caso da função estudada. Para os manuais de ajuda na internet, use ?? antes do nome da função, por exemplo ??sort(), read.dbf(), etc. Essa sintaxe não precisa dos pacotes estarem anexados para ajuda de determinada função, porém o pacote necessita estar instalado. Para mais detalhes sobre pacotes, leia o Capítulo 9. 6.5 Chamadas de funções As chamadas de funções podem ocorrer de três formas: aninhada, intermediária ou de forma pipe. Todas essas formas estão implementadas no R de forma nativa, porém este último, foi implementado inicialmente pelo pacote magrittr, e na versão do R 4.1, foi implementado o operador pipe nativo (|&gt;), sendo aprofundado no Volume II. Suponha que desejamos calcular o desvio padrão de um conjunto de valores. Vamos utilizar as três formas de chamadas de função, que segue: Aninhado: &gt; # Gerando 100 numeros aleatorios de uma distribuicao normal &gt; set.seed(10) # Semente &gt; x &lt;- rnorm(100) &gt; # Calculando o desvio padrao &gt; sqrt(var(x)) ## [1] 0.9412359 Intermediária: &gt; # Calculando o desvio padrao &gt; vari &lt;- var(x) &gt; desvpad &lt;- sqrt(vari); desvpad ## [1] 0.9412359 Pipe: &gt; # Para usar o pipe (magrittr), substitua |&gt; por %&gt;%, e instale e anexe o pacote: &gt; # install.packages(magrittr) &gt; library(magrittr) &gt; # Calculando o desvio padrao &gt; x %&gt;% + var()%&gt;% + sqrt() ## [1] 0.9412359 A ideia da chamada de função aninhada é inserir função como argumento de funções sem necessidade de associar nomes aos objetos. A ordem de execução começa sempre da direita para a esquerda. No caso da chamada de função intermediária, associamos nomes a cada função, e os passos seguem. Por fim, o operador especial pipe (%&gt;%) tem como primeiro operando o primeiro argumento da função no segundo operando. Quando desenvolvemos pacotes, preferimos os dois primeiros, pois é a forma tradicional de chamadas de função no R . A chamada de função pipe é muito utilizada para ciência de dados, uma vez que trabalhamos com manipulações de dados, visualizações gráficas, sem necessariamente precisarmos associar nomes aos objetos, de modo a armazenar seus resultados. Dessa forma é preferível o operador pipe. 6.6 Estruturas de controle As funções que utilizaremos, a seguir, são utilizadas quando desejamos realizar processos repetitivos para um determinado fim ou condicionado, as famosas estruturas de controle. Assim, como em outras linguagens, as funções utilizadas são: if(), switch(), ifelse(), while(), repeat, for(). Todos esses nomes são reservados no ambiente R, isto é, não podemos associar esses nomes a objetos. Esses objetos tem modo special4 ,porque as expressão não são necessariamente avaliadas. Já a função ifelse() é de modo closure. Este último é um tipo de objeto que é uma função criada por function(), e será o mesmo tipo de objeto que os usuários terão quando desenvolverem as suas próprias funções. A sintaxe das estruturas de controle de tipo special é: função (condição) { expressão } A sintaxe das funções repeat e swicth() foge um pouco desse padrão, e explicaremos em sua aplicação, mais a frente. Apesar da linguagem R ser interpretada, acaba ganhando a fama de que as funções loops são mais lentas. Em alguns casos, a construção do algoritmo proporciona isso e não a implementação dessas funções em si. Um exemplo que podemos citar, são as cópias de objetos que podem ter um gasto de memória ativa imenso no processo e proporcionar um gasto computacional. E isso foi devido a forma de como o algoritmo copiou os objetos, e não o desempenho das funções loops. Veremos isso em detalhes no Volume II. A primeira estrutura é o if(), com sintaxe: if (condição) { # Corpo do if() #instruções sob condição = TRUE } O fluxograma para o entendimento da função if() pode ser observado na Figura 6.1. Podemos também representar a função if() sintaticamente com a função else da seguinte forma: Agora, acrescentando a função else trabalhando conjuntamente com a função if(), temos a sua forma sintática dada por: if (condição) { # Corpo do if() # instruções sob condição = TRUE } else { # Corpo do else # instruções sob condição = FALSE } em que o fluxograma da combinação dessas duas funções podem ser representados pela Figura 6.1. Uma forma mais simplificada unindo as funções if() e else, resultaram na função ifelse(), que pode ser representada sintaticamente da seguinte forma: knitr::include_graphics(&quot;img/Fluxograma_da_Funcao_if.png&quot;) FIGURA 6.1: Fluxograma da função if() knitr::include_graphics(&quot;img/Fluxograma_da_Funcao_if_else.png&quot;) FIGURA 6.2: Modelo estrutural de um banco de dados if (condição) instr1 if (condição) instr1 else instr2 &gt; # Objeto &gt; i &lt;- 5 &gt; # Estrutura if() &gt; if (i &gt; 3) { + print(&quot;Maiorque3!&quot;) + } ## [1] &quot;Maior&lt;U+2423&gt;que&lt;U+2423&gt;3!&quot; Como observado no Código R 6.2, após associado o nome x associado ao objeto 5, isto é i &lt;- 5, a função if() foi chamada e a condição foi verificada se i &lt; 3. Como essa condição era verdadeira, a expressão sob a condição verdadeira é impressa, e a função if é encerrada. Vejamos mais um exemplo no Código R 6.3, a seguir. &gt; # Objeto numerico &gt; x &lt;- 10 &gt; # Estrutura &#39;if&#39; &gt; if (is.numeric(x)) { + print(&quot;Issoéumnúmero&quot;) + } else { + print(&quot;Issonãoéumnúmero&quot;) + } ## [1] &quot;Isso&lt;U+2423&gt;é&lt;U+2423&gt;um&lt;U+2423&gt;número&quot; &gt; # eh o mesmo que &gt; if (is.numeric(x) == TRUE) { + print(&quot;Issoéumnúmero&quot;) + } else { + print(&quot;Issonãoéumnúmero&quot;) + } ## [1] &quot;Isso&lt;U+2423&gt;é&lt;U+2423&gt;um&lt;U+2423&gt;número&quot; Observamos na primeira forma que a condição para if() avaliar, nós não precisamos perguntar se is.numeric(x) == TRUE, porque isso já é implícito na função, e acaba levando a primeira expressão print(Isso é um número). De todo modo, em um segundo momento explicitamos a condição, e verificamos que o resultado para este caso será o mesmo. No R , essa estrutura de controle não é vetorizado, isto é, se a condição houver um vetor lógico maior que 1, apenas os primeiros itens serão usados. Para entender, vejamos o Código R 6.4. &gt; # Objetos &gt; x &lt;- 5 &gt; w &lt;- 3:8 &gt; # Primeira sintaxe (Preferivel) &gt; if (x &lt; w) { + x + } else { + w + } ## Warning in if (x &lt; w) {: a condição tem comprimento &gt; 1 e somente o primeiro ## elemento será usado ## [1] 3 4 5 6 7 8 &gt; # Segunda forma &gt; if (x &lt; w) x else w ## Warning in if (x &lt; w) x else w: a condição tem comprimento &gt; 1 e somente o ## primeiro elemento será usado ## [1] 3 4 5 6 7 8 Observamos que o fato de x &lt; y ser vetorizado, tivemos problema com a condição if(). A partir de w &gt; 5, o resultado era para ter retornado sempre o valor 5, isto é, o valor verdadeiro (x) para a condição. Isso implica que a condição deve ser sempre entre vetores escalares. Uma saída seria utilizar a função for(), conjugada com if() e else. Porém, como forma de vetorizar essa condição, foi criado a função ifelse(), em que o fluxograma dessa função pode ser observado pela Figura , cuja forma sintática é dada a seguir. ifelse (condição, expressão sob TRUE, expressão sob FALSE) Podemos ver que a aplicação do Código R 6.4 retornou um resultado que não se esperaria como o desejado, pelo fato da função if() não ser vetorizada. Assim, por meio do Código R 6.5 usando knitr::include_graphics(&quot;img/Fluxograma_da_Funcao_ifelse.png&quot;) FIGURA 6.3: Fluxograma da função ifelse() a função ifelse(), verificaremos que esta por ser vetorizada, o resultado retornado ocorre como esperado. &gt; # Objetos &gt; x &lt;- 5 &gt; w &lt;- 3:8 &gt; # Primeira sintaxe (Preferivel) &gt; ifelse(x &lt; w, x, w) ## [1] 3 4 5 5 5 5 Podemos estar interessados em resultados específicos para determinadas condições, e daí, usar o que chamamos de programação defensiva, podendo ser apresentado no Código R 6.6. &gt; x &lt;- 2 # numero &gt; &gt; # Estrutura &#39;if&#39; &gt; if (!is.numeric(x)) { + &quot;Nao_eh_numero&quot; + } else { + if ((trunc(x) %% 2) == 0) { + cat(&quot;numero_par:&quot;, trunc(x)) + } else { + if ((trunc(x) %% 2) == 1) { + cat(&quot;numero_impar:&quot;, trunc(x)) + } + } + } ## numero_par:&lt;U+2423&gt; 2 A ideia no Código R 6.6 é escolher um numero inteiro o algoritmo verificar se este é par ou ímpar. O que pode ocorrer como supostos erros que foram protegidos pelo código, o primeiro é de se avaliar um valor que não seja número. Nesse caso, a primeira condição if(!is.numeric(x)) retornar uma mensagem que o valor não é um número. O segundo erro que poderia ocorrer é do valor inserido não ser um número inteiro. Nesse caso, truncamos o número apenas usando a sua parte inteira e desprezando a decimal, sem o arredondamento. Tentar evitar erros previsíveis, é o que chamamos de programação defensiva, uma forma do próprio usuário conseguir identificar o erro mais facilmente. Um próximo exemplo, apresentado no Código R 6.6, mostrará inicialmente por meio da condição if() e else pode se apresentar um código mais complexo, sendo simplificado na sequência com o uso da função switch(), Código R 6.8. O fluxograma da função switch() pode ser observado pela Figura 6.4. knitr::include_graphics(&quot;img/Fluxograma_Funcao_switch.png&quot;) FIGURA 6.4: Fluxograma da função switch(). &gt; # Objeto &gt; set.seed(15) # Fixando a semente &gt; x &lt;- rnorm(1000) # Gerando 1000 numeros aleatorios &gt; # medida descritiva &gt; opcao &lt;- &quot;media&quot; # opcoes: &quot;media&quot;, &quot;mediana&quot;, &quot;medapar&quot; (media aparada) &gt; if (opcao == &quot;media&quot;) { + cat(&quot;Amédiaaritméticaé:&quot;, round(mean(x), 4)) + } else { + if (opcao == &quot;mediana&quot;) { + cat(&quot;Amedianaé:&quot;, round(mean(x), 4)) + } else { + if (opcao == &quot;medapar&quot;) { + cat(&quot;Amédiaaparadaé:&quot;, round(mean(x, trim = 0.1), 4)) + } + } + } ## A&lt;U+2423&gt;média&lt;U+2423&gt;aritmética&lt;U+2423&gt;é: 0.037 &gt; # Objeto &gt; set.seed(15) # Fixando a semente &gt; x &lt;- rnorm(1000) # Gerando 1000 numeros aleatorios &gt; # medida descritiva &gt; opcao &lt;- &quot;media&quot; # opcoes: &quot;media&quot;, &quot;mediana&quot;, &quot;medapar&quot; (media aparada) &gt; switch(opcao, + media = cat(&quot;Amédiaaritméticaé:&quot;, round(mean(x), 4)), + mediana = cat(&quot;Amedianaé:&quot;, round(mean(x), 4)), + medapar = cat(&quot;Amédiaaparadaé:&quot;, round(mean(x, trim = 0.1), 4)) ) ## A&lt;U+2423&gt;média&lt;U+2423&gt;aritmética&lt;U+2423&gt;é: 0.037 As três estruturas básicas de loop no R são: repeat, while() e for(). Dizemos que um loop é um conjunto de instruções (expressões) em um algoritmo que se repete um número de vezes até que sejam alcançados os objetivos desejados. A repetição é controlada pelo contador, um objeto R . Cada repetição represeta um ciclo do loop. Enquanto a condição do loop for verdadeira, os ciclos se repetem atualizando o contador, Figura 6.5. Algumas funções não têm condição explícita (repeat e while), e precisam de funções adicionais em suas expressões. knitr::include_graphics(&quot;img/Fluxograma_loop.png&quot;) FIGURA 6.5: Fluxograma do loop A primeira função loop é repeat, apresentamos sua sintaxe: repeat { expressão ... } Juntamente com o repeat, usamos as funções break e next, pois a função repeat não tem uma condição explícita. Para o entendimento, criamos dois fluxogramas, sendo o primeiro entendendo a função repeat junto com a função break e o outro a função repeat juntamente com a função next, dos quais podem ser verificadas pelas Figuras 6.6 e 6.7, respectivamente. Vejamos, alguns exemplos para essas funções, iniciando pelo Código R 6.9. knitr::include_graphics(&quot;img/Fluxograma_Funcao_repeat_break.png&quot;) FIGURA 6.6: Fluxograma das funções repeat e break knitr::include_graphics(&quot;img/Fluxograma_Funcao_repeat_next.png&quot;) FIGURA 6.7: Fluxograma das funções repeat e next &gt; # Contador &gt; i &lt;- 1 &gt; # Loop repeat &gt; repeat { + if (i &gt; 5) { + break + } else { + print(i) + i &lt;- i + 1 + } + } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 Observamos que a condição em repeat se repete até i &gt; 5, ou seja, será impresso apenas os valores de 1 a 5. Para que isso ocorra, nós quebramos o ciclo de repetição com a função break, em que o objeto i &lt;- 1 [linha 1, Código R 6.9] é o contador do ciclo. Percebemos que cada ciclo apresenta no console como resultado a execução print(i) [linha 8, Código R 6.9], e que na sequência, o contador se atualiza, i &lt;- i + 1 [linha 9, Código R 6.9]. Essa situação se repete enquanto i &lt; 6, porque nessa situação a condição em else é sempre a executada. Assim, no momento em que o contador i é igual a 5, esse valor é impresso no console, e na sequência este é atualizado para i &lt;- 5 + 1, isto é, o contador assume valor igual a 6. Nesse momento, o ciclo recomeça e quando a linha 5 é avaliada, a condição i &gt; 5 passa a ser verdadeira, então a linha 6 é avaliado e função break entra em ação. Isso resulta na quebra do ciclo, e então a função repeat é encerrada. O próximo exemplo no Código 6.10, apresentamos a função next. &gt; # Contador &gt; i &lt;- 1 &gt; # Loop repeat &gt; repeat { + if (i &gt; 5) { + break + } + else { + if (i == 3) { + i &lt;- i + 1 + next + print(i + 1) + } + print(i) + i &lt;- i + 1 + } + } ## [1] 1 ## [1] 2 ## [1] 4 ## [1] 5 O que diferencia o Código R 6.9 para o Código R 6.10 é o acréscimo da função next ao código. Quando a condição if(i == 3) [linha 9, Código R 6.10] é verdadeira, as linhas 10 e 11 são executadas. Primeiro atualizamos o contador i &lt;- 3 + 1 [linha 10, Código R 6.10] e posteriormente, a função next [linha 10, Código R 6.10] é executada. Inserimos a linha 12 no Código R 6.10] para termos a ideia da função next, que é avançar o ciclo quando esta função é executada, ou seja, quando o contador quando assume valor 3, as linhas 10 e 11 são executadas, e após a função next ser chamada, as linhas 12, 14 e 15 não são executadas, porque se fossem, o valor 5 seria impresso duas vezes, e isso não ocorreu. O que aconteceu foi o avanço de ciclo. Devemos ter uma atenção a função repeat, porque como ela não tem um critério de parada explícito, podemos incorrer em um loop infinito. Similar a função repeat(), temos a função while(), que agora, temos uma condição de parada, cujo fluxograma é dado pela Figura 6.8, com sintaxe dada por: while (condição) { expressão ... } knitr::include_graphics(&quot;img/Fluxograma_Funcao_while.png&quot;) FIGURA 6.8: Fluxograma da função while Nessa função, também podemos usar as funções break e next, como usados na função repeat. Vejamos o exemplo no Código R 6.11. &gt; # Contador &gt; i &lt;- 1 &gt; # Loop while &gt; while (i &lt;= 5) { + print(i) + i &lt;- i + 1 + } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 Nesse caso, não foi necessário utilizar a função break, devido a condição que ela permite impor ao ciclo. Vejamos um outro exemplo, no Código R 6.12. &gt; # Contador &gt; i &lt;- 1 &gt; # Loop while &gt; while (i &lt;= 5) { + if (i == 3) { + i &lt;- i + 1 + next + } + print(i) + i &lt;- i + 1 + } ## [1] 1 ## [1] 2 ## [1] 4 ## [1] 5 Observamos a utilização da função next, similar ao que foi realizado com a função repeat. Por fim, a função for(), com cuja sintaxe é dada por: for (contador in lista) { expressão ... } Com essa função, também podemos utilizar break e next. Porém, o controle do ciclo nessa situação é maior, e menos necessário essas funções. Vejamos a Figura 6.9. knitr::include_graphics(&quot;img/Fluxograma_Funcao_for.png&quot;) FIGURA 6.9: Fluxograma da função for() &gt; # Loop for &gt; for (i in 1:5) { + print(i) + } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 Observamos que a implementação, dos algoritmos anteriores, é bem mais simples usando a função for(). Vejamos um próximo exemplo, no Código R 6.14. &gt; # Loop for &gt; for (i in 1:5) { + if (i == 3) { + next + } + print(i) + } ## [1] 1 ## [1] 2 ## [1] 4 ## [1] 5 Mais uma vez, foi utilizado a função next, sem necessidade agora, de atualizar o contador i, uma vez que já está definido na função for(). Veremos na próxima subseção, que temos funções de alto nível que podem substituir as funções loops. São as chamadas funções da família apply. 6.7 Criando funções Até esse momento, usamos funções já desenvolvidas no R, seja dos pacotes nativos, seja via instalação dos pacotes via CRAN. Agora, iremos desenvolver as nossas próprias funções. Como falado anteriormente, no início, a estrutura da função criada se mantém, argumento, corpo e ambiente. Para isso, usaremos a função function(). O modo desse objeto é closure5. Vejamos a sua sintaxe, &gt; # Forma usual &gt; nome_funcao &lt;- function(arg1, arg2, ...) { + corpo: comandos.. + } &gt; # Forma simplificada &gt; nome_funcao &lt;- function(arg1, arg2, ...) corpo Desse modo, apresentamos o primeiro exemplo no Código R 6.15, a seguir &gt; # Criando a funcao &#39;fun1&#39; &gt; fun1 &lt;- function(x) { + res &lt;- x + 1 + return(res) + } Nesse caso, temos uma função chamada fun1(), cujo argumento de entrada é x. Observemos que uma função é como um objeto do tipo vector, associamos um nome ao objeto da mesma forma. O corpo apresenta uma delimitação por chaves , em que apresenta um comando de atribuição, cujo nome res se associa ao resultado da soma x + 1. Por fim, o resultado dessa função, imprime res, por meio da função return(). Para executar fun1(), fazemos: &gt; fun1(x = 5) ## [1] 6 O que aconteceu foi que ao assumir x = 5 no argumento, essa informação foi repassada para o corpo da função fun1(), aonde existia o nome x, que se associou ao objeto 5, para esse caso. A função + é chamada, e a expressão x + 1 é avaliada, cujo nome res se associa ao resultado dessa expressão. Por fim, quando a função fun1() é chamada, o resultado de res é impressa no console, por meio de return(res). Vamos verificar os três componentes da função fun1() no console, isto é, &gt; # Argumentos &gt; formals(fun1) ## $x &gt; # Corpo &gt; body(fun1) ## { ## res &lt;- x + 1 ## return(res) ## } &gt; # Ambiente &gt; environment(fun1) ## &lt;environment: R_GlobalEnv&gt; O corpo da função é executado de forma sequencial, a partir da primeira linha de comando até a última. Apesar de recomendado, também não é obrigatório o uso da função return(), são as chamadas saídas explícitas6, sendo observado como segue, &gt; # Funcao &gt; fun2 &lt;- function(x) x + 1 &gt; # Executando 6.7.1 Função anônima Podemos também ter o que chamamos de função anônima, da qual não associamos nome as funções. Contudo, sendo criada esta não pode ser recuperada como qualquer outro objeto. Essa forma é interessante quando não precisamos dela após o seu uso. Por exemplo, queremos calcular a integral, \\[ \\int_{0}^{1} x^2 \\,dx=\\frac{1}{3} \\] e criamos uma função \\(x^2\\). Então, &gt; integrate(f = function(x) x^2, + lower = 0, + upper = 1) ## 0.3333333 with absolute error &lt; 3.7e-15 A função integrate() é utilizada para o cálculo de integral, do qual, passamos os argumentos, função (f), limite inferior (lower) e limite superior (upper) da integração, respectivamente. Observemos que não houve necessidade de nomear a função no argumento, pois não há objetivo de ser reutilizado. Isso também ocorre muito na área de ciência de dados, quando muitas vezes fazemos manipulações com os dados ao mesmo tempo, sem necessidade de associar nomes aos resultados intermediários. 6.7.2 Chamadas de função As chamadas de funções ocorrem de três formas: aninhado, intermediário e via pipe. Vejamos o cálculo do desvio padrão novamente, Código R 6.16. &gt; # Funcao auxiliar 1 &gt; aux1 &lt;- function(x) x - mean(x) &gt; # Funcao auxiliar 2 &gt; aux2 &lt;- function(x) x^2 &gt; # Funcao auxiliar 3 &gt; aux3 &lt;- function(x) { + sum(x) / (length(x) - 1) + } &gt; # Gerando 100 numeros aleatorios de uma distribuicao normal &gt; set.seed(10) &gt; x &lt;- rnorm(100) &gt; # Calculo do desvio padrao (aninhado) &gt; sqrt(aux3(aux2(aux1(x)))) ## [1] 0.9412359 &gt; # Calculo do desvio padrao (intemediario) &gt; dp &lt;- aux1(x) &gt; dp &lt;- aux2(dp) &gt; dp &lt;- aux3(dp) &gt; dp &lt;- sqrt(dp) &gt; dp ## [1] 0.9412359 &gt; # Calculo do desvio padrao (pipe) &gt; x |&gt; + aux1() |&gt; + aux2() |&gt; + aux3() |&gt; + sqrt() ## [1] 0.9412359 Mais detalhes sobre esses três aspectos serão abordados no Volume II. 6.7.3 Ordenação de argumentos Os argumentos nas funções podem ser nomeados ou não. Quando nomeados, a ordem como são inseridos na função não importa. Já os argumentos não nomeados, seus valores precisam estar na ordem como a função foi desenvolvida. Vejamos o Código R 6.17, para entender melhor. &gt; estdesc &lt;- function(x, opcao) { + res &lt;- switch(opcao, + media = round(mean(x), 4), + mediana = round(mean(x), 4), + medapar = round(mean(x, trim = 0.1), 4)) + return(res) + } &gt; # Objeto &gt; set.seed(15) &gt; x &lt;- rnorm(1000) &gt; # Argumentos nomeados na funcao &gt; estdesc(x = x, opcao = &quot;media&quot;) ## [1] 0.037 &gt; estdesc(opcao = &quot;media&quot;, x = x) ## [1] 0.037 &gt; # Argumentos não nomeados ordenados &gt; estdesc(x, &quot;media&quot;) ## [1] 0.037 &gt; # Argumentos não ordenados (Gera erro) &gt; estdesc(&quot;media&quot;, x) ## Error in switch(opcao, media = round(mean(x), 4), mediana = round(mean(x), : EXPR deve ser um vetor de comprimento 1 6.7.4 Objeto reticências () O objeto reticências é do tipo pairlist, um tipo de objeto usado bastante internamente no R , e dificilmente utilizado no código interpretado. Desse modo, não temos acesso direto a estrutura do objeto . Contudo, esse objeto tem um papel fundamental nas funções, quando damos a liberdade de inserir mais argumentos além dos definidos na criação da função. Esse argumento é usado na função plot(), por exemplo, do pacote nativo base. Vejamos como o argumento  pode ser usado em uma função, no Código R 6.18. &gt; # Funcao que plota um grafico &gt; grafico &lt;- function(x, y, ...) { + plot(x = x, y = y, ...) + } &gt; # Vetores &gt; x &lt;- 1:10; y &lt;- rnorm(10) &gt; # Chamada 1, com os argumentos definidos &gt; grafico(x = x, y = y) &gt; # Chamada 2, inserindo argumentos nao definidos &gt; grafico(x = x, y = y, main = &quot;Título&quot;) Isso ocorre, porque temos a função plot() no corpo da função grafico() que apresenta muitos argumentos. Dessa forma, criamos a função grafico(), com os argumentos que representam as coordenadas, mas a reticências () garantem que os demais argumentos da função plot, omitidos, possam ser utilizados. 6.8 Escopo léxico Vamos retornar aos componentes da função fun1(), desenvolvido no Código R 6.15, reapresentando novamente as três estruturas de uma função, &gt; # Argumentos &gt; formals(fun1) ## $x &gt; # Corpo &gt; body(fun1) ## { ## res &lt;- x + 1 ## return(res) ## } &gt; # Ambiente &gt; environment(fun1) ## &lt;environment: R_GlobalEnv&gt; Observemos que o último componente é o ambiente onde o nome fun1 foi associado a função. Este ambiente é chamado de ambiente envolvente. Nesse caso é o ambiente global. Contudo, quando a função é executada, momentaneamente é criado o ambiente de execução. É neste ambiente que os nomes que estão no corpo da função são associados aos objetos. Vejamos um primeiro exemplo, Código R 6.19. &gt; x &lt;- 10 &gt; fun &lt;- function() { + x &lt;- 2 + x + } &gt; # Chamando a funcao fun &gt; fun() ## [1] 2 Por causa do ambiente de execução que o objeto x dentro da função é retornado, ao invés do que foi definido fora da função. Isso porque o ambiente de execução mascara os nomes definidos dentro da função dos nomes definidos fora da função. Esse é uma primeira característica do escopo léxico nas funções em R . Anteriormente, falamos sobre a atribuição, que representa a forma como os nomes se associam aos objetos. Agora, o escopo vem a ser a forma como os nomes encontram seus valores associados. O termo léxico significa que as funções podem encontrar nomes e seus respectivos valores associados, definidos no ambiente onde a função foi definida, isto é, no ambiente de função. Claro que isso segue regras, e a primeira foi a máscara de nome falada anteriormente. Porém quando não existe um nome vinculado a um objeto, e este foi definido no ambiente de função, o valor é repassado para o corpo da função, como pode ser observado no Código R 6.20. &gt; x &lt;- 10 &gt; fun &lt;- function() { + x + } &gt; # Chamando a funcao fun &gt; fun() ## [1] 10 O resultado de fun() foi 10, porque como a função procurou no ambiente de execuções e não encontrou esse nome, a função foi até o ambiente superior, no caso, o ambiente de execuções. Como falado anteriormente, todo ambiente tem um pai (ou ambiente superior). Essa hierarquização é observada no caminho de busca, que pode ser acessado por search(), ou seja, &gt; search() ## [1] &quot;.GlobalEnv&quot; &quot;package:magrittr&quot; &quot;package:stats&quot; ## [4] &quot;package:graphics&quot; &quot;package:grDevices&quot; &quot;package:utils&quot; ## [7] &quot;package:datasets&quot; &quot;package:methods&quot; &quot;Autoloads&quot; ## [10] &quot;package:base&quot; O ambiente corrente do R sempre será o ambiente ambiente global (.GlobalEnv). O ambiente de execução não aparece, porque ele é momentâneo. Então, após buscar no ambiente de execução e não encontrar, é pelo caminho de busca que a função irá procurar pelos objetos inseridos no corpo da função. Ele só existe quando a função é chamada e não quando ela é definida, isto é, &gt; # Funcao &gt; fun &lt;- function() x + 10 &gt; # Objeto 1 &gt; x &lt;- 10 &gt; # Chamada1 &gt; fun() ## [1] 20 &gt; # Objeto 2 &gt; x &lt;- 20 &gt; # Chamada 2 &gt; fun() ## [1] 30 Observe que após ser criada a função fun(), o nome x se associou ao objeto 10. Posteriormente, fun() foi chamada e o resultado foi 20. Contudo, o nome x se associou a outro objeto 20, e após a segunda chamada da função fun(), o resultado foi 30, porque a função procura os valores quando ela é executada, e não quando é criada, é a característica de pesquisa dinâmica do escopo léxico. Uma outra situação pode ser observada no Código R 6.21. &gt; # Objeto &gt; n &lt;- 1 &gt; # Funcao &gt; fun &lt;- function() { + n &lt;- n + 1 + n + } &gt; # Chamada 1 &gt; fun() ## [1] 2 &gt; # Chamada 2 &gt; fun() ## [1] 2 Nessas linhas de comando, poderíamos pensar que após ter executado a primeira chamada, o valor retornado seria 2, e a segunda chamada retornaria o valor 3, como ocorre com as variáveis estáticas na linguagem C, por exemplo. Aqui nesse caso, o resultado independente do número de chamadas, será sempre o mesmo porque uma outra característica do escopo léxico no R é o novo começo, porque a cada vez que a função é executada um novo ambiente de execução é criado, e portanto, cada execução dos comandos de atribuição e expressão são executados de forma independentes nas chamadas de funções. Algo que não havíamos falado anteriormente, é que a função function() não necessariamente necessita de definição de argumentos, devido a flexibilidade do escopo léxico das funções em R. É essa característica que faz com que os comandos no corpo das funções encontrem os objetos que não estão definidos na própria função. Mais detalhes, serão encontrado no Volume II: Nível Intermediário da coleção Estudando o Ambiente R. "],["boas-práticas-de-como-escrever-um-código.html", "Capítulo 7 Boas práticas de como escrever um código", " Capítulo 7 Boas práticas de como escrever um código "],["pacotes.html", "Capítulo 8 Pacotes 8.1 Estrutura básica de um pacote 8.2 Instalação de um pacote 8.3 Objetivos de um pacote 8.4 Utilizando funções de um pacote 8.5 Carregando e anexando um pacote 8.6 NAMESPACE de um pacote 8.7 Usando os operadores :: e :::", " Capítulo 8 Pacotes 8.1 Estrutura básica de um pacote 8.2 Instalação de um pacote 8.3 Objetivos de um pacote 8.4 Utilizando funções de um pacote 8.5 Carregando e anexando um pacote 8.6 NAMESPACE de um pacote 8.7 Usando os operadores :: e ::: "],["boas-práticas-de-como-escrever-um-código-1.html", "Capítulo 9 Boas práticas de como escrever um código 9.1 Introdução", " Capítulo 9 Boas práticas de como escrever um código 9.1 Introdução Nesse momento, entendemos os principais objetos para escrevermos os nossos scripts. Quando escrevemos um código, duas consequências ocorrem: guardá-lo para futuras consultas, ou compartilhamento. Nesses dois casos, percebemos que alguém irá ler esse código, ou até mesmo o próprio usuário, irá retornar àquelas linhas de código e tentar raciocinar quais as ideias por trás disso tudo. Para um melhor entendimento de seu script, nada mais importante do que uma boa escrita, separação das estruturas por hierarquização, comentários, etc. Uma primeira ferramenta que pode ser configurada para quem usa o RStudio é acionar todas as opções de diagnóstico do seu código. Para isso no menu: Tools &gt; Global options &gt; Code &gt; Editing. Marque todas as opções em General; Tools &gt; Global options &gt; Code &gt; Display, Marque todas as opções; Tools &gt; Global options &gt; Code &gt; Diagnostics. Marque todas as opções em R Diagnostics. Com isso, colorações nas linhas de comando ocorrerão, distinguindo diversas estruturas, como linhas de comentário, funções, espaçamentos, dentre outras coisas. Uma vez feito isso, vamos para o passo seguinte que são as boas práticas de como se escrever um script. Temos algumas ferramentas prontas, como o pacote styler e como alternativa o pacote formatR, que automatiza todo o nosso código seja em script, contido em um pacote, ou diretório. Acesse https://yihui.org/formatr, para mais detalhes. Para instalar e anexar o pacote styler, use as linhas de comando: &gt; # Instalando pacote &gt; install.packages(styler) &gt; # Carregando e anexando &gt; library(styler) Vejamos a Figura 9.1, para entendermos a funcionabilidade desse pacote. knitr::include_graphics(&quot;img/Configuracao_Styler.png&quot;) FIGURA 9.1: Passos para configurar o pacote styler. "],["pacotes-1.html", "Capítulo 10 Pacotes 10.1 Introdução 10.2 Estrutura básica de um pacote 10.3 Instalação de um pacote 10.4 Objetivos de um pacote 10.5 Utilizar as funções de um pacote 10.6 Carregando e anexando um pacote 10.7 NAMESPACE de um pacote 10.8 Documentações de um pacote 10.9 Operadores :: e :::", " Capítulo 10 Pacotes 10.1 Introdução Um pacote em R é um diretório de arquivos necessários para carregar um código de funções, dados, documentações de ajuda, testes, etc. O próprio R em sua instalação, contém 30 pacotes nativos, que contém as funções mínimas para a utilização do ambiente. No pacote, não há apenas códigos em R , mas um pacote fonte (do inglês, source package), contendo os arquivos mencionados acima, ou um arquivo compactado, de extensão .tar.gz do pacote fonte, ou um pacote instalado, resultado do comando R CMD INSTALL, que será visto no Volume V: Desenvolvimento de Pacotes R, coleção Estudando o Ambiente R. Isso acontece no SO Linux. Para as plataformas Windows e Macintosh, existem também os pacotes binários ou compactados com a extensão .zip ou .tgz, respectivamente. Um pacote, portanto é a unidade básica para o compartilhamento de um código. Atualmente, até 01/12/2021, o número de pacotes disponíveis no CRAN é 18.524. Podemos encontrar a lista de pacotes por data de publicação ou por ordem alfabética. Qualquer usuário pode publicar um pacote e disponibilizá-lo sob o CRAN. Para isso, uma série de testes iniciais são realizados no próprio ambiente R , para verificar se o pacote em desenvolvimento não contém problemas previsíveis, e posteriormente, uma checagem mais aprofundada, após a submissão, é realizada por algum dos mantenedores do R (R Development Core Team). Isso significa dizer que se um pacote está disponível no CRAN, além de sua estabilidade, o pacote será executável nas três plataformas mais usadas em sistema operacional, SO Linux ou sitemas Unix, SO Windows e SO Macintosh. Isso é um padrão hoje no R. Há outros repositórios que podem ser disponibilizados os pacotes, como por exemplo, Biocondutor, R-forge, GitHub. Este último está sendo muito utilizado, nesses últimos anos. Porém, quando os pacotes estão em repositórios diferentes do CRAN, não haverá garantias dos padrões mencionados anteriormente. Além do mais, devemos entender que a principal preocupação dos mantenedores do R, é que os pacotes funcionem corretamente, naquilo em que os mesmos objetivam, mas em nada é discutido sobre a metodologia científica, ou de análises, a que o pacote se destina. Isso é verificado, quando o pacote após disponível no CRAN, também é submetido para o journal do R, o The R Journal ou ao Journal of Statistical Software, por exemplo. Aí sim, o pacote é esmiuçado tanto no aspecto computacional, quanto no metodológico. Portanto, entenda que nem todo pacote sob o CRAN é confiável naquilo que se propõe, o que não significa dizer, que um pacote é confiável se apenas tiver sido publicado nas revistas anteriores ou em qualquer outra específica para a área de interesse, mas a cautela é sempre necessária, tentando entender quem são os desenvolvedores, ou fazendo uma pesquisa mais ampla sobre o referido pacote, para que assim, a decisão da escolha seja confiável. Fazemos esse adendo, porque quando se vai pesquisar sobre um determinado assunto poderá existir diversos pacotes para o mesmo, e a pergunta será, qual pacote devemos escolher? Aquele que é mais fácil utilizar? E daí, uma boa pesquisa para a escolha não deve ser levado apenas em consideração a facilidade de utilização do pacote, mas saber se as funções do pacote realmente retornam os resultados confiáveis para aquilo que se destina. Fica a nossa dica. Para uma instalação mais rápida dos pacotes, optem pelos espelhos disponíveis nos países em que vivem, uma vez que a transferência de dados ocorrem mais rapidamente. Aqui no Brasil, por exemplo, o primeiro espelho desenvolvido e ativo até hoje é o da UFPR. Mas, temos mais quatro espelhos: dois na USP, uma na Fiocruz/RJ, e outra na UESC. Um termo que deve ficar claro, que erroneamente, alguns usuários chamam o termo biblioteca como um sinônimo de pacote. Nas documentações do R , biblioteca é o diretório onde os pacotes são instalados, também chamados de diretório de biblioteca ou diretório de árvores. O outro sentido de biblioteca é o de biblioteca compartilhada (dinâmica ou estática), que armazenam código compilado que se vinculam aos pacotes, por exemplo, no Windows são as DLLs. 10.2 Estrutura básica de um pacote A estrutura básica de um pacote é apresentada na Figura 10.1 FIGURA 10.1: Esqueleto básico de um pacote Vejamos as ideias básicas desses subdiretórios e arquivos: DESCRIPTION: Esse é um arquivo de texto, contendo informações básicas como o título do pacote, versão, licença, descrição, nome dos autores, e o mantenedor do pacote, isto é, para quando um pacote estiver com problema ou o CRAN entre em contato, será para este último. Esses as informações obrigatórias que devem ter nesse arquivo; NAMESPACE: Esse arquivo embora tenha tenha muita semelhança com a linguagem R , o seu conteúdo, se destina a importação e exportação de funções no pacote. Será nesse arquivo, que diremos quais os pacotes que ele depende, isto é, as funções, e quais as funções exportadas, visíveis, que devem ser apresentadas aos usuários; R/: Esse subdiretório apresenta os scripts com as funções em R . é o cérebro do pacote; man/: Esse subdiretório apresenta os arquivos de ajuda, com extensão .Rd. Isso significa, que uma vez instalado o pacote no R , o acesso aos manuais de ajuda do referido pacote, estarão disponíveis, graças a esses arquivos. Claro, que quando os pacotes se tornam mais complexos, outros subdiretórios e arquivos são necessário. Mas isso é assunto para o Volume V: Desenvolvimento de Pacotes R, coleção Estudando o Ambiente R. 10.3 Instalação de um pacote A instalação de um pacote via R pode ser feito pela função install.packages(pkgs = nome_pacote). Por exemplo, vamos tentar instalar o pacote midrangeMCP, da seguinte forma: &gt; install.packages(&quot;midrangeMCP&quot;) Pode ser que nesse processo, dependendo de onde o usuário esteja executando essa linha de comando, interface do R ou RStudio, que seja solicitado o espelho por onde deseja fazer a instalação. Isso é apenas um atalho para ter um acesso mais rápido na instalação do pacote. A sugestão é escolher um espelho de seu país de origem. Uma forma simples de se ter detalhes do pacote na internet, tais como, baixar o pacote fonte ou o pacote binário do midrangeMCP, por exemplo, é sempre usar essa url: &lt;http://cran.r-project. org/package=midrangeMCP&gt;. Para qualquer outro pacote, basta mudar o nome do pacote na url, e assim, estaremos na página do repositório do pacote. O pacote fonte, como falado anteriormente, é compactado com extensão .tar.gz, no caso, midrangeMCP_3.1.1.tar.gz. O pacote binário tem a compactação zipada, midrangeMCP_3.1.1.tar.zip para o Windows e midrangeMCP_3.1.1.tgz para o Macintosh. O acesso aos arquivos do pacote mencionados no esqueleto são disponíveis no pacote fonte. Uma outra forma possível de instalação é baixar o arquivo do pacote fonte para o seu computador e instalá-lo, via comando: &gt; install.packages(pkgs = &quot;./midrangeMCP.tar.gz&quot;, repos = NULL, type = &quot;source&quot;) ## Installing package into &#39;C:/Users/MABENLA/Documents/R/win-library/4.1&#39; ## (as &#39;lib&#39; is unspecified) ## Warning in install.packages(pkgs = &quot;./midrangeMCP.tar.gz&quot;, repos = NULL, : ## installation of package &#39;./midrangeMCP.tar.gz&#39; had non-zero exit status Consideramos que o arquivo do pacote esteja no diretório de trabalho do usuário. Caso contrário, deve ser informado o local onde pacote se encontra no computador. Para o Window ou Macintosh, é possível instalar também, a partir dos pacotes binários. Muitos dos desenvolvedores, estão disponibilizando seus projetos de pacotes, principalmente no GitHub, inclusive com manuals de ajuda com maiores detalhes. Pode ser possível instalar esses pacotes por esse repositório. Precisamos inicialmente do pacote devtools, e posteriormente a instalação do pacote. Segue as linhas de comando: &gt; install.packages(&quot;devtools&quot;) &gt; install_github(&quot;bendeivide/midrangeMCP&quot;) Contudo, devemos dar a preferência pela instalação via CRAN. Por lá, teremos a garantia que os pacotes estão estáveis para a utilização nas referidas plataformas mencionadas acima. Alguns pacotes, por falta de manutenção, seja por atualizações do R ou por qualquer outro motivo, podem se tornar incompatíveis para utilização sobre alguns dos três sistemas operacionais básicos (SO Windows, Unix e SO Mac) exigidos pelo R. Dessa forma, se as correções não forem feitas, estes pacotes e tornam órfãos, ou seja, desativados sob o CRAN. O primeiros pacotes sob o CRAN, por exemplo, não tinham o arquivo NAMESPACE, que hoje é exigido. Qualquer tentativa de instalação desses pacotes nessas situações, não serão bem sucedidas. Dessa forma, fizemos uma vídeo-aula, como tentativa de recuperar os pacotes desativados. Porém, deixemos claro que nem sempre é possível a instalação de pacotes desativados. 10.4 Objetivos de um pacote A ideia de um pacote para um usuário R deve representar como uma ferramenta para otimizar suas atividades do dia-a-dia na utilização da linguagem. Suponha que o usuário seja um cientista de dados, e todos os dias ele carrega uma sequência de scripts, via source, para disponibilizar suas funções no ambiente global. Isso acaba gerando processos repetitivos de trabalho desnecessários. Ao invés, o cientista de dados pode desenvolver um pacote, e esse pacote conter todas as funções necessárias para as suas análises. De uma vez, o pacote instalado e anexado no caminho de busca, todas as suas funções estarão disponíveis para utilização. Portanto, o entendimento disso, permite uma maior eficiência de trabalho. Outro ponto é que a experiência contida em um pacote pode ser propagada mais facilmente para outros usuários, mostrando que o conhecimento é uma liberdade necessária. Tanto pelo CRAN, quanto por outras plataformas, o pacote pode ser disponibilizado. 10.5 Utilizar as funções de um pacote Uma vez instalado o pacote, precisamos carregar e anexá-lo, para que possamos utilizar os recursos disponíveis no pacote, como funções, dados, etc. Isso significa, disponibilizar na memória e inseri-lo no caminho de busca, respectivamente. Para fazer essas duas ações ao mesmo tempo, use a função library() ou require(). A primeira função se for utilizada sem argumento algum, retorna todos os pacotes instalados na biblioteca de pacotes do R . Vejamos o exemplo do pacote midrangeMCP, no Código R 9.1. &gt; # Carregando e anexando o pacote midrangeMCP &gt; library(midrangeMCP) &gt; # Usando a função MRtest() desse pacote &gt; #----- &gt; # Dados simulados de um experimento em DIC (Delineamento Inteiramente Casualizado) &gt; # Variavel resposta &gt; rv &lt;- c(100.08, 105.66, 97.64, 100.11, 102.60, 121.29, 100.80, + 8 + 99.11, 104.43, 122.18, 119.49, 124.37, 123.19, 134.16, + 9 + 125.67, 128.88, 148.07, 134.27, 151.53, 127.31) &gt; # Tratamento &gt; treat &lt;- factor(rep(LETTERS[1:5], each = 4)) &gt; # Anava &gt; res &lt;- anova(aov(rv~treat)) &gt; DFerror &lt;- res$Df[2] &gt; MSerror &lt;- res$`Mean Sq`[2] &gt; # Aplicando testes &gt; results &lt;- midrangeMCP::MRtest(y = rv, + trt = treat, + dferror = DFerror, + mserror = MSerror, + alpha = 0.05, + main = &quot;PCMs&quot;, + MCP = c(&quot;all&quot;)) ## MCP&#39;s based on distributions of the studentized midrange and range ## ## Study: PCMs ## ## Summary: ## Means std r Min Max ## A 100.87 3.40 4 97.64 105.66 ## B 107.95 9.28 4 100.80 121.29 ## C 117.62 9.02 4 104.43 124.37 ## D 130.22 5.37 4 123.19 134.67 ## E 140.30 11.42 4 127.31 151.53 ## ## Mean Grouping Midrange Test ## ## Statistics: ## Exp.Mean CV MSerror Df n Stud.Midrange Ext.DMS Int.DMS ## 119.392 6.889695 67.66288 15 5 1.089969 5.783507 4.482902 ## ## Groups: ## Means Groups ## E 140.30 g1 ## D 130.22 g2 ## C 117.62 g3 ## B 107.95 g4 ## A 100.87 g4 ## ## Mean Grouping Range Test ## ## Statistics: ## Exp.Mean CV MSerror Df n Stud.Range DMS ## 119.392 6.889695 67.66288 15 5 4.366985 17.96085 ## ## Groups: ## Means Groups ## E 140.30 g1 ## D 130.22 g1 ## C 117.62 g2 ## B 107.95 g2 ## A 100.87 g2 ## ## SNK Midrange Test ## ## Statistics: ## Exp.Mean CV MSerror Df n Stud.Midrange DMS ## comp1 119.392 6.8897 67.6629 15 5 1.0900 5.7835 ## comp2 119.392 6.8897 67.6629 15 4 1.1646 6.0906 ## comp3 119.392 6.8897 67.6629 15 3 1.2828 6.5768 ## comp4 119.392 6.8897 67.6629 15 2 1.5072 7.4994 ## ## Groups: ## Means Groups ## E 140.30 g1 ## D 130.22 g1g2 ## C 117.62 g1g2g3 ## B 107.95 g2g3 ## A 100.87 g3 ## ## Tukey Midrange Test ## ## Statistics: ## Exp.Mean CV MSerror Df n Stud.Midrange Ext.DMS Int.DMS ## 119.392 6.889695 67.66288 15 5 1.089969 5.783507 4.482902 ## ## Groups: ## Means Groups ## E 140.30 g1 ## D 130.22 g2 ## C 117.62 g3 ## B 107.95 g4 ## A 100.87 g4 &gt; midrangeMCP::MRbarplot(results) 10.6 Carregando e anexando um pacote Anteriormente, falamos que usamos a função library() ou require() para carregar e anexar um pacote para utilizar suas funções, após a instalação. Carregar um pacote significa disponibilizar na memória ativa. Para acessar uma função de um pacote após ter sido carregado, usamos o operador ::, isto é, nome_pacote::nome_função. Isto significa, que será chamado a função necessária sem anexar o pacote no caminho de busca. Estudaremos no Capítulo 10, um pouco mais sobre caminho de busca. Para esse momento, entendamos que é um caminho hierarquizado de ambientes, isto é, objetos que armazenam, em forma de lista, nomes associados a objetos. A função para ver o caminho de busca é search(), como pode ser observado no Código R 9.2. &gt; # Caminho de busca &gt; search() ## [1] &quot;.GlobalEnv&quot; &quot;package:midrangeMCP&quot; &quot;package:stats&quot; ## [4] &quot;package:graphics&quot; &quot;package:grDevices&quot; &quot;package:utils&quot; ## [7] &quot;package:datasets&quot; &quot;package:methods&quot; &quot;Autoloads&quot; ## [10] &quot;package:base&quot; &gt; # Carregando e chamando uma função de um pacote &gt; midrangeMCP::MRwrite(results, extension = &quot;latex&quot;) ## Table in latex of results of the MGM test ## ## % latex table generated in R 4.1.3 by xtable 1.8-4 package ## % Wed Sep 28 06:34:16 2022 ## \\begin{table}[ht] ## \\centering ## \\begin{tabular}{lrl} ## \\hline ## trt &amp; Means &amp; Groups \\\\ ## \\hline ## E &amp; 140.30 &amp; g1 \\\\ ## D &amp; 130.22 &amp; g2 \\\\ ## C &amp; 117.62 &amp; g3 \\\\ ## B &amp; 107.95 &amp; g4 \\\\ ## A &amp; 100.87 &amp; g4 \\\\ ## \\hline ## \\end{tabular} ## \\end{table} ## ## ## Table in latex of results of the MGR test ## ## % latex table generated in R 4.1.3 by xtable 1.8-4 package ## % Wed Sep 28 06:34:16 2022 ## \\begin{table}[ht] ## \\centering ## \\begin{tabular}{lrl} ## \\hline ## trt &amp; Means &amp; Groups \\\\ ## \\hline ## E &amp; 140.30 &amp; g1 \\\\ ## D &amp; 130.22 &amp; g1 \\\\ ## C &amp; 117.62 &amp; g2 \\\\ ## B &amp; 107.95 &amp; g2 \\\\ ## A &amp; 100.87 &amp; g2 \\\\ ## \\hline ## \\end{tabular} ## \\end{table} ## ## ## Table in latex of results of the SNKM test ## ## % latex table generated in R 4.1.3 by xtable 1.8-4 package ## % Wed Sep 28 06:34:16 2022 ## \\begin{table}[ht] ## \\centering ## \\begin{tabular}{lrl} ## \\hline ## trt &amp; Means &amp; Groups \\\\ ## \\hline ## E &amp; 140.30 &amp; g1 \\\\ ## D &amp; 130.22 &amp; g1g2 \\\\ ## C &amp; 117.62 &amp; g1g2g3 \\\\ ## B &amp; 107.95 &amp; g2g3 \\\\ ## A &amp; 100.87 &amp; g3 \\\\ ## \\hline ## \\end{tabular} ## \\end{table} ## ## ## Table in latex of results of the TM test ## ## % latex table generated in R 4.1.3 by xtable 1.8-4 package ## % Wed Sep 28 06:34:16 2022 ## \\begin{table}[ht] ## \\centering ## \\begin{tabular}{lrl} ## \\hline ## trt &amp; Means &amp; Groups \\\\ ## \\hline ## E &amp; 140.30 &amp; g1 \\\\ ## D &amp; 130.22 &amp; g2 \\\\ ## C &amp; 117.62 &amp; g3 \\\\ ## B &amp; 107.95 &amp; g4 \\\\ ## A &amp; 100.87 &amp; g4 \\\\ ## \\hline ## \\end{tabular} ## \\end{table} ## ## ## Table in latex of results of descriptive statistics ## ## % latex table generated in R 4.1.3 by xtable 1.8-4 package ## % Wed Sep 28 06:34:16 2022 ## \\begin{table}[ht] ## \\centering ## \\begin{tabular}{lrrrrr} ## \\hline ## trt &amp; Means &amp; std &amp; r &amp; Min &amp; Max \\\\ ## \\hline ## A &amp; 100.87 &amp; 3.40 &amp; 4.00 &amp; 97.64 &amp; 105.66 \\\\ ## B &amp; 107.95 &amp; 9.28 &amp; 4.00 &amp; 100.80 &amp; 121.29 \\\\ ## C &amp; 117.62 &amp; 9.02 &amp; 4.00 &amp; 104.43 &amp; 124.37 \\\\ ## D &amp; 130.22 &amp; 5.37 &amp; 4.00 &amp; 123.19 &amp; 134.67 \\\\ ## E &amp; 140.30 &amp; 11.42 &amp; 4.00 &amp; 127.31 &amp; 151.53 \\\\ ## \\hline ## \\end{tabular} ## \\end{table} ## ## See yours tables in Console ## Format: latex Com as linhas de comando apresentadas anteriormente, percebemos ao executar a função MRwrite() do pacote midrangeMCP, usando :: que o caminho de busca não foi alterado. Isso significa que o pacote não foi anexado, apenas carregado, ou seja, se o usuário desejar usar alguma função do pacote digitando apenas o nome no console, não será possível, porque o pacote não está anexado ao caminho de busca. Vejamos outra situação pelo Código R 9.3. &gt; # Caso o pacote midrangeMCP esteja anexado, use: &gt; # detach(&quot;package:midrangeMCP&quot;, unload = TRUE) &gt; # Caminho de busca &gt; search() ## [1] &quot;.GlobalEnv&quot; &quot;package:midrangeMCP&quot; &quot;package:stats&quot; ## [4] &quot;package:graphics&quot; &quot;package:grDevices&quot; &quot;package:utils&quot; ## [7] &quot;package:datasets&quot; &quot;package:methods&quot; &quot;Autoloads&quot; ## [10] &quot;package:base&quot; &gt; # Carregando e anexando um pacote &gt; library(midrangeMCP) &gt; # Verificando novamente o caminho de busca &gt; search() ## [1] &quot;.GlobalEnv&quot; &quot;package:midrangeMCP&quot; &quot;package:stats&quot; ## [4] &quot;package:graphics&quot; &quot;package:grDevices&quot; &quot;package:utils&quot; ## [7] &quot;package:datasets&quot; &quot;package:methods&quot; &quot;Autoloads&quot; ## [10] &quot;package:base&quot; &gt; # Chamando uma funcao do pacote &gt; guimidrangeMCP() Com o uso da função library(), percebemos que o caminho de busca foi alterado, porque agora temos o ambiente de pacote package:midrangeMCP. Isso significa que agora poderemos acessar os objetos desse pacote apenas digitando o nome associado a eles. Por fim, a última linha de comando, representa a interface gráfica ao usuário para o pacote, o que chamamos de GUI (do inglês, Graphical User Interface). 10.7 NAMESPACE de um pacote No início da seção sobre pacotes, falamos sobre o esqueleto de um pacote, isto é, os componentes básicos de um pacote. Um dos arquivos foi o NAMESPACE. Esse arquivo é responsável pela exportação e importação de funções. As funções exportadas de um pacote, por meio desse arquivo, são aquelas visíveis após a anexação do pacote ao caminho de busca, ou por meio do operador ::. As funções importadas são aquelas utilizadas de outros pacotes, utilizadas internamente ao referido pacote. As funções ditas internas são aquelas não mencionadas no NAMESPACE. Em muitas situações, precisamos de funções internas necessárias para a finalidade do pacote, que muitas vezes não é objetivo final para disponibilidade dos usuários, mas códigos intermediários para a boa funcionabilidade do pacote. Dessa forma, uma boa escolha para que não haja conflitos em nomes associados a objetos no ambiente de trabalho, é a decisão de não exportá-los. Porém, quando se cria um pacote, por exemplo, pelo RStudio , o padrão no NAMESPACE é o comando: exportPattern(3), que significa que todas as funções no pacote serão exportadas que não iniciam por um ponto (.). 10.8 Documentações de um pacote Toda função exportada de um pacote precisa de um arquivo de ajuda (.Rd). Rodas as funções deverão ter esses tipos arquivos inseridos no subdiretório man/. Mais detalhes sobre o desenvolvimento de pacotes será abordado no Volume V: Desenvolvimento de Pacotes R, coleção Estudando o Ambiente R. 10.9 Operadores :: e ::: Como falamos anteriormente, para chamarmos uma função sem a necessidade de anexar o pacote, usamos o operador ::. Comentamos também, que algumas funções não eram exportadas pelo NAMESPACE de um pacote. Contudo, se desejarmos visualizar ou executá-las, poderemos utilizar o operador :::. Vejamos um exemplo, nas linhas de comando a seguir. &gt; # Instale o pacote SMR &gt; # install.packages(SMR) # Descomente a linha de comando para instalar &gt; # Carregando e chamando funcoes exportadas do pacote SMR &gt; SMR::pSMR(q = 2, size = 10, df = 3) ## [1] 0.9905216 &gt; # Carregando e chamando funcoes nao exportadas ao pacote &gt; SMR:::GaussLegendre(size = 4) ## $nodes ## [1] -0.8611363 -0.3399810 0.3399810 0.8611363 ## ## $weights ## [1] 0.3478548 0.6521452 0.6521452 0.3478548 As funções internas dos pacotes devem ser utilizadas com muita cautela, uma vez que são funções que podem passar por atualizações, mudanças. Isso porque, como não são funções exportadas, alguns pacotes podem passar por atualizações, e desse modo, estas funções também podem ser atualizadas ou até mesmo alteradas. Outro ponto interessante é que não se recomenda a utilização de importação de funções internas de outros pacotes no desenvolvimento de pacotes, uma vez que são funções que podem passar por mudanças drásticas, e portanto, gerar problemas nas rotinas. Se uma função em um pacote não foi exportada, é porque o desenvolvedor tem um bom motivo para tal situação. As funções exportadas são de fato a essência do objetivo de um pacote, e por isso que elas são exportadas. ^\\. "],["considerações-e-preparação-para-programação-em-r-nível-intermediário.html", "Capítulo 11 Considerações e preparação para Programação em R (Nível Intermediário)", " Capítulo 11 Considerações e preparação para Programação em R (Nível Intermediário) "],["referências.html", "Referências", " Referências ADLER, J. R in a Nutshell. Sebastopol: OReilly Media, 2012. BECKER, R. A.; CHAMBERS, J. M.; WILKS, A. R. The New S Language: A Programming Environment for Data Analysis and Graphics. Boca Raton, Flórida: CRC Press, 1988. CHAMBERS, J. M. Software for Data Analysis: Programming with R. New York: Springer, 2008. CHAMBERS, J. M. Extending R. Boca Raton, Florida: Chapman; Hall/CRC, 2016. CHAMBERS, J. M.; HASTIE, T. J. Statistical Methods in S. London: Chapman &amp; Hall, 1991. CHAMBERS, J. M.; HASTIE, T. J. Programming with Data: A Guide to the S Language. Ney York: Springer, 1998. GROSSER, M.; BUMAN, H.; WICKHAM, H. Advanced R Solutions. 2nd. ed. Boca Raton, Florida: Chapman; Hall/CRC, 2021. WICKHAM, H. R Packages. 2nd. ed. [s.l.] OReilly Media, 2015. WICKHAM, H. Advanced R. 2nd. ed. Boca Raton, Florida: Chapman; Hall/CRC, 2019. WICKHAM, H.; GROLEMUND, G. R for Data Science. Sebastopol: OReilly Media, 2017. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
