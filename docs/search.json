[{"path":"index.html","id":"bem-vindo","chapter":"Bem-vindo","heading":"Bem-vindo","text":" Esse é um livro digital da coleção “Estudando o ambiente R”, Volume 1: Nível Básico, com o selo Democratizando Conhecimento (DC). O Livro é destinado aos usuários R que objetivam aprofundar o entendimento ambiente R para seus projetos pessoais e profissionais.","code":""},{"path":"index.html","id":"licença","chapter":"Bem-vindo","heading":"Licença","text":"Este trabalho está licenciado com uma Licença Creative Commons - Atribuição-NãoComercial 4.0 Internacional.","code":""},{"path":"epígrafe.html","id":"epígrafe","chapter":"Epígrafe","heading":"Epígrafe","text":"melhor linguagem é que você domina! (Ben Dêivide)","code":""},{"path":"prefácio.html","id":"prefácio","chapter":"Prefácio","heading":"Prefácio","text":"coleção Estudando o ambiente R é fruto de cursos ministrados sobre essa linguagem, bem como consultorias e estudos ao longo dos anos. Em 2005, quando ingressei na academia curso de Engenharia Agronômica fiquei fascinado com disciplina de Estatística segundo semestre ano corrente. Na sequência, acabo tendo o primeiro contato com o ambiente R, com pouco mais de 9 anos de seu lançamento e redistribuição. Poucos materiais naquela época haviam disponíveis em língua portuguesa. Porém, foi o suficiente para eu entender que estava diante de uma grande ferramenta computacional e estatística, necessária para o entendimento, pois sabia que poderia gerar além de conhecimento, bons frutos acadêmicos.Hoje, ano de 2021, usuário há mais de 15 anos dessa linguagem, percebi que sentia desconfortável, como apenas usário dessa ferramenta de trabalho. E assim, quando queremos aprender algo não há ferramenta melhor que aprender por ensinar. E assim, lotado Departamento de Estatística, Física e Matemática (DEFIM), campus Alto Paraopeba, pela Universidade Federal de São João del-Rei (UFSJ), juntamente com o Centro Acadêmico de Engenharia de Telecomunicações (UFSJ), resolvemos em parceria, ministrar nesse momento de pandemia uma sequência de módulos para o curso R, desde o nível Básico até ao módulo Avançado.ideia desse curso foi apresentar algo diferente relacionado maioria dos cursos em R, que foi sempre apresentar essa ferramenta dentro dos conceitos da área da Estatística. Apesar de uma coisa ser intrínseca outra, há muitas particularidades ambiente R que são complexos, e muitas vezes julgados erroneamente. Um dos exemplos clássicos é que loops em R são lentos e com alto gasto de memória, quando na realiadade, isso ocorre muitas vezes pelo não entendimento sistema de cópia de objetos nesse ambiente. Ainda mais, o entendimento desses cursos é agravado porque o entendimento sobre estatística além de um cunho matemático, tem o seu cunho filosófico de como metodologias foram desenvolvidas, e o entendimento mútuo da Estatística e o ambiente R, podem não ter o conhecimento real que essa potencial ferramenta pode proporcionar, uma vez que muitos assuntos complexos podem estar envolvidos em uma única aula.Assim, desenvolvemos na coleção Estudando o ambiente R os três volumes iniciais, referentes apenas linguagem R, sendo Volume : Nível Básico, Volume II: Nível Intermediário e Volume III: Nível Avançado. Fazendo alusão dos três livros iniciais sobre linguagem S de John Chambers, faremos uma explanação sobre assuntos de menor complexidade até noções mais complexas sobre o ambiente R, restringindo apenas sintaxe e semântica da linguagem. Os volumes subsequentes serão destinados Documentações R, Desenvolvimento de pacote R, Gráficos, Banco de dados, Interface Gráfica ao Usuário, Interface R com outras linguagens, dentre outros.Tentando engajar nossos alunos, e agora colegas de trabalho, tenho parceria Volume , de Diego Arthur, uma pessoa que tenta se superar cada desafio e assunto estudado.Por fim, espero que esse primeiro volume possa servir de referência para os passos iniciais nessa ferramenta tão importante para área de análise de dados.Ben Dêivide de Oliveira Batista","code":""},{"path":"entendendo-a-coleção-estudando-o-ambiente-r.html","id":"entendendo-a-coleção-estudando-o-ambiente-r","chapter":"Capítulo 1 Entendendo a coleção Estudando o ambiente R ","heading":"Capítulo 1 Entendendo a coleção Estudando o ambiente R ","text":"Coleção Estudando o ambiente R não tem como objetivo principal de ensinar análise de dados. Mas sim, proporcionar ao leitor um conhecimento sobre linguagem R, de modo que se possa usufruir todos os recursos que esse ambiente possa proporcionar.Ainda como complemento, não queremos nesse material, convencê-lo utilizar linguagem R, pois melhor linguagem é aquela que você domina. Contudo, pretendemos mostrar que os recursos utilizados pelo R não estão mais limitados própria análise de dados. Um exemplo é esse material, que nesse momento usufruímos da própria linguagem para repassar nossas experiências sem ao menos ter o domínio sobre linguagens tipo HTML, CSS, JavaScript, dentre outras, necessárias para uma boa renderização de página web. Isso mostra potencial ferramenta de trabalho que o ambiente R pode ser para vida profissional.Dessa forma, propormos um entendimento sobre sintaxe e semântica de como linguagem R é desenvolvida. Com isso, o leitor será capaz após leitura dos dois primeiros volumes, de estudar um pouco mais sobre essa ciência que nos últimos anos vem ganhando mais evidência, que é Estatística. Tudo isso devido ao grande volume de informações obtidos nessa era tecnológica. Juntamente com ela, o R se tornará uma poderosa ferramenta para entender os padrões que estão por trás dos dados, que por sinal, é moeda valiosa momento, ou melhor, sempre foi!Aprenderemos também recursos diversos na área da computação, como programação defensiva, desenvolvimento de interfaces gráficas, paralelização, como também recursos na área da estatística sem complexidades teóricas, como o desenvolvimento de gráficos e o uso de banco de dados. Ensinaremos também o desenvolvimento de materiais como artigos, livros, websites, blogs, dashboards. Por fim, chegaremos maior cobiça de um programador R, desenvolver um pacote.\n Observem que em muitos momentos utilizamos o artigo “o” para linguagem R. Pois é, isso ocorre porque ela também é considerada um software ou ambiente. Daí, também podemos chamá-la de software R, ou preferivelmente, ambiente R. \nOs módulos dessa coleção terão os três volumes base para o entendimento ambiente R:Volume : Nível Básico;Volume II: Nível Intermediário; eVolume III: Nìvel Avançado.seguir, explanaremos sobre cada um dos módulos.","code":""},{"path":"entendendo-a-coleção-estudando-o-ambiente-r.html","id":"volume-i-nível-básico","chapter":"Capítulo 1 Entendendo a coleção Estudando o ambiente R ","heading":"1.1 Volume I: Nível Básico","text":"Esse primeiro volume, que representa o livro corrente, apresenta um breve histórico sobre linguagem, sua instalação, bem como os recursos que IDE1 RStudio, o conhecimento da sintaxe e semântica da linguagem R, compreendendo estruturas bases da linguagem, sobre o que é um objeto e como construir uma função, o entendimento sobre fluxos de controle. O que é um pacote, carregar e anexar um pacote, e quem são pessoas que fazem parte da manutenção dessa linguagem, também serão assuntos desse primeiro módulo. Caminhos de busca, ambientes e namespaces, teremos noções básicas. Algo muito interessante, que pode mudar vida de um programador em R são boas práticas para escrita de um código, tema também abordado nesse módulo.ideia desse volume é proporcionar um entendimento básico, um primeiro contato com linguagem, fazendo com que o leitor possa dar os primeiros passos, executando primeiras linhas de comando. Mas também, dando o enfoque com erros tão recorrentes, como o entendimento sobre um objeto, ou o anexo de um pacote caminho de busca. Temas como esses, dentre outros, serão forma inicial que encontramos, para que posteriormente, seja dado um aprofundamento sobre estrutura de um objeto R bem como sua manipulação, e adicionado isso, inserção de como são os paradigmas da programação nesse ambiente. Essa última parte será estudada, Volume II, apresentado seguir.","code":""},{"path":"entendendo-a-coleção-estudando-o-ambiente-r.html","id":"volume-ii-nível-intermediário","chapter":"Capítulo 1 Entendendo a coleção Estudando o ambiente R ","heading":"1.2 Volume II: Nível Intermediário","text":"O volume II é introduzido com uma melhor caracterização ambiente R quanto ao seu escopo léxico, como linguagem interpretada, como programação funcional, como programação meta-paradigma, como programação dinâmica; apresentaremos manipulações de objetos em mais detalhe, bem como o surgimento de alguns outros objetos como tibble, cópias de objetos. Uma característica ambiente R é que linguagem pode ser orientada objetos e isso será estudado nesse módulo. Introduziremos ao desenvolvimento de pacotes R, e aprofundaremos sobre os ambientes. Por fim, mostraremos como desenvolver Projeto RStudio e integrá-los ao GitHub, e dessa forma, introduziremos sobre o sistema Git.Esse talvez seja o maior volume, dentre os três iniciais, porque apenar de não precisarmos entender mais ideia dos objetos, que foram retratadas Volume , inserção dos paradigmas da programação para este volume, trará uma maior riqueza de características para o R, mostrando sua versatilidade. Também, daremos um maior detalhamento como manipular objetos, e otimizações existentes da linguagem, como por exemplo, modificação local, que se entendida, poderá perceber que o loop ambiente R não é lento quanto parece. Ao final desse volume, falaremos sobre como propagar o seu código com o sistema Git na plataforma GitHub, sincronizado com os projetos RStudio.","code":""},{"path":"entendendo-a-coleção-estudando-o-ambiente-r.html","id":"volume-iii-nível-avançado","chapter":"Capítulo 1 Entendendo a coleção Estudando o ambiente R ","heading":"1.3 Volume III: Nível Avançado","text":"O Volume III, será total exploração manual R Internals. Apesar de ser um assunto voltado para membros R Core Team, pretendemos entender como o R trabalha nos bastidores. Dessa forma, teremos total controle sobre nossas rotinas. Contudo, para usários que pretendem entender o ambiente R de forma aplicada, pode avançar esse volume para leitura dos volumes seguintes.","code":""},{"path":"entendendo-a-coleção-estudando-o-ambiente-r.html","id":"demais-volumes","chapter":"Capítulo 1 Entendendo a coleção Estudando o ambiente R ","heading":"1.4 Demais volumes","text":"Os demais volumes compreendem lacunas necessárias para serem abordadas com profundidade, tais como: Documentações R, Desenvolvimento de pacote R, Gráficos, Banco de dados, Interface Gráfica ao Usuário, Interface R com outras linguagens, dentre outros.","code":""},{"path":"entendendo-a-coleção-estudando-o-ambiente-r.html","id":"referencias","chapter":"Capítulo 1 Entendendo a coleção Estudando o ambiente R ","heading":"1.5 Referências complementares da Coleção","text":"Citaremos alguns livros e materiais utilizados para o desenvolvimento dessa coleção, que alguns podem ser acessados online via bookdown, tais como:Introduction R (R Core Team)Introduction R (R Core Team)R Data Import/Export (R Core Team)R Data Import/Export (R Core Team)R Installation Administration (R Core Team)R Installation Administration (R Core Team)Writing R Extensions (R Core Team)Writing R Extensions (R Core Team)R Language Definition (R Core Team)R Language Definition (R Core Team)R Internals (R Core Team)R Internals (R Core Team)Advanced R (WICKHAM, 2019)Advanced R (WICKHAM, 2019)Advanced R Solutions (GROSSER; BUMAN; WICKHAM, 2021)Advanced R Solutions (GROSSER; BUMAN; WICKHAM, 2021)R Packages (WICKHAM, 2015)R Packages (WICKHAM, 2015)R Data Science (WICKHAM; GROLEMUND, 2017)R Data Science (WICKHAM; GROLEMUND, 2017)Extending R (CHAMBERS, 2016)Extending R (CHAMBERS, 2016)Software Data Analysis: Programming R (CHAMBERS, 2008)Software Data Analysis: Programming R (CHAMBERS, 2008)R Nutshell (ADLER, 2012)R Nutshell (ADLER, 2012)New S Language (Livro Branco) (BECKER; CHAMBERS; WILKS, 1988)New S Language (Livro Branco) (BECKER; CHAMBERS; WILKS, 1988)Statistical Models S (Livro Azul) (CHAMBERS; HASTIE, 1991)Statistical Models S (Livro Azul) (CHAMBERS; HASTIE, 1991)Programming Data (Livro Verde) (CHAMBERS; HASTIE, 1998)Programming Data (Livro Verde) (CHAMBERS; HASTIE, 1998)Vale salientar que esses três últimos livros, se pudéssemos unir, seria bíblia ambiente R.","code":""},{"path":"entendendo-a-coleção-estudando-o-ambiente-r.html","id":"pacutilizados","chapter":"Capítulo 1 Entendendo a coleção Estudando o ambiente R ","heading":"1.6 Pacotes R utilizados para essa coleção","text":"Apresentamos uma lista de pacotes, Tabela 1.1, utilizados ao longo da coleção para os exemplos abordados, como também para o próprio desenvolvimento dos livros.TABELA 1.1:  Pacotes serem instalados para o acompanhamento dos exemplos e exercícios da coleção Estudando o ambiente R.","code":""},{"path":"entendendo-a-coleção-estudando-o-ambiente-r.html","id":"história-do-r","chapter":"Capítulo 1 Entendendo a coleção Estudando o ambiente R ","heading":"1.7 História do R","text":"linguagem R tem sua primeira aparição científica publicada em 1996, com o artigo intitulado\nR: Language Data Analysis Graphics, cujos os autores são os desenvolvedores da linguagem,\nGeorge Ross Ihaka e Robert Clifford Gentleman.\nFIGURA 1.1: Criadores R.\nDurante época em que estes professores trabalhavam na Universidade de Auckland, Nova Zelândia, desenvolvendo uma implementação alternativa da lingugagem S, desenvolvida por John Chambers, que comercialmente era o S-PLUS, nasceu em 1991, o projeto da linguagem R , em que em 1993 o projeto é divulgado e em 1995, o primeiro lançamento oficial, como software livre com\nlicença GNU. Devido demanda de correções da linguagem que estava acima da capacidade de\natualização em tempo real, foi criado em 1997, um grupo central voluntário, responsável por essas\natualizações, o conhecido R Development Core Team2, que hoje está em 20 membros (atualizado\nem 5 de novembro de 2021): Douglas Bates, John Chambers, Peter Delgaard, Robert Gentleman,\nKurt Hornik, Ross Ihaka, Tomas Kalibera, Michael Lawrence, Friedrich Leisch, Uwe Ligges, Thomas\nLumley, Martin Maechler, Sebastian Meyer, Paul Murrel, Martyn Plummer, Brian Ripley, Deepayan\nSarkarm, Duncan Temple Lang, Luke Tierney e Simon Urbanek. Por fim, o CRAN (Comprehensive R Archive Network) foi oficialmente anunciado em 23 de abril de 1997 3. O CRAN é um conjunto de sites (espelhos) que transportam material idêntico, com\ncontribuições R de uma forma geral.","code":""},{"path":"entendendo-a-coleção-estudando-o-ambiente-r.html","id":"o-que-é-o-r","chapter":"Capítulo 1 Entendendo a coleção Estudando o ambiente R ","heading":"1.8 O que é o R ?","text":"R é uma linguagem de programação e ambiente de software livre e código aberto (open source). Entendemos4:Software livre: software que respeita liberdade e sendo de comunidade dos usuários, isto é, os usuários possuem liberdade de executar, copiar, distribuir, estudar, mudar, melhorar o software. Ainda reforça que um software é livre se os seus usuários possuem quatro liberdades:\nLiberdade 0 - liberdade de executar o programa como você desejar, para qualquer propósito;\nLiberdade 1 - liberdade de estudar como o programa funciona, e adaptá-la suas necessidades;\nLiberdade 2 - liberdade de redistribuir cópias de modo que você possa ajudar outros;\nLiberdade 3 - liberdade de distribuir cópias de suas versões modificadas outros;\nSoftware livre: software que respeita liberdade e sendo de comunidade dos usuários, isto é, os usuários possuem liberdade de executar, copiar, distribuir, estudar, mudar, melhorar o software. Ainda reforça que um software é livre se os seus usuários possuem quatro liberdades:Liberdade 0 - liberdade de executar o programa como você desejar, para qualquer propósito;Liberdade 1 - liberdade de estudar como o programa funciona, e adaptá-la suas necessidades;Liberdade 2 - liberdade de redistribuir cópias de modo que você possa ajudar outros;Liberdade 3 - liberdade de distribuir cópias de suas versões modificadas outros;Algo que deve estar claro é que um software livre não significa não comercial. Sem esse fim, o software livre não atingiria seus objetivos. Agora perceba que, segundo Richard Stallman, ideia de software livre faz campanha pela liberdade para os usuários da computação. Por outro lado, o código aberto valoriza principalmente vantagem prática e não faz campanha por princípios.Código aberto: Para Richard Stallman 6 código aberto apoia critérios um pouco mais flexíveis que os software livre. Todos os códigos abertos de software livre lançados se qualificariam como código aberto. Quase todos os softwares de código aberto são software livre, mas há exceções, como algumas licenças de código aberto que são restritivas demais, de forma que elas não se qualificam como licenças livres. Nesse contexto, o autor cita muitas situações que diferenciam os dois termos. Vale pena leitura.linguagem R é uma combinação da linguagem S com semântica de escopo léxico da linguagem Scheme. Dessa forma, linguagem R se diferencia em dois aspectos principais 7:Gerenciamento de memória: usando próprias palavras de Ross Ihaka, em R, alocamos uma quantidade fixa de memória na inicialização e gerenciamos com um coletor de lixo dinâmico. Isso significa que há muito pouco crescimento de heap e, como resultado, há menos problemas de paginação que os vistos em S.Gerenciamento de memória: usando próprias palavras de Ross Ihaka, em R, alocamos uma quantidade fixa de memória na inicialização e gerenciamos com um coletor de lixo dinâmico. Isso significa que há muito pouco crescimento de heap e, como resultado, há menos problemas de paginação que os vistos em S.Escopo: na linguagem R, funções acessam variáveis criadas pelo o corpo da própria função, como também variáveis contidas ambiente que função foi criada. caso da linguagem S, isso não ocorre, assim, como por exemplo na linguagem C, em que funções acessam apenas variáveis definidas globalmente.Escopo: na linguagem R, funções acessam variáveis criadas pelo o corpo da própria função, como também variáveis contidas ambiente que função foi criada. caso da linguagem S, isso não ocorre, assim, como por exemplo na linguagem C, em que funções acessam apenas variáveis definidas globalmente.Vejamos alguns exemplos para entendimento (Se você ainda não está ambientado ao R, estude esse módulo primeiro, e depois reflita sobre esses exemplos). Antes de executar linhas de comando, instale o pacote lobstr como segue:\\[CODIGO\\]Como linguagem S é uma linguagem interpretada cuja base é linguagem FORTRAN, linguagem R também é uma linguagem interpretada e baseada além da linguagem S, tem como base linguagens de baixo nível C, FORTRAN e própria linguagem R.Embora o R tenha uma interface baseada em linhas de comando, existem muitas interfaces gráficas ao usuário com destaque ao RStudio, criado por Joseph J. Allaire, Figura 1.2.\nFIGURA 1.2: J. J. Allaire, o criador RStudio\nEssa interface tornou o R mais popular, pois além de produzir,hoje, pacotes de grande utilização como família de pacotes tidyverse, rmarkdown, shiny, dentre outros, permite uma eficiente capacidade de trabalho de análise de utilização R. Uma vez que o RStudio facilita utilização de muitos recursos por meio de botões, como por exemplo, criação de um pacote R. Há quem diga que para um iniciante em R, não seja recomendado utilizar o RStudio para o entendimento da linguagem. Cremos, que o problema não é IDE utilizada, e sim, o caminho onde deseja chegar com linguagem R.Brasil, o primeiro espelho CRAN foi criado na UFPR, pelo grupo Prof. Paulo Justiniano. Inclusive um dos primeiros materiais mais completos sobre linguagem R produzidos Brasil, foi dele, iniciado em 2005, intitulado “Introdução ao Ambiente Estatístico R”. Vale pena assistirmos evento palestra: R Reflexões: um pouco de história e experiências com o R, proferida pelo Prof. Paulo Justiniano Ribeiro Júnior, R Day - Encontro nacional de usuários R, ocorrido em 2018 em Curitiba/UFPR, qual o vídeo está disponível Canal (Youtube) LEG UFPR.","code":""},{"path":"entendendo-a-coleção-estudando-o-ambiente-r.html","id":"instalação-do-r-e-rstudio","chapter":"Capítulo 1 Entendendo a coleção Estudando o ambiente R ","heading":"1.9 Instalação do R e RStudio","text":"Para realizarmos instalação ambiente R , uma vez que o RStudio é apenas uma IDE, e sem o R, não há sentido instalá-lo, seguimos os seguintes passos:Instalação R - https://www.r-project.org, Figura 1.3 e 1.4:\nFIGURA 1.3:  Primeiro passo para Instalação R\n\nFIGURA 1.4: Segundo passo para Instalação R\nInstalação RStudio - https://rstudio.com/products/rstudio/download/#download:Justificamos utilização RStudio pela quantidade de recursos disponíveis e diversidade de usuários R, que hoje o perfil não é apenas de um programador, mas de um usuário que necessita de uma ferramenta estatística para análise de seus dados. Dessa forma, até por questão de praticidade, e de uso pessoal, não deixaremos de repassar o entendimento sobre linguagem R com o uso RStudio.Outra coisa importante, é que esses passos para instalação R e RStudio se basearam sistema operacional Windows, mas para detalhes sobre essas instalações em outros sistemas operacionais, acesse:\nhttps://bendeivide.github.io/cursor.\nFIGURA 1.5: Instalação RStudio\n","code":""},{"path":"como-o-r-trabalha.html","id":"como-o-r-trabalha","chapter":"Capítulo 2 Como o R trabalha","heading":"Capítulo 2 Como o R trabalha","text":"Iniciamos discussão por uma afirmação de John McKinley Chambers, qual afirmou que o R tem três princípios (Chambers 2016):\nFIGURA 2.1: John Chambers2, o criador da linguagem S.\nPrincípio Objeto: Tudo que existe em R é um objeto;Princípio da Função: Tudo que acontece R é uma chamada de função;Princípio da Interface: Interfaces para outros programas são parte R;Ao longo de todo o curso, para os três módulos, iremos nos referir esses princípios. Vamos inicialmente observar uma adaptação da ilustração feita por Paradis (2005), mostrando como o R trabalha, Figura 2.2.Toda ação que acontece R é uma chamada de função (Operadores e funções), que por sua vez é armazenada na forma de um objeto, e este se associa um nome. forma de execução de uma função é baseada em argumentos (dados, fórmulas, expressões, etc), que são entradas, ou argumentos padrões que já são pré-estabelecidos na criação da função. Esses tipos de argumentos podem ser modificados na execução da função. Por fim, saída é o resultado, que é também um objeto, e pode ser usado como argumento de outras funções.\nFIGURA 2.2: Esquema de como o R funciona.\nNa Figura 2.2, observamos que todas ações realizadas sobre os objetos ficam armazenadas na memória ativa computador. Esses objetos são criados por comandos (teclado ou mouse) através de funções ou operadores (chamada de função), dos quais leem ou escrevem arquivos de dados disco rígido, ou leem da própria internet. Por fim, o resultado desses objetos podem ser apresentados console (memória ativa), exportados em formato de imagem, página web, etc. (disco rígido), ou até mesmo ser reaproveitado como argumento de outras funções, porque o resultado também é um objeto.","code":"\nknitr::include_graphics(\"img/Criador_S.PNG\")\nknitr::include_graphics(\"img/Funcionamento_R.PNG\")"},{"path":"como-o-r-trabalha.html","id":"como-utilizar-o-r-e-o-rstudio","chapter":"Capítulo 2 Como o R trabalha","heading":"2.1 Como utilizar o R e o RStudio","text":"primeira ideia que temos sobre linguagem R é linha de comando, que é simbolizada pelo prompt de comando “>”. Este símbolo significa que o R está pronto para receber os comandos usuário. O prompt de comando está localizado console R. Vejamos o console R seguir, que é o local que recebe linhas de comando usuário, Figura 2.3.O R ao ser iniciado, está pronto para receber linhas de comando desejadas. Uma forma simples de armazernar os seus comandos é por meio de um script, isto é, um arquivo de texto com extensão .R. Para criar, basta ir em: Arquivo > Novo script…. Veremos muitas outras informações ao longo curso.O RStudio se apresenta como uma interface para facilitar utilização R, tendo por padrão quatro quadrantes, demonstrado na Figura 2.4Muitas coisas na interface R podem se tornar problemas para os usuários, uma vez que janelas gráficas, janelas de scripts, dentre outras, se sobrepõe. Uma vantagem RStudio foi essa divisão de quadrantes, que torna muito mais organizado atividades realizadas R.De um modo geral, diremos que o primeiro quadrante é responsável pela entrada de dados, comandos, isto é, o input. O segundo quadrante, que é o console R , representa tanto entrada como saída de informações (input/output). Dependendo atividades abas podem aumentar. O terceiro quadrante representa informações básicas como objetos ambiente global, memória de comandos na aba History, dentre outras, e também representa entrada como saída de informações (input/output). Por fim, o quarto quadrante é responsável por representação gráficas, instalação de pacotes, renderização de páginas web.\nFIGURA 2.3: Console R (Versão 4.0.3).\n\nFIGURA 2.4: Interface RStudio (Versão 1.4.1103).\n","code":"\nknitr::include_graphics(\"img/Console_do_R.PNG\")\nknitr::include_graphics(\"img/Interface_RStudio.PNG\")"},{"path":"como-o-r-trabalha.html","id":"comandos-no-r","chapter":"Capítulo 2 Como o R trabalha","heading":"2.2 Comandos no R","text":"","code":""},{"path":"como-o-r-trabalha.html","id":"console-e-prompt-de-comando","chapter":"Capítulo 2 Como o R trabalha","heading":"2.2.1 Console e Prompt de comando","text":"Como falado anteriormente, o R é uma linguagem baseada em linhas de comando, e linhas de comando, são executadas uma de cada vez, console. Assim que o prompt de comando está visível na tela console, o R indica que o usuário está pronto para inserir linhas de comando. O símbolo padrão prompt de comando é “>”, porém, ele pode ser alterado. Para isso, use linha de comando, por exemplo ??O conjunto de símbolos que podem ser utilizados R depende sistema operacional e país em que o R está sendo executado. Basicamente, todos os símbolos alfanuméricos podem ser utilizados, mas para evitar problemas quanto ao uso das letras aos nomes, opte pelos caracteres ASCII.escolha nome associado um objeto tem algumas regras:Deve consistir em letras, dígitos, “.” e “_”;Deve consistir em letras, dígitos, “.” e “_”;Os nomes devem ser iniciado por uma letra ou um ponto não seguido de um número, isto é, Ex.: .123, 1n, dentre outros;Os nomes devem ser iniciado por uma letra ou um ponto não seguido de um número, isto é, Ex.: .123, 1n, dentre outros;letras maiúsculas se distinguem das letras minúsculas;letras maiúsculas se distinguem das letras minúsculas;Não pode inicia por “_” ou dígito, é retornado um erro console caso isso ocorra;Não pode inicia por “_” ou dígito, é retornado um erro console caso isso ocorra;Não pode usar qualquer uma das palavras reservadas pela linguagem, isto é, TRUE, FALSE, ,\n, dentre outras, que pode ser consultado usando o comando ?Reserved().Não pode usar qualquer uma das palavras reservadas pela linguagem, isto é, TRUE, FALSE, ,\n, dentre outras, que pode ser consultado usando o comando ?Reserved().Um nome que não segue essas regras é chamado de um nome não sintático. Um comando que pode ser usado para converter nomes não sintatícos em nomes sintáticos é make.names.Apesar dessas justificativas, algumas situações como apresentadas nos exemplos anteriores são possíveis, ver Wickham (2019) na Seção 2.2.1.","code":"R>options(prompt = \"R>\")\nR># Toda vez que o console iniciar, começarar por 'R>'\nR>10## [1] 10# Nome nao sintatico\n.123 <- 50\n## Error in 0.123 <- 50 : lado esquerdo da atribuicao inválida (do_set)\n# Qual a sugestao de nome sintatico para '.123'?\nmake.names(.123)\n[1] \"X0.123\""},{"path":"como-o-r-trabalha.html","id":"comandos-elementares","chapter":"Capítulo 2 Como o R trabalha","heading":"2.2.2 Comandos elementares","text":"Os comandos elementares podem ser divididos em expressões e atribuições. Por exemplo, podemos estar interessados em resolver seguinte expressão \\(10+15=25\\). console quando passamos pelo comando:console quando passamos pelo comando Código R 4.2, o R avalia essa expressão internamente e imprime o resultado na tela, após apertar o botão ENTER teclado. Esse fato é o que ocorre segundo princípio mencionado por Chambers (2016), tudo em R acontece por uma chamada de função. Na realidade o símbolo + é uma função interna R , que chamamos de função primitiva, porque foi implementada em outra linguagem. Assim, esse é o resultado de três objetos (“10”, “+”, “15”) que são avaliados internamente, qual função ‘+‘(e1, e2) é chamada, e em seguida o resultado é impresso console. Intrinsecamente, podemos também afirmar que função print() também trabalha nessa situação, fazendo o papel de imprimir o resultado console.mesmo modo, se houver algum problema em algum dos objetos o retorno da avaliação pode ser uma mensagem de erro. Um caso muito prático é quando utilizamos o separador de casas decimais, sendo vírgula “,”, para os números. Quando na realidade deve ser um ponto “.”, respeitando o sistema internacional de medidas. vírgula é utilizada para separar elementos, argumentos em uma função, etc. Vejamos um exemplo Código R 4.3.Porém, tem que ficar claro que uma expressão é qualquer comando repassado console. Este comando é avaliado e seu resultado impresso, há menos que explicitamente o usuário queira tornálo invisível. Caso algum elemento comando não seja reconhecido pelo R, há um retorno de alguma mensagem em forma de “erro” ou “alerta”, tentando indicar o possível problema. Todos esses processos ocorrem na memória ativa computador, e uma vez o resultado impresso console, o valor é perdido, há menos que você atribua essa expressão um nome, que erroneamento usamos o termo: “criamos um objeto!”. atribuição dessa expressão será dada pela junção de dois símbolos <-, falado mais frente. Um comando em forma de atribuição também avalia sua expressão, um nome se associa ao seu resultado, e o resultado será mostrado, se posteriormente, após execução você digitar o “nome” atribuído esse resultado. Vejamos um exemplo o Código R 4.4.","code":"\nR>10 + 15## [1] 25\n10.5 + 15.5## [1] 26\n# Foi criado um objeto do tipo caractere e o nome \"meu_nome\" foi associado a ele\n# O 'R' avalia essa expressão, mas não imprime no console!\nmeu_nome <- \"Ben\"\n# Para imprimir o resultado da expressão, digitamos o nome \"meu_nome\" no console\n# e apertamos o botão ENTER do teclado!\nmeu_nome## [1] \"Ben\""},{"path":"como-o-r-trabalha.html","id":"execução-de-comandos","chapter":"Capítulo 2 Como o R trabalha","heading":"2.2.3 Execução de comandos","text":"Quando inserimos um comando console, executamos uma linha de comando por vez ou separados por “;” em uma mesma linha. Vejamos o CódigoSe um comando muito grande e não couber em uma linha, ou caso deseje completar um\ncomando em mais de uma linha, após primeira linha haverá o símbolo “+” iniciando linha seguinte ao invés símbolo de prompt de comando (“>”), até que o comando esteja sintaticamente\ncompleto. Vejamos o Código R 4.6, seguir.Por fim, todas linhas de comando quando iniciam pelo símbolo jogo da velha, “#” indica um comentário e essa linha de comando não é avaliada pelo console, apenas impressa na tela. E ainda, linhas de comandos console são limitadas aproximadamente 4095 bytes (não caracteres).","code":"\n# Uma linha de comando por vez\nmeu_nome <- \"Ben\" # Criamos e associamos um nome ao objeto\nmeu_nome # Imprimos o objeto## [1] \"Ben\"\n# Tudo em uma linha de comando\nmeu_nome <- \"Ben\"; meu_nome## [1] \"Ben\"\n# Uma linha de comando em mais de uma linha\n(10 + 10) /\n  2## [1] 10"},{"path":"como-o-r-trabalha.html","id":"chamada-e-correção-de-comandos-anteriores","chapter":"Capítulo 2 Como o R trabalha","heading":"2.2.4 Chamada e correção de comandos anteriores","text":"Uma vez que um comando foi executado console, esse comando por ser recuperado usando teclas de setas para cima e para baixo teclado, recuperando os comandos anteriorermente executados, e que os caracteres podem ser alterados usando teclas esquerda e direita teclado, removidas com o botão Delete ou Backspace teclado, ou acrescentadas digitando os caracteres necessários. Uma outra forma de completar determinados comandos já existentes, como por exemplo, uma função que já existe nas bibliotecas de instalação R, usando o botão Tab teclado. O usuário começa digitando iniciais, e para completar o nome aperta tecla Tab. Posteriormente, basta completar linha de comando e apertar ENTER para executá-la. Para entender mais detalhes, acesse o link: https://youtu./0MRPmVsPvk4, e veja em vídeo-aula mais detalhes.Esses recursos RStudio são mais dinâmicos e vão mais além. Por exemplo, quando usamos um objeto tipo função, estes apresentam o que chamamos de argumento(s) dentro parêntese de uma função, qual são elementos necessários, para que função seja executada corretamente. Nesse caso, ao inseri o nome dessas funções console, usando o RStudio, ao iniciá-la com abertura parêntese, abre-se uma janela informando todos os argumentos possíveis dessa função. Isso torna muito dinâmico escrever linhas de comando, porque não precisaremos estar lembrando nome dos argumentos de uma função, mas apenas entender o objetivo dessa função. Para entender mais detalhes, acesse o link: https://youtu./KL3WAB_GFNI, e veja em vídeo-aula mais detalhes.","code":""},{"path":"como-o-r-trabalha.html","id":"ambiente-global-área-de-trabalho-ou-workspace","chapter":"Capítulo 2 Como o R trabalha","heading":"2.3 Ambiente Global (área de trabalho ou Workspace)","text":"Quando usamos um comando de atribuição console, o R armazena o nome associado ao objeto\ncriado na área de trabalho (Workspace), que nós chamamos de Ambiente Global. Teremos uma seção\nintrodutória na seção Ambientes e caminhos de busca, mas entendamos inicialmente que o objetivo\nde um ambiente é associar um conjunto de nomes um conjunto de valores. Vejamos o Código R\n4.7.Observemos que todos os objetos criados até o momento estão listados, e o que é mais surpreendente é que ambientes podem conter outros ambientes e até mesmo se conterem. Observe o objeto meu_nome é um ambiente e está contido Ambiente global. Será sempre dessa forma que recuperaremos um objeto criado console R . Caso contrário, se console esse comando não de atribuição esse objeto é perdido.","code":"\n# Nomes criados no ambiente \nx <- 10 - 6; y <- 10 + 4; w <- \"Maria Isabel\"\n# Verificando o nomes contidos no ambiente global\nls()## [1] \"meu_nome\" \"w\"        \"x\"        \"y\""},{"path":"como-o-r-trabalha.html","id":"arquivos-.rdata-e-.rhistory","chapter":"Capítulo 2 Como o R trabalha","heading":"2.4 Arquivos .RData e .Rhistory","text":"Ao final que falamos até agora, todo o processo ao inserir linhas de comando console, e desejarmos finalizar os trabalhos ambiente R , dois arquivos são criados, sob instrução usuário em querer aceitar ou não, um .RData e outro .Rhistory, cujas finalidades são:.RData: salvar todos os objetos criados que estão atualmente disponíveis;.RData: salvar todos os objetos criados que estão atualmente disponíveis;.Rhistory: salvar todas linhas de comandos inseridas console..Rhistory: salvar todas linhas de comandos inseridas console.Ao iniciar o R mesmo diretório onde esses arquivos foram salvos, é carregado toda sua área de trabalho anteriormente, bem como o histórico das linhas de comando utilizadas anteriormente.","code":""},{"path":"como-o-r-trabalha.html","id":"criando-e-salvando-um-script","chapter":"Capítulo 2 Como o R trabalha","heading":"2.5 Criando e salvando um script","text":"melhor forma de armazenarmos nossas linhas de código inseridas console é criando um Script. Este é um arquivo de texto com extensão .R. Uma vez criada, poderemos ao final salvar o arquivo e guardá-lo para utilizar futuramente.R , ao ser iniciado poderemos ir menu em Arquivo > Novo script…. Posteriormente, pode ser inserido linhas de comando, executadas console pela tecla de atalho F5. janelas Script e console possivelmente ficarão sobrepostas. Para uma melhor utilização, estas janelas podem ficar lado lado, configurando-menu em Janelas > Dividir na horizontal (ou Dividir lado lado).RStudio, poderemos criar um Script menu em File > New File > R Script, ou diretamente ícone abaixo da opção File menu, cujo o símbolo é um arquivo com o símbolo “+” em verde, que é o ícone New File, e escolher R Script. Esse arquivo abrirá primeiro quadrante na interface RStudio.Para salvar, devemos clicar botão com o símbolo de disquete (R/RStudio), escolher o nome arquivo e o diretório onde o arquivo será armazenado seu computador. Algumas ressalvas devem ser feitas:Escolha sempre um nome sem caracteres especiais, com acentos, etc.;Escolha sempre um nome sem caracteres especiais, com acentos, etc.;Escolha sempre um nome curto ou abreviado, que identifique finalidade das linhas de comando escritas;Escolha sempre um nome curto ou abreviado, que identifique finalidade das linhas de comando escritas;Evite espaços se o nome arquivo composto. Para isso, use o símbolo underline \"_\";Evite espaços se o nome arquivo composto. Para isso, use o símbolo underline \"_\";Quando escrever um código, evite também escrever caracteres especiais, exceto em casos de necessidade, como imprimir um texto na tela, títulos na criação de gráficos, dentre outras. Nos referimos especificamente, nos comentários código.Quando escrever um código, evite também escrever caracteres especiais, exceto em casos de necessidade, como imprimir um texto na tela, títulos na criação de gráficos, dentre outras. Nos referimos especificamente, nos comentários código.Um ponto bem interessante é o diretório. Quando criamos um Script primeira vez, e trabalhamos nele pós criação, muitos erros podem ser encontrados de início. Um problema clássico é importação de dados. O usuário tem um conjunto de de dados e deseja fazer importação para o R , porém, mesmo com todos os comandos corretos, o console retorna um erro, informando que não existe esse arquivo que contém os dados para serem informados. Isso é devido ao diretório de trabalho atual. Para verificar qual o diretório que está trabalhando momento, use linha de comando:Para alterar o diretório de trabalho, o usuário deve usar seguinte função setwd(“Aqui, deve ser apontado para o local desejado!”). Supomos que salvamos o nosso Script em C:_scripts_r. Assim, usamos função setwd() e ao apontarmos o local, barras devem ser inseridas de modo invertido, isto é, setwd(“C:/meu_scripts_r”), além de estar entre aspas.RStudio , isso pode ser feito em Session > Set Working Directory > Source File Location. Isso levará ao diretório corrente Script. Se desejar escolher outro diretório, vá em Session > Set Working Directory > Choose Directory…. Porém, uma vez criado um Script, e utilizado novamente, se o usuário estiver abrindo o RStudio também naquele primeiro momento, por padrão, o diretório de trabalho corrente será o mesmo diretório Script. Isso acaba otimizando o trabalho.Devemos nos atentar também, quando trabalhamos utilizando Scripts ou arquivos de banco de dados, em locais diferentes diretório corrente. Um outro recurso interessante é função source(), que tem o objetivo de executar todas linhas de comando de um Script sem precisar abri-lo. Isso pode ser útil, quando criamos funções para nossas atividades, porém elas não se encontram Script de trabalho para o momento. Assim, podemos criar um Script auxiliar que armazenas todas funções criadas para análises desejadas, e Script corrente, poderemos chamá-las sem precisar abri o Script auxiliar. Todos os objetos passam estar disponíveis ambiente global.Por fim, algo de muita importância para um programador e usuário de linguagem, comente suas linhas de comando. Mas faça isso partir primeiro dia em que foi desenvolvido o primeiro Script. Isso criará um hábito, uma vez que o arquivo não está sendo criado apenas para um momento, mas para futuras consultas. E quando voltamos Scripts com muitas linhas de comando, principalmente depois de algum tempo, e sem comentários, possivelmente você passará alguns instantes para tentar\nentender o que foi escrito.Outra coisa importante, é boa prática de escrita de um código, Capítulo ??, e o RStudio nos proporciona algumas ferramentas interessantes. Mas isso será visto mais frente.","code":"\ngetwd()"},{"path":"objetos.html","id":"objetos","chapter":"Capítulo 3 Objetos","heading":"Capítulo 3 Objetos","text":"Definimos um objeto como uma entidade ambiente R com características internas contendo informações necessárias para interpretar sua estrutura e conteúdo. Essas características são chamadas de atributos. Vamos entender o termo estrutura como disposição de como está o seu conteúdo. Por exemplo, estrutura de um objeto mais simples R é um vetor atômico, pois os elementos contidos nele, apresenta o mesmo modo, um tipo de atributo. Falaremos nisso, mais à frente. De forma didática, adaptaremos representação dos objetos formato de diagrama. Vejamos seguinte linha de comando:Todo mundo que tem uma certa noção sobre linguagem R afirmaria: “criei um objeto x que recebe o valor 10”. Para Wickham (2019) essa afirmação é imprecisa e pode levar um entendimento equivocado sobre o que acontece de fato. Para o mesmo autor, o correto é afirmar que o objeto 10 está se ligando um nome. E de fato, o objeto não tem um nome, mas o nome tem um objeto. O símbolo que associa um objeto um nome é o de atribuição, <-, isto é, junção símbolo desigualdade menor e o símbolo de menos. Para ver qual objeto associado ao nome, o usuário precisa apenas digitar o nome console e apertar tecla ENTER.Representaremos em termos de diagrama, um nome se ligando um objeto, na Figura 3.1.\nFIGURA 3.1: Dizemos que o nome 'x' se liga ao objeto tipo (estrutura) vetor.\nO identificador na memória ativa desse objeto pode ser obtida por:O diagrama explica que o nome criado x se associou com um objeto tipo (estrutura) vetor (vector) e modo numérico (numeric)1 , cuja identificação na memória ativa seu computador foi <0xf8a104fc20>. É claro que para cada vez que o usuário abri o ambiente R e executar novamente esse comando, ou repeti o comando, esse identificador irá alterar.Essa outra representação, Código R ??, ficará mais claro para afirmação feita anteriormente, segundo diagrama, Figura 3.2, que representa ligação nome y ao mesmo objeto. Os termos nos diagramas, serão usados de acordo com sintaxe da linguagem com os termos em inglês para melhor compreensão e fixação dos termos utilizados em R , uma vez que os termos na linguagem são baseados nesse idioma.Observem que não houve criação de um outro objeto, mas apenas ligação de mais um nome ao objeto existente, pois o identificador na memória ativa para o objeto não alterou, é o mesmo. Logo, não temos um outro objeto, mais dois nomes que se ligam ao mesmo objeto.\nFIGURA 3.2: Dizemos que o nome 'x' e ‘y’ se ligam ao objeto tipo (estrutura) vetor.\nMais especificamente, acrescentamos um outro diagrama, Figura 3.3, mostrando representação ambiente global (.GlobalEnv, nome associado ao objeto que representa o ambiente global).\nFIGURA 3.3: Dizemos que o nome 'x' e 'y' se ligam ao objeto tipo (estrutura) vetor e essa ligação fica armazenada ambiente global.\nDe todo modo, deixaremos para o Volume II, uma abordagem mais profunda sobre o assunto. O símbolo de atribuição poderá ser representado na direção da esquerda para à direita ou vice-versa, isto é,Essas duas linhas de comando anteriores podem ter passado despercebidas pelo leitor em uma situação. Se na segunda linha tivéssemos alterado o valor objeto de 10 para 30, por exemplo, associação de x seria ao objeto 30. Isso significa que se o nome já existe, ele será apagado da memória ativa computador e associado ao novo objeto 2. Veja,Uma outra forma menos convencional é usar função assign(), isto é,Ao invés símbolo de atribuição, muitos usuários utilizam o símbolo da igualdade “=” para associarmos nomes aos objetos, que o ambiente R compreenderá. Contudo, discutiremos mas adiante, Capítulo ??, que o uso da igualdade deverá em R ser usado apenas para utilização em argumentos de uma função.Quando desejamos executar mais de uma linha de comando por vez, separamos estas pelo símbolo “;”, isto é,Neste caso, executamos quatro comandos em uma linha. Associamos dois nomes dois objetos e imprimimos os seus valores.Por questão de comodidade, iremos partir de agora, sempre nos referir um objeto pelo nome associado ele, para não está sempre se expressando como “um nome associado um objeto”. Mas que fique claro discussão realizada anteriormente sobre esses conceitos.Nesse momento, nos limitaremos falar sobre objetos que armazenam dados, tipo caracteres,\nnúmeros e operadores lógicos (TRUE/FALSE).","code":"> x <- 10\nknitr::include_graphics(\"img/Ligacao_Objeto.PNG\")> lobstr::obj_addr(x)\n> # [1] \"0xf8a104fc20\"> y <- x\n> lobstr::obj_addr(y)\n> # [1] \"0xf8a104fc20\"\nknitr::include_graphics(\"img/Ligacao_Objeto2.PNG\")\nknitr::include_graphics(\"img/Objeto_Ambiente_Global.PNG\")> x <- 10\n> 10 -> x> lobstr::obj_addr(x)\n> # [1] \"0xf8a104fc20\"\n> x <- 30\n> lobstr::obj_addr(x)\n> # [1] \"0x42db6dbb50\"\nassign(\"m\", 15)\nm## [1] 15\nx <- 10; w <- 15; x; w## [1] 10## [1] 15"},{"path":"objetos.html","id":"atributos","chapter":"Capítulo 3 Objetos","heading":"3.1 Atributos","text":"Todos os objetos, terão pelo menos dois tipos de atributos, chamados de atributos intrínsecos. Os demais atributos, quando existem, podem ser verificados pela função attributes(). ideia dos atributos pode ser pensada como metadados, isto é, um conjunto de informações que caracterizam o objeto.Diremos também que todos os objetos R tem uma classe, e por meio dessas classes, determinadas funções podem ter comportamento diferente objetos com classes diferentes. Agora, devemos deixar claro essa informação, apesar R seguir o princípio objeto, nem tudo é orientado objetos, como por exemplo, observamos na linguagens C++ e Java. Deixemos esse tópico para discorrer Volume II.forma de se verificar classe de um objeto é pela função class(). Contudo, os objetos internos R (base), quando solicitado sua classe pela função class(), acabam retornando, algumas vezes, resultados equivocados. Uma alternativa é utilizar função sloop::s3_class() pacote sloop.Isso também será discutido Volume II.Devemos nos atentar uma questão: existe um atributo também chamado classe (class), e nem todos os objetos necessariamente tem esse atributo, apenas aqueles orientados objetos, como é o caso objeto com atributo classe. Por exemplo, é devido classe factor objeto criado pela função factor() que apesar seu resultado ser numérico, este não se comporta como numérico. Isto significa que o atributo classe muda o comportamento de como funções veem esse objeto. Entretanto, mesmo os objetos que não apresentam esse atributo, quando pedimos pela chamada class() desse referido objeto, haverá o retorno que chamamos de classe implícita, que nada mais é que tipagem objeto baseado atributo modo (mode() ou typeof()). Classe implícita não é definida pelo atributo class, mas pela tipagem objeto. Isso também será abordado Volume II.Para verificarmos se tal objeto tem o atributo class, usamos função attributes(). Quando este atributo existe, ele é coincidente com o resultado obtido também pela função class().O tipo da classe implícita pode ser numeric, logical, character, list, matrix, array. Outros objetos apresentam classes definidas pelo atributo class, como factor, data.frame, dentre outros.Para remover o efeito atributo class, usamos função unclass() para tal.Por exemplo, quando criamos um objeto da classe data.frame, vejamos o que acontece quando removemos esse atributo Código R 5.2.Observe que sem o atributo class= ‘data.frame’, o objeto tem classe list. Isto significa que, o objeto tem uma estrutura em forma de list, mas se comporta como um data.frame, que se apresenta como mostrado anteriormente.Veremos Volume II como criar atributos, classes, e mostrar que não conseguiremos mostrar todos os tipos de classes, pois todo momento se cria classes em objetos R desenvolvimento de pacotes.","code":"\n# Criamos um objeto de classe 'data.frame'\ndados <- data.frame(a = 1:3, b = LETTERS[1:3])\n# Imprimindo na tela\ndados##   a b\n## 1 1 A\n## 2 2 B\n## 3 3 C\n# Verificando sua classe\nclass(dados)## [1] \"data.frame\"\n# Verificando o efeito do objeto 'dados',\n# sem o efeito da classe\ndados2 <- unclass(dados); dados2## $a\n## [1] 1 2 3\n## \n## $b\n## [1] \"A\" \"B\" \"C\"\n## \n## attr(,\"row.names\")\n## [1] 1 2 3\n# Qual a classe desse objeto sem o efeito da\n# classe 'data.frame'\nclass(dados2)## [1] \"list\""},{"path":"objetos.html","id":"atributos-intrínsecos","chapter":"Capítulo 3 Objetos","heading":"3.1.1 Atributos intrínsecos","text":"Todos os objetos tem dois atributos intrínsecos: o modo e comprimento. O modo representa natureza dos elementos objetos. Para o caso dos vetores atômicos, o modo dos vetores podem ser cinco, numérico (numeric), lógico (logic), caractere 3 (character), complexo (complex) ou bruto (raw). Este último, não daremos evidência para esse momento, lembrando que essa tipagem está relacionada alinguagem S. O comprimento mede quantidade de elementos objeto. Para determinarmos o modo de um objeto, usamos função mode(). Vejamos alguns exemplos pelo Código R 5.3.Contudo, essa função mode() se baseou nos atributos baseados na linguagem S. Temos uma outra função para verificarmos o modo objeto que é por typeof(). O atributo modo retornado de um objeto para esta última função, está relacionado tipagem da linguagem C, Código R 5.4, uma vez que boa parte das rotinas R está nessa linguagem, principalmente funções pacote base. Existem 24 tipos que serão detalhados Volume II.Observamos que apesar de alguns vetores serem vazios, estes ainda tem um modo, observe nas seguintes linhas de comando, Código R 5.5.diferença existente nos objetos \\(y\\) e \\(y^2\\) para funções mode() e typeof() se referem apenas\ncomo o R armazena essas informações na memória computador. Podemos perguntar ao R se\ndois números são iguais, assim:Veja que o resultado é TRUE, isto é, sim eles são iguais. Agora, veja próxima linha de comando:O retorno agora foi FALSE, que significa que o armazenamento dessas informações não são iguais. Posteriormente, entenderemos que isso reflete código usuário, uma vez que um código escrito pode apresentar uma perda de desempenho simplesmente pela não necessidade de determinados objetos serem copiados.O termo double retornado pela função typeof() significa dupla precisão na linguagem de programação, que acaba tenho uma exigência de mais memória que o objeto de modo integer. Esses termos são utilizados na linguagem C. Já linguagem S não os diferencia, utiliza tudo como numeric.Aqui vale um destaque para o termo numérico, que R podem ter três significados:Pode significar um número real, isto é, para computação um número de dupla precisão (numeric e double seriam iguais nesse aspecto), Código R 5.6;nos sistemas S3 e S4 (orientação objetos), o termo numérico é usado como atalho para o modo integer ou double. Esse ponto veremos Volume II. Contudo, vejamos o Código R 5.7;Pode ser utilizado (.numeric()) para verificar se determinados objetos tem o modo numé- rico. Por exemplo, temos um objeto de classe factor que é importante para área da estatística experimental, representando os níveis de um fator em um experimento. Os elementos desse objeto pode ser número ou caracteres, mas serão representados como sempre por números. Entretanto, não se comportam como numérico, Código R 5.8;Tabela 5.1 seguir, mostra o retorno dos seis principais modos de um objeto tipo (estrutura) de vetores atômicos (Os modos apresentados baseiam-se apenas quanto característica dos dados objeto. É claro que um objeto não armazena apenas dados. Existem outras naturezas, que serão omitidas nesse momento).O comprimento objeto é informado pela função lenght(), qual representação em diagrama informa esse atributo. Vejamos linhas de comando Código R 5.9.Um diagrama apresentando esses três objetos ambiente global, pode ser apresentado na Figura 3.4. Observe que acrescentamos agora o comprimento dos objetos diagrama entre colchetes, ao lado atributo modo.\nFIGURA 3.4: Objetos v1, v2 e v3.\nUm resumo funções mensionadas podem ser refletidas com seguintes indagações:base::class() e loop::c3_class(): Qual o tipo de objeto?base::mode(): Qual o tipo de dados baseados na linguagem S?base::typeof(): Qual o tipo de dados baseados na linguagem C?base::attributes(): O objeto tem atributos?base::length(): Qual o comprimento objeto?Usamos essa sintaxe pacote::nome_função() para entedermos qual o pacote da função que utilizamos. Contudo, essa forma tem uma importância sentido de acesso funções em um pacote sem necessitar anexá-lo caminho de busca. Assunto abordado mais frente.","code":"> # Objeto modo caractere\n> x <- \"Ben\"; mode(x)## [1] \"character\"> # Objeto modo numerico\n> y <- 10L; mode(y)## [1] \"numeric\"> # Objeto modo numerico\n> y2 <- 10; mode(y2)## [1] \"numeric\"> # Objeto modo logico\n> z <- TRUE; mode(z)## [1] \"logical\"> # Objeto modo complexo\n> w <- 1i; mode(w)## [1] \"complex\"> # Objeto modo caractere\n> x <- \"Ben\"; typeof(x)## [1] \"character\"> # Objeto modo numerico (Inteiro)\n> y <- 10L; typeof(y) ## [1] \"integer\"> # Objeto modo numerico (Real)\n> y2 <- 10; typeof(y2)## [1] \"double\"> # Objeto modo logico\n> z <- TRUE; typeof(z)## [1] \"logical\"> # Objeto modo complexo\n> w <- 1i; typeof(w)## [1] \"complex\"> # Vetor numérico vazio de comprimento 1\n> numeric(0)## numeric(0)> # Verificando o seu modo\n> mode(numeric(0))## [1] \"numeric\"> typeof(numeric(0))## [1] \"double\"> # Vetor caractere vazio de comprimento 1\n> character(0)## character(0)> # Verificando o seu modo\n> mode(character(0))## [1] \"character\"> typeof(character(0))## [1] \"character\"> # 10 eh igual a 10L ?\n> 10 == 10L## [1] TRUE> # 10 eh identico a 10L ?\n> identical(10, 10L)## [1] FALSE> # Criacao de dois objetos de modo numerico\n> a <- numeric(1); b <- double(1)\n> # Verificando o modo\n> mode(a); mode(b)## [1] \"numeric\"## [1] \"numeric\"> # Verificando se 'a' e 'b' sao identificos\n> identical(a, b)## [1] TRUE> sloop::s3_class(1)## [1] \"double\"  \"numeric\"> sloop::s3_class(1L)## [1] \"integer\" \"numeric\"> # Criando um objeto de atributo classe 'factor':\n> fator <- factor(\"a\"); fator## [1] a\n## Levels: a> # O atributo classe muda a forma dos elementos. Veja quando retiramos o atributo \n> # classe 'factor', o objeto retorna o valor 1\n> unclass(fator)## [1] 1\n## attr(,\"levels\")\n## [1] \"a\"> # Para confirmar essa afirmacao anterior, vejamos o modo\n> mode(fator)## [1] \"numeric\"> typeof(fator)## [1] \"integer\"> # Apesar do resultado retornar 1, veja que ele nao se comporta como numerico\n> is.numeric(fator)## [1] FALSE> is.integer(fator)## [1] FALSE> # Vetor de comprimento 5\n> v1 <- 1:5\n> # Vetor de comprimento 3\n> v2 <- c(\"Ben\", \"Maria\", \"Lana\")\n> # Vetor de comprimento quatro\n> v3 <- c(TRUE, FALSE, TRUE, TRUE)\n> # Vejamos o comprimento dos vetores\n> length(v1)## [1] 5> length(v2)## [1] 3> length(v3)## [1] 4\nknitr::include_graphics(\"img/Diagrama_Objetos.PNG\")"},{"path":"objetos.html","id":"coerção","chapter":"Capítulo 3 Objetos","heading":"3.2 Coerção","text":"Como falamos anteriormente, os vetores atômicos armazenam um conjunto de elementos de mesmo modo. coerção é forma como o R coage o modo dos objetos. Por exemplo, se um elemento de modo caractere estiver em um vetor, todos os demais elementos serão convertidos para esse modo. Vejamos linha de comando, seguir.Observe que todos os elementos ganharam aspas, isto é, se tornaram um caractere ou uma cadeia de caracteres. coersão entre vetores de modo numeric, character e logical será sempre como verificado pela Figura ??.caso dos vetores lógicos, todo TRUE se converterá em 1, e FALSE em 0. Porém, os modos dos vetores podem ser coagidos pelo usuário, usando funções tipo .() com prefixo ., isto é, se desejarmos que um objeto meu_objeto tenha o modo “character,” basta usar .character(meu_objeto). Para desejar saber se um objeto é de um determinado modo, usamos funções tipo .(), com o prefixo “.”. Vejamos o Código R 5.10, para elucidar o que discutimos anteriormente.","code":"> # Criando um objeto x e imprimindo o seu resultado\n> x <- c(\"Nome\", 3, 4, 5);x## [1] \"Nome\" \"3\"    \"4\"    \"5\"> # Objeto de modo numerico\n> minha_idade <- 35\n> mode(minha_idade)## [1] \"numeric\"> # Coersão do objeto para modo caractere (`string`)\n> minha_idade <- as.character(minha_idade)\n> mode(minha_idade)## [1] \"character\"> # Verificando se o objeto tem modo 'character'\n> is.character(minha_idade)## [1] TRUE"},{"path":"objetos.html","id":"tipo-de-objetos","chapter":"Capítulo 3 Objetos","heading":"3.3 Tipo de objetos","text":"Por fim, pretendemos falar sobre os principais tipos de objetos. O tipo vamos entender como estrutura de como os dados estão organizados em um objeto, relacionados aos seus atributos. Falamos anteriormente sobre estrutura mais simples, que é o vetor atômico. Mas entendemos que um vetor em R podem ser considerados: atômicos ou listas. Podemos então subdividi-los em:Vetores atômicos:\nLógicos, Numéricos e Caracteres;\nMatrizes unidimensionais (Matrix) e multidimensionais (Arrays);\nLógicos, Numéricos e Caracteres;Matrizes unidimensionais (Matrix) e multidimensionais (Arrays);Vetores em listas:\nListas (Lists);\nQuadro de dados (Data frames);\nListas (Lists);Quadro de dados (Data frames);Existem outros, mas para esse módulo, exploraremos estes nas seções seguintes. funções para coerções realizadas pelos usuários, são similares funções de coerção para modo, isto é, usar funções prefixadas ..Daremos uma visão geral dos objetos apresentados até o momento na Tabela 5.2.","code":""},{"path":"objetos.html","id":"vetores","chapter":"Capítulo 3 Objetos","heading":"3.3.1 Vetores","text":"Podemos dizer que existem três tipos principais de vetores atômicos:Numéricos (numeric):\nInteiro (integer);\nReal (double);\nInteiro (integer);Real (double);Lógico (logical);Caractere (character)Existem dois tipos raros que são os complexos (complex) e brutos (raw), que falaremos Volume\nII.","code":""},{"path":"objetos.html","id":"vetores-escalares-ou-constantes","chapter":"Capítulo 3 Objetos","heading":"3.3.1.1 Vetores escalares ou constantes","text":"O menor comprimento de um vetor é de tamanho um, conhecido também como um escalar. Porém, para o R tudo é observado como um vetor. sintaxes para os tipos especiais são:os vetores lógicos assumem valores: TRUE ou FALSE, ou abreviados, T ou F, respectivamente. Existem valores especiais devido precisão de operações na programação, que são os chamados pontos flutuantes. Nesse caso temos: Inf, -Inf e NaN, quando o resultados tende \\(\\infty\\), \\(-\\infty\\), sem número, respectivamente;os vetores lógicos assumem valores: TRUE ou FALSE, ou abreviados, T ou F, respectivamente. Existem valores especiais devido precisão de operações na programação, que são os chamados pontos flutuantes. Nesse caso temos: Inf, -Inf e NaN, quando o resultados tende \\(\\infty\\), \\(-\\infty\\), sem número, respectivamente;os vetores numéricos tipo ‘double‘ podem ser representados de forma decima (0.123), científica (1.23e5), ou hexadecimal (3E0A);os vetores numéricos tipo ‘double‘ podem ser representados de forma decima (0.123), científica (1.23e5), ou hexadecimal (3E0A);os vetores numéricos tipo integer são representados pela letra L ao final número inteiro,\nisto é, 1L, 1.23e5L, etc.;os vetores numéricos tipo integer são representados pela letra L ao final número inteiro,\nisto é, 1L, 1.23e5L, etc.;os caracteres são representados pelas palavras, letras, números ou caracteres especiais entre aspas, isto é, ’Ben’, ’’. Pode ser utilizado também aspa simples, ’Ben’, ’’, etc.os caracteres são representados pelas palavras, letras, números ou caracteres especiais entre aspas, isto é, ’Ben’, ’’. Pode ser utilizado também aspa simples, ’Ben’, ’’, etc.\\[CODIGO-1\\]\n\\[CODIGO-2\\]\n\\[CODIGO-3\\]\\[CODIGO-4\\]\\[CODIGO-5\\]","code":""},{"path":"objetos.html","id":"vetores-longos","chapter":"Capítulo 3 Objetos","heading":"3.3.1.2 Vetores longos","text":"Os vetores longos podem ser criados pela função c(), inicial da palavra concatenar (inglês, concatenate), que significa agrupar. Vejamos um primeiro exemplo Código R 5.16.Uma coisa interessante é que por padrão, função c() sempre cria um vetor de modo double, \nmenos que o usuário determine que estes elementos sejam inteiros, como pode ser visto Código\nR 5.17.Uma forma mais eficiente para criarmos um vetor com elementos de sequências regulares, é por meio da função primitiva (:), isto é, :, isto é,Veremos mais frente outras funções para construir sequências regulares. Se verificarmos os três objetos, veremos que todos eles são iguais:O que vai diferenciá-los é forma de armazená-lo (double ou integer), e por consequência, o espaço na memória ativa, como podemos observar Código R 5.18.O que podemos observar é que o vetor de modo double precisa de mais memória para armazenar os valores que o objeto de modo integer. O último objeto, gerado pela chamada ‘:‘(), aparentemente ocupa mais memória. Porém, essa função apresenta um recurso interessante apresentado nas versões posteriores R (3.5.0), que é chamado de abreviação alternativa. Esse recurso faz com que sequência de números não seja armazenada completamente, apenas os extremos. Isso significa que para qualquer tamanho de sequência, ocupação de memória objeto será sempre mesma. Lembrando que essa sequência sempre terá o modo double na tipagem C. Outras formas de criar\nsequências de números é usando funções rep(), rep_len() (mais rápido), seq(), seq_along() (mais rápido) e seq_len() (mais rápido), sequence(), replicate(), gl(), e que pode ser observado Código R 5.19.Dessa forma, poderemos ter com o último objeto (vetor.num3) uma economia de memória, dependendo tamanho seu vetor, quando se compara com outras opções, isto é,","code":"> # Criando um vetor 'double'\n> vetor.num <- c(1, 2, 3, 4, 5); vetor.num## [1] 1 2 3 4 5> typeof(vetor.num)## [1] \"double\"> # Criando um vetor 'integer'\n> vetor.num2 <- c(1L, 2L, 3L, 4L, 5L); vetor.num; typeof(vetor.num2)## [1] 1 2 3 4 5## [1] \"integer\"> # Criando uma sequência de 1 a 5\n> vetor.num3 <- 1:5; vetor.num3; typeof(vetor.num3)## [1] 1 2 3 4 5## [1] \"integer\"> vetor.num == vetor.num2## [1] TRUE TRUE TRUE TRUE TRUE> vetor.num == vetor.num3## [1] TRUE TRUE TRUE TRUE TRUE> vetor.num2 == vetor.num3## [1] TRUE TRUE TRUE TRUE TRUE> # Objetos:\n> vetor.num <- c(1, 2, 3, 4, 5)\n> vetor.num2 <- c(1L, 2L, 3L, 4L, 5L)\n> vetor.num3 <- 1:5\n> # Memoria:\n> lobstr::obj_size(vetor.num)## 96 B> lobstr::obj_size(vetor.num2)## 80 B> lobstr::obj_size(vetor.num3)## 680 B> # Repete o numero 2 tres vezes\n> rep(x = 2, times = 3)## [1] 2 2 2> # Repete o vetor 1:3 tres vezes\n> rep(x = 1:3, times = 3)## [1] 1 2 3 1 2 3 1 2 3> # Repete cada numero do vetor, tres vezes\n> rep(x = 1:3, each = 3)## [1] 1 1 1 2 2 2 3 3 3> # Repete cada numero do vetor duas vezes,\n> # porem, o comprimento dessa sequencia esta\n> # limitado a 4\n> rep(1:3, each = 2, length.out = 4)## [1] 1 1 2 2> # O vetor eh repetido ate obter uma\n> # sequencia de tamanho 7\n> rep(x = 1:3, length.out = 7)## [1] 1 2 3 1 2 3 1> # (Versao mais rapida de rep) O vetor eh repetido ate obter uma\n> # sequencia de tamanho 15\n> rep_len(x = 1:10, length.out = 15)##  [1]  1  2  3  4  5  6  7  8  9 10  1  2  3  4  5> # Sequencia criada de 1 a 2, espacada em 0.1\n> seq(from = 1, to = 2, by = 0.1)##  [1] 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0> # Sequencia criada de 1 a 10, espacada em 1\n> seq(from = 1, to = 10, by = 1)##  [1]  1  2  3  4  5  6  7  8  9 10> # Sequencia criada de 1 a 10 de forma equisespacada\n> # de comprimento 20\n> seq(from = 1, to = 10, length.out = 20)##  [1]  1.000000  1.473684  1.947368  2.421053  2.894737  3.368421  3.842105\n##  [8]  4.315789  4.789474  5.263158  5.736842  6.210526  6.684211  7.157895\n## [15]  7.631579  8.105263  8.578947  9.052632  9.526316 10.000000> # Eh o mesmo que 1:length(y)\n> y <- rnorm(10)\n> seq(along.with = y)##  [1]  1  2  3  4  5  6  7  8  9 10> # Sequencia de 1 a 20\n> seq(20)##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20> # Sequencia criada de 10 a 100 de mesmo comprimento\n> # de x\n> x <- 1:10\n> seq(from = 10, to = 100, along.with = x)##  [1]  10  20  30  40  50  60  70  80  90 100> # (Versao mais rapida para seq) Eh o mesmo que\n> # 1:lenght(w)\n> w <- c(4, 3, 6, 9)\n> seq_along(w)## [1] 1 2 3 4> # (Versao mais rapida para seq) Eh o mesmo que 1:4\n> seq_len(4)## [1] 1 2 3 4> # Tamanho de memoria dos objetos\n> lobstr::obj_size(1:10)## 680 B> lobstr::obj_size(1:10000)## 680 B> lobstr::obj_size(1:1000000)## 680 B> lobstr::obj_size(c(1:10))## 96 B> lobstr::obj_size(c(1:10000))## 40,048 B> lobstr::obj_size(c(1:1000000))## 4,000,048 B"},{"path":"objetos.html","id":"manipulando-vetores","chapter":"Capítulo 3 Objetos","heading":"3.3.1.3 Manipulando vetores","text":"Quando algum elemento de um vetor não está disponível, representamos pela constante lógica NA, que pode ser coagida para qualquer outro modo de vetor, exceto para raw. Podemos ter constantes lógicas NA específicas para modos específicos: NA_integer_, NA_real_ (o equivalente para o modo double), NA_complex_ e NA_character_. Entretando, dependendo de onde o NA é inserido, o atributo modo objeto já converte para NA específico de acordo com o seu atributo modo. Essa constante contido vetor não altera o modo vetor, isto é,Podemos criar vetores atômicos iniciais sem nenhuma elemento, por meio das funções numeric(0),\ncharacter(0) e logical(0), isto é,","code":"> typeof(c(1, 2, 3, NA))## [1] \"double\"> typeof(c(1, 2, 3, NA))## [1] \"double\"> typeof(c(\"c\", \"b\", \"a\", NA))## [1] \"character\"> # Vetor numerico de comprimento 0\n> v1 <- numeric(0); length(v1)## [1] 0> v2 <- character(0); length(v2)## [1] 0> v3 <- logical(0); length(v2)## [1] 0"},{"path":"objetos.html","id":"matrizes-bidimensionais","chapter":"Capítulo 3 Objetos","heading":"3.3.2 Matrizes bidimensionais","text":"","code":""},{"path":"objetos.html","id":"matrizes-multidimensionais","chapter":"Capítulo 3 Objetos","heading":"3.3.3 Matrizes multidimensionais","text":"","code":""},{"path":"objetos.html","id":"listas","chapter":"Capítulo 3 Objetos","heading":"3.3.4 Listas","text":"","code":""},{"path":"objetos.html","id":"quadro-de-dados","chapter":"Capítulo 3 Objetos","heading":"3.3.5 Quadro de dados","text":"","code":""},{"path":"objetos.html","id":"funções","chapter":"Capítulo 3 Objetos","heading":"3.3.6 Funções","text":"","code":""},{"path":"objetos.html","id":"estruturas-de-controle","chapter":"Capítulo 3 Objetos","heading":"3.3.6.1 Estruturas de controle","text":"","code":""},{"path":"objetos.html","id":"como-criar-funções","chapter":"Capítulo 3 Objetos","heading":"3.3.6.2 Como criar funções","text":"","code":""},{"path":"objetos.html","id":"escopo-léxico","chapter":"Capítulo 3 Objetos","heading":"3.3.6.3 Escopo léxico","text":"","code":""},{"path":"importando-dados.html","id":"importando-dados","chapter":"Capítulo 4 Importando dados","heading":"Capítulo 4 Importando dados","text":"","code":""},{"path":"importando-dados.html","id":"preparação-dos-dados","chapter":"Capítulo 4 Importando dados","heading":"4.1 Preparação dos dados","text":"","code":""},{"path":"importando-dados.html","id":"importando-dados-1","chapter":"Capítulo 4 Importando dados","heading":"4.2 Importando dados","text":"","code":""},{"path":"boas-práticas-de-como-escrever-um-código.html","id":"boas-práticas-de-como-escrever-um-código","chapter":"Capítulo 5 Boas práticas de como escrever um código","heading":"Capítulo 5 Boas práticas de como escrever um código","text":"","code":""},{"path":"boas-práticas-de-como-escrever-um-código.html","id":"nomes-de-arquivos","chapter":"Capítulo 5 Boas práticas de como escrever um código","heading":"5.1 Nomes de arquivos","text":"","code":""},{"path":"boas-práticas-de-como-escrever-um-código.html","id":"comentar-as-linahs-de-comando","chapter":"Capítulo 5 Boas práticas de como escrever um código","heading":"5.2 Comentar as linahs de comando","text":"","code":""},{"path":"boas-práticas-de-como-escrever-um-código.html","id":"nome-de-objetos","chapter":"Capítulo 5 Boas práticas de como escrever um código","heading":"5.3 Nome de objetos","text":"","code":""},{"path":"boas-práticas-de-como-escrever-um-código.html","id":"sintaxe","chapter":"Capítulo 5 Boas práticas de como escrever um código","heading":"5.3.1 Sintaxe","text":"","code":""},{"path":"pacotes.html","id":"pacotes","chapter":"Capítulo 6 Pacotes","heading":"Capítulo 6 Pacotes","text":"","code":""},{"path":"pacotes.html","id":"estrutura-básica-de-um-pacote","chapter":"Capítulo 6 Pacotes","heading":"6.1 Estrutura básica de um pacote","text":"","code":""},{"path":"pacotes.html","id":"instalação-de-um-pacote","chapter":"Capítulo 6 Pacotes","heading":"6.2 Instalação de um pacote","text":"","code":""},{"path":"pacotes.html","id":"objetivos-de-um-pacote","chapter":"Capítulo 6 Pacotes","heading":"6.3 Objetivos de um pacote","text":"","code":""},{"path":"pacotes.html","id":"utilizando-funções-de-um-pacote","chapter":"Capítulo 6 Pacotes","heading":"6.4 Utilizando funções de um pacote","text":"","code":""},{"path":"pacotes.html","id":"carregando-e-anexando-um-pacote","chapter":"Capítulo 6 Pacotes","heading":"6.5 Carregando e anexando um pacote","text":"","code":""},{"path":"pacotes.html","id":"namespace-de-um-pacote","chapter":"Capítulo 6 Pacotes","heading":"6.6 NAMESPACE de um pacote","text":"","code":""},{"path":"pacotes.html","id":"usando-os-operadores-e","chapter":"Capítulo 6 Pacotes","heading":"6.7 Usando os operadores :: e :::","text":"","code":""},{"path":"ambientes-e-caminho-de-busca.html","id":"ambientes-e-caminho-de-busca","chapter":"Capítulo 7 Ambientes e caminho de busca","heading":"Capítulo 7 Ambientes e caminho de busca","text":"","code":""},{"path":"ambientes-e-caminho-de-busca.html","id":"a-superatribuição","chapter":"Capítulo 7 Ambientes e caminho de busca","heading":"7.1 A superatribuição","text":"","code":""},{"path":"interfaces-com-outras-linguagens.html","id":"interfaces-com-outras-linguagens","chapter":"Capítulo 8 Interfaces com outras linguagens","heading":"Capítulo 8 Interfaces com outras linguagens","text":"","code":""},{"path":"considerações-e-preparação-para-programação-em-r-nível-intermediário.html","id":"considerações-e-preparação-para-programação-em-r-nível-intermediário","chapter":"Capítulo 9 Considerações e preparação para Programação em R (Nível Intermediário)","heading":"Capítulo 9 Considerações e preparação para Programação em R (Nível Intermediário)","text":"","code":""},{"path":"referências.html","id":"referências","chapter":"Referências","heading":"Referências","text":"","code":""}]
