[{"path":"index.html","id":"bem-vindo","chapter":"Bem-vindo","heading":"Bem-vindo","text":" Este é um livro digital da coleção “Estudando o ambiente R”, Volume 1, intitulado R Básico, com o selo Democratizando Conhecimento (DC). O Livro é destinado aos usuários R que objetivam aprofundar o entendimento ambiente R para seus projetos pessoais e profissionais.","code":""},{"path":"index.html","id":"sugestões-e-críticas","chapter":"Bem-vindo","heading":"Sugestões e críticas","text":"Sugestões e críticas sobre o livro podem ser enviadas para livrosdeben@gmail.com.","code":""},{"path":"index.html","id":"livro-físico","chapter":"Bem-vindo","heading":"Livro físico","text":"O livro físico encontra-se à venda diretamente com Representante comercial (Allanna Lopes) pelo Whatsapp:Clique aqui para entrar em contatoO livro físico encontra-se à venda pelo Shopee:R básico (capa comum - internamente preto e branco)O livro físico encontra-se à venda pelo mercado livre:R básico (capa comum - internamente preto e branco)O livro físico encontra-se à venda pela Amazon:R básico (Capa comum e Colorido internamente): https://www.amazon.com/dp/6500515994;R básico (Capa comum e Preto e branco internamente): https://www.amazon.com/dp/6500531914","code":""},{"path":"index.html","id":"materiais-complamentares","chapter":"Bem-vindo","heading":"Materiais complamentares","text":"Todos os códigos aprensentados livro, apresentações, versão digital em PDF, dentre outras informações, podem ser encontrados em: https://bendeivide.github.io/books/eambr01/.","code":""},{"path":"index.html","id":"licença","chapter":"Bem-vindo","heading":"Licença","text":"Este trabalho está licenciado com uma Licença Creative Commons - Atribuição-NãoComercial 4.0 Internacional.","code":""},{"path":"epígrafe.html","id":"epígrafe","chapter":"Epígrafe","heading":"Epígrafe","text":"melhor linguagem é que você domina! (Ben Dêivide)","code":""},{"path":"prefácio.html","id":"prefácio","chapter":"Prefácio","heading":"Prefácio","text":"coleção Estudando o ambiente R é fruto de cursos ministrados sobre essa linguagem, bem como consultorias e estudos ao longo dos anos. Em 2005, quando ingressei na academia curso de Engenharia Agronômica fiquei fascinado com disciplina de Estatística segundo semestre ano corrente. Na sequência, acabo tendo o primeiro contato com o ambiente R, com pouco mais de 9 anos de seu lançamento e redistribuição. Poucos materiais naquela época haviam disponíveis em língua portuguesa. Porém, foi o suficiente para eu entender que estava diante de uma grande ferramenta computacional e estatística, necessária para o entendimento, pois sabia que poderia gerar além de conhecimento, bons frutos acadêmicos.Hoje, ano de 2021, usuário há mais de 15 anos dessa linguagem, percebi que sentia desconfortável, como apenas usário dessa ferramenta de trabalho. E assim, quando queremos aprender algo não há ferramenta melhor que aprender por ensinar. E assim, lotado Departamento de Estatística, Física e Matemática (DEFIM), campus Alto Paraopeba, pela Universidade Federal de São João del-Rei (UFSJ), juntamente com o Centro Acadêmico de Engenharia de Telecomunicações (UFSJ), resolvemos em parceria, ministrar nesse momento de pandemia uma sequência de módulos para o curso R, desde o nível Básico até ao módulo Avançado.ideia desse curso foi apresentar algo diferente relacionado maioria dos cursos em R, que foi sempre apresentar essa ferramenta dentro dos conceitos da área da Estatística. Apesar de uma coisa ser intrínseca outra, há muitas particularidades ambiente R que são complexos, e muitas vezes julgados erroneamente. Um dos exemplos clássicos é que loops em R são lentos e com alto gasto de memória, quando na realiadade, isso ocorre muitas vezes pelo não entendimento sistema de cópia de objetos nesse ambiente. Ainda mais, o entendimento desses cursos é agravado porque o entendimento sobre estatística além de um cunho matemático, tem o seu cunho filosófico de como metodologias foram desenvolvidas, e o entendimento mútuo da Estatística e o ambiente R, podem não ter o conhecimento real que essa potencial ferramenta pode proporcionar, uma vez que muitos assuntos complexos podem estar envolvidos em uma única aula.Assim, desenvolvemos na coleção Estudando o ambiente R os três volumes iniciais, referentes apenas linguagem R, sendo Volume : Nível Básico, Volume II: Nível Intermediário e Volume III: Nível Avançado. Fazendo alusão dos três livros iniciais sobre linguagem S de John Chambers, faremos uma explanação sobre assuntos de menor complexidade até noções mais complexas sobre o ambiente R, restringindo apenas sintaxe e semântica da linguagem. Os volumes subsequentes serão destinados Documentações R, Desenvolvimento de pacote R, Gráficos, Banco de dados, Interface Gráfica ao Usuário, Interface R com outras linguagens, dentre outros.Tentando engajar nossos alunos, e agora colegas de trabalho, tenho parceria Volume , de Diego Arthur, uma pessoa que tenta se superar cada desafio e assunto estudado.Por fim, espero que esse primeiro volume possa servir de referência para os passos iniciais nessa ferramenta tão importante para área de análise de dados.Ben Dêivide de Oliveira Batista","code":""},{"path":"entendendo-a-coleção-estudando-o-ambiente-r.html","id":"entendendo-a-coleção-estudando-o-ambiente-r","chapter":"Capítulo 1 Entendendo a coleção Estudando o ambiente R ","heading":"Capítulo 1 Entendendo a coleção Estudando o ambiente R ","text":"Coleção Estudando o ambiente R não tem como objetivo principal de ensinar análise de dados. Mas sim, proporcionar ao leitor um conhecimento sobre linguagem R, de modo que se possa usufruir todos os recursos que esse ambiente possa proporcionar.Ainda como complemento, não queremos nesse material, convencê-lo utilizar linguagem R, pois melhor linguagem é aquela que você domina. Contudo, pretendemos mostrar que os recursos utilizados pelo R não estão mais limitados própria análise de dados. Um exemplo é esse material, que nesse momento usufruímos da própria linguagem para repassar nossas experiências sem ao menos ter o domínio sobre linguagens tipo HTML, CSS, JavaScript, dentre outras, necessárias para uma boa renderização de página web. Isso mostra potencial ferramenta de trabalho que o ambiente R pode ser para vida profissional.Dessa forma, propormos um entendimento sobre sintaxe e semântica de como linguagem R é desenvolvida. Com isso, o leitor será capaz após leitura dos dois primeiros volumes, de estudar um pouco mais sobre essa ciência que nos últimos anos vem ganhando mais evidência, que é Estatística. Tudo isso devido ao grande volume de informações obtidos nessa era tecnológica. Juntamente com ela, o R se tornará uma poderosa ferramenta para entender os padrões que estão por trás dos dados, que por sinal, é moeda valiosa momento, ou melhor, sempre foi!Aprenderemos também recursos diversos na área da computação, como programação defensiva, desenvolvimento de interfaces gráficas, paralelização, como também recursos na área da estatística sem complexidades teóricas, como o desenvolvimento de gráficos e o uso de banco de dados. Ensinaremos também o desenvolvimento de materiais como artigos, livros, websites, blogs, dashboards. Por fim, chegaremos maior cobiça de um programador R, desenvolver um pacote.\n Observem que em muitos momentos utilizamos o artigo “o” para linguagem R. Pois é, isso ocorre porque ela também é considerada um software ou ambiente. Daí, também podemos chamá-la de software R, ou preferivelmente, ambiente R. \nOs módulos dessa coleção terão os três volumes base para o entendimento ambiente R:Volume : Nível Básico;Volume II: Nível Intermediário; eVolume III: Nìvel Avançado.seguir, explanaremos sobre cada um dos módulos.","code":""},{"path":"entendendo-a-coleção-estudando-o-ambiente-r.html","id":"volume-i-nível-básico","chapter":"Capítulo 1 Entendendo a coleção Estudando o ambiente R ","heading":"1.1 Volume I: Nível Básico","text":"Esse primeiro volume, que representa o livro corrente, apresenta um breve histórico sobre linguagem, sua instalação, bem como os recursos que IDE1 RStudio, o conhecimento da sintaxe e semântica da linguagem R, compreendendo estruturas bases da linguagem, sobre o que é um objeto e como construir uma função, o entendimento sobre fluxos de controle. O que é um pacote, carregar e anexar um pacote, e quem são pessoas que fazem parte da manutenção dessa linguagem, também serão assuntos desse primeiro módulo. Caminhos de busca, ambientes e namespaces, teremos noções básicas. Algo muito interessante, que pode mudar vida de um programador em R são boas práticas para escrita de um código, tema também abordado nesse módulo.ideia desse volume é proporcionar um entendimento básico, um primeiro contato com linguagem, fazendo com que o leitor possa dar os primeiros passos, executando primeiras linhas de comando. Mas também, dando o enfoque com erros tão recorrentes, como o entendimento sobre um objeto, ou o anexo de um pacote caminho de busca. Temas como esses, dentre outros, serão forma inicial que encontramos, para que posteriormente, seja dado um aprofundamento sobre estrutura de um objeto R bem como sua manipulação, e adicionado isso, inserção de como são os paradigmas da programação nesse ambiente. Essa última parte será estudada, Volume II, apresentado seguir.","code":""},{"path":"entendendo-a-coleção-estudando-o-ambiente-r.html","id":"volume-ii-nível-intermediário","chapter":"Capítulo 1 Entendendo a coleção Estudando o ambiente R ","heading":"1.2 Volume II: Nível Intermediário","text":"O volume II é introduzido com uma melhor caracterização ambiente R quanto ao seu escopo léxico, como linguagem interpretada, como programação funcional, como programação meta-paradigma, como programação dinâmica; apresentaremos manipulações de objetos em mais detalhe, bem como o surgimento de alguns outros objetos como tibble, cópias de objetos. Uma característica ambiente R é que linguagem pode ser orientada objetos e isso será estudado nesse módulo. Introduziremos ao desenvolvimento de pacotes R, e aprofundaremos sobre os ambientes. Por fim, mostraremos como desenvolver Projeto RStudio e integrá-los ao GitHub, e dessa forma, introduziremos sobre o sistema Git.Esse talvez seja o maior volume, dentre os três iniciais, porque apenar de não precisarmos entender mais ideia dos objetos, que foram retratadas Volume , inserção dos paradigmas da programação para este volume, trará uma maior riqueza de características para o R, mostrando sua versatilidade. Também, daremos um maior detalhamento como manipular objetos, e otimizações existentes da linguagem, como por exemplo, modificação local, que se entendida, poderá perceber que o loop ambiente R não é lento quanto parece. Ao final desse volume, falaremos sobre como propagar o seu código com o sistema Git na plataforma GitHub, sincronizado com os projetos RStudio.","code":""},{"path":"entendendo-a-coleção-estudando-o-ambiente-r.html","id":"volume-iii-nível-avançado","chapter":"Capítulo 1 Entendendo a coleção Estudando o ambiente R ","heading":"1.3 Volume III: Nível Avançado","text":"O Volume III, será total exploração manual R Internals. Apesar de ser um assunto voltado para membros R Core Team, pretendemos entender como o R trabalha nos bastidores. Dessa forma, teremos total controle sobre nossas rotinas. Contudo, para usários que pretendem entender o ambiente R de forma aplicada, pode avançar esse volume para leitura dos volumes seguintes.","code":""},{"path":"entendendo-a-coleção-estudando-o-ambiente-r.html","id":"demais-volumes","chapter":"Capítulo 1 Entendendo a coleção Estudando o ambiente R ","heading":"1.4 Demais volumes","text":"Os demais volumes compreendem lacunas necessárias para serem abordadas com profundidade, tais como: Documentações R, Desenvolvimento de pacote R, Gráficos, Banco de dados, Interface Gráfica ao Usuário, Interface R com outras linguagens, dentre outros.","code":""},{"path":"entendendo-a-coleção-estudando-o-ambiente-r.html","id":"referencias","chapter":"Capítulo 1 Entendendo a coleção Estudando o ambiente R ","heading":"1.5 Referências complementares da Coleção","text":"Citaremos alguns livros e materiais utilizados para o desenvolvimento dessa coleção, que alguns podem ser acessados online via bookdown, tais como:Introduction R (R Core Team)Introduction R (R Core Team)R Data Import/Export (R Core Team)R Data Import/Export (R Core Team)R Installation Administration (R Core Team)R Installation Administration (R Core Team)Writing R Extensions (R Core Team)Writing R Extensions (R Core Team)R Language Definition (R Core Team)R Language Definition (R Core Team)R Internals (R Core Team)R Internals (R Core Team)Advanced R (WICKHAM, 2019)Advanced R (WICKHAM, 2019)Advanced R Solutions (GROSSER; BUMAN; WICKHAM, 2021)Advanced R Solutions (GROSSER; BUMAN; WICKHAM, 2021)R Packages (WICKHAM, 2015)R Packages (WICKHAM, 2015)R Data Science (WICKHAM; GROLEMUND, 2017)R Data Science (WICKHAM; GROLEMUND, 2017)Extending R (CHAMBERS, 2016)Extending R (CHAMBERS, 2016)Software Data Analysis: Programming R (CHAMBERS, 2008)Software Data Analysis: Programming R (CHAMBERS, 2008)R Nutshell (ADLER, 2012)R Nutshell (ADLER, 2012)New S Language (Livro Branco) (BECKER; CHAMBERS; WILKS, 1988)New S Language (Livro Branco) (BECKER; CHAMBERS; WILKS, 1988)Statistical Models S (Livro Azul) (CHAMBERS; HASTIE, 1991)Statistical Models S (Livro Azul) (CHAMBERS; HASTIE, 1991)Programming Data (Livro Verde) (CHAMBERS; HASTIE, 1998)Programming Data (Livro Verde) (CHAMBERS; HASTIE, 1998)Vale salientar que esses três últimos livros, se pudéssemos unir, seria bíblia ambiente R.","code":""},{"path":"entendendo-a-coleção-estudando-o-ambiente-r.html","id":"pacutilizados","chapter":"Capítulo 1 Entendendo a coleção Estudando o ambiente R ","heading":"1.6 Pacotes R utilizados para essa coleção","text":"Apresentamos uma lista de pacotes, Tabela 1.1, utilizados ao longo da coleção para os exemplos abordados, como também para o próprio desenvolvimento dos livros.TABELA 1.1:  Pacotes serem instalados para o acompanhamento dos exemplos e exercícios da coleção Estudando o ambiente R.","code":""},{"path":"história-e-instalação-do-r.html","id":"história-e-instalação-do-r","chapter":"Capítulo 2 História e instalação do R","heading":"Capítulo 2 História e instalação do R","text":"linguagem R tem sua primeira aparição científica publicada em 1996, com o artigo intitulado\nR: Language Data Analysis Graphics, cujos os autores são os desenvolvedores da linguagem,\nGeorge Ross Ihaka e Robert Clifford Gentleman.\nFIGURA 2.1: Criadores R.\nDurante época em que estes professores trabalhavam na Universidade de Auckland, Nova Zelândia, desenvolvendo uma implementação alternativa da lingugagem S, desenvolvida por John Chambers, que comercialmente era o S-PLUS, nasceu em 1991, o projeto da linguagem R , em que em 1993 o projeto é divulgado e em 1995, o primeiro lançamento oficial, como software livre com\nlicença GNU. Devido demanda de correções da linguagem que estava acima da capacidade de\natualização em tempo real, foi criado em 1997, um grupo central voluntário, responsável por essas\natualizações, o conhecido R Development Core Team2, que hoje está em 20 membros (atualizado\nem 5 de novembro de 2021): Douglas Bates, John Chambers, Peter Delgaard, Robert Gentleman,\nKurt Hornik, Ross Ihaka, Tomas Kalibera, Michael Lawrence, Friedrich Leisch, Uwe Ligges, Thomas\nLumley, Martin Maechler, Sebastian Meyer, Paul Murrel, Martyn Plummer, Brian Ripley, Deepayan\nSarkarm, Duncan Temple Lang, Luke Tierney e Simon Urbanek. Por fim, o CRAN (Comprehensive R Archive Network) foi oficialmente anunciado em 23 de abril de 1997 3. O CRAN é um conjunto de sites (espelhos) que transportam material idêntico, com\ncontribuições R de uma forma geral.","code":""},{"path":"história-e-instalação-do-r.html","id":"o-que-é-o-r","chapter":"Capítulo 2 História e instalação do R","heading":"2.1 O que é o R ?","text":"R é uma linguagem de programação e ambiente de software livre e código aberto (open source). Entendemos4:Software livre: software que respeita liberdade e sendo de comunidade dos usuários, isto é, os usuários possuem liberdade de executar, copiar, distribuir, estudar, mudar, melhorar o software. Ainda reforça que um software é livre se os seus usuários possuem quatro liberdades:\nLiberdade 0 - liberdade de executar o programa como você desejar, para qualquer propósito;\nLiberdade 1 - liberdade de estudar como o programa funciona, e adaptá-la suas necessidades;\nLiberdade 2 - liberdade de redistribuir cópias de modo que você possa ajudar outros;\nLiberdade 3 - liberdade de distribuir cópias de suas versões modificadas outros;\nSoftware livre: software que respeita liberdade e sendo de comunidade dos usuários, isto é, os usuários possuem liberdade de executar, copiar, distribuir, estudar, mudar, melhorar o software. Ainda reforça que um software é livre se os seus usuários possuem quatro liberdades:Liberdade 0 - liberdade de executar o programa como você desejar, para qualquer propósito;Liberdade 1 - liberdade de estudar como o programa funciona, e adaptá-la suas necessidades;Liberdade 2 - liberdade de redistribuir cópias de modo que você possa ajudar outros;Liberdade 3 - liberdade de distribuir cópias de suas versões modificadas outros;Algo que deve estar claro é que um software livre não significa não comercial. Sem esse fim, o software livre não atingiria seus objetivos. Agora perceba que, segundo Richard Stallman, ideia de software livre faz campanha pela liberdade para os usuários da computação. Por outro lado, o código aberto valoriza principalmente vantagem prática e não faz campanha por princípios.Código aberto: Para Richard Stallman 6 código aberto apoia critérios um pouco mais flexíveis que os software livre. Todos os códigos abertos de software livre lançados se qualificariam como código aberto. Quase todos os softwares de código aberto são software livre, mas há exceções, como algumas licenças de código aberto que são restritivas demais, de forma que elas não se qualificam como licenças livres. Nesse contexto, o autor cita muitas situações que diferenciam os dois termos. Vale pena leitura.linguagem R é uma combinação da linguagem S com semântica de escopo léxico da linguagem Scheme. Dessa forma, linguagem R se diferencia em dois aspectos principais 7:Gerenciamento de memória: usando próprias palavras de Ross Ihaka, em R, alocamos uma quantidade fixa de memória na inicialização e gerenciamos com um coletor de lixo dinâmico. Isso significa que há muito pouco crescimento de heap e, como resultado, há menos problemas de paginação que os vistos em S.Gerenciamento de memória: usando próprias palavras de Ross Ihaka, em R, alocamos uma quantidade fixa de memória na inicialização e gerenciamos com um coletor de lixo dinâmico. Isso significa que há muito pouco crescimento de heap e, como resultado, há menos problemas de paginação que os vistos em S.Escopo: na linguagem R, funções acessam variáveis criadas pelo o corpo da própria função, como também variáveis contidas ambiente que função foi criada. caso da linguagem S, isso não ocorre, assim, como por exemplo na linguagem C, em que funções acessam apenas variáveis definidas globalmente.Escopo: na linguagem R, funções acessam variáveis criadas pelo o corpo da própria função, como também variáveis contidas ambiente que função foi criada. caso da linguagem S, isso não ocorre, assim, como por exemplo na linguagem C, em que funções acessam apenas variáveis definidas globalmente.Vejamos alguns exemplos para entendimento (Se você ainda não está ambientado ao R, estude esse módulo primeiro, e depois reflita sobre esses exemplos). Antes de executar linhas de comando, instale o pacote lobstr como segue:\\[CODIGO\\]Como linguagem S é uma linguagem interpretada cuja base é linguagem FORTRAN, linguagem R também é uma linguagem interpretada e baseada além da linguagem S, tem como base linguagens de baixo nível C, FORTRAN e própria linguagem R.Embora o R tenha uma interface baseada em linhas de comando, existem muitas interfaces gráficas ao usuário com destaque ao RStudio, criado por Joseph J. Allaire, Figura 2.2.\nFIGURA 2.2: J. J. Allaire, o criador RStudio\nEssa interface tornou o R mais popular, pois além de produzir,hoje, pacotes de grande utilização como família de pacotes tidyverse, rmarkdown, shiny, dentre outros, permite uma eficiente capacidade de trabalho de análise de utilização R. Uma vez que o RStudio facilita utilização de muitos recursos por meio de botões, como por exemplo, criação de um pacote R. Há quem diga que para um iniciante em R, não seja recomendado utilizar o RStudio para o entendimento da linguagem. Cremos, que o problema não é IDE utilizada, e sim, o caminho onde deseja chegar com linguagem R.Brasil, o primeiro espelho CRAN foi criado na UFPR, pelo grupo Prof. Paulo Justiniano. Inclusive um dos primeiros materiais mais completos sobre linguagem R produzidos Brasil, foi dele, iniciado em 2005, intitulado “Introdução ao Ambiente Estatístico R”. Vale pena assistirmos evento palestra: R Reflexões: um pouco de história e experiências com o R, proferida pelo Prof. Paulo Justiniano Ribeiro Júnior, R Day - Encontro nacional de usuários R, ocorrido em 2018 em Curitiba/UFPR, qual o vídeo está disponível Canal (Youtube) LEG UFPR.","code":""},{"path":"história-e-instalação-do-r.html","id":"instalação-do-r-e-rstudio","chapter":"Capítulo 2 História e instalação do R","heading":"2.2 Instalação do R e RStudio","text":"Para realizarmos instalação ambiente R , uma vez que o RStudio é apenas uma IDE, e sem o R, não há sentido instalá-lo, seguimos os seguintes passos:Instalação R - https://www.r-project.org, Figura 2.3 e 2.4:\nFIGURA 2.3:  Primeiro passo para Instalação R\n\nFIGURA 2.4: Segundo passo para Instalação R\nInstalação RStudio - https://rstudio.com/products/rstudio/download/#download:Justificamos utilização RStudio pela quantidade de recursos disponíveis e diversidade de usuários R, que hoje o perfil não é apenas de um programador, mas de um usuário que necessita de uma ferramenta estatística para análise de seus dados. Dessa forma, até por questão de praticidade, e de uso pessoal, não deixaremos de repassar o entendimento sobre linguagem R com o uso RStudio.Outra coisa importante, é que esses passos para instalação R e RStudio se basearam sistema operacional Windows, mas para detalhes sobre essas instalações em outros sistemas operacionais, acesse:\nhttps://bendeivide.github.io/cursor.\nFIGURA 2.5: Instalação RStudio\n","code":""},{"path":"como-o-r-trabalha.html","id":"como-o-r-trabalha","chapter":"Capítulo 3 Como o R trabalha?","heading":"Capítulo 3 Como o R trabalha?","text":"Iniciamos discussão por uma afirmação de John McKinley Chambers, qual afirmou que o R tem três princípios (Chambers 2016):\nFIGURA 3.1: John Chambers2, o criador da linguagem S.\nPrincípio Objeto: Tudo que existe em R é um objeto;Princípio da Função: Tudo que acontece R é uma chamada de função;Princípio da Interface: Interfaces para outros programas são parte R;Ao longo de todo o curso, para os três módulos, iremos nos referir esses princípios. Vamos inicialmente observar uma adaptação da ilustração feita por Paradis (2005), mostrando como o R trabalha, Figura 3.2.Toda ação que acontece R é uma chamada de função (Operadores e funções), que por sua vez é armazenada na forma de um objeto, e este se associa um nome. forma de execução de uma função é baseada em argumentos (dados, fórmulas, expressões, etc), que são entradas, ou argumentos padrões que já são pré-estabelecidos na criação da função. Esses tipos de argumentos podem ser modificados na execução da função. Por fim, saída é o resultado, que é também um objeto, e pode ser usado como argumento de outras funções.\nFIGURA 3.2: Esquema de como o R funciona.\nNa Figura 3.2, observamos que todas ações realizadas sobre os objetos ficam armazenadas na memória ativa computador. Esses objetos são criados por comandos (teclado ou mouse) através de funções ou operadores (chamada de função), dos quais leem ou escrevem arquivos de dados disco rígido, ou leem da própria internet. Por fim, o resultado desses objetos podem ser apresentados console (memória ativa), exportados em formato de imagem, página web, etc. (disco rígido), ou até mesmo ser reaproveitado como argumento de outras funções, porque o resultado também é um objeto.","code":"\nknitr::include_graphics(\"img/Criador_S.PNG\")\nknitr::include_graphics(\"img/Funcionamento_R.PNG\")"},{"path":"como-o-r-trabalha.html","id":"como-utilizar-o-r-e-o-rstudio","chapter":"Capítulo 3 Como o R trabalha?","heading":"3.1 Como utilizar o R e o RStudio","text":"primeira ideia que temos sobre linguagem R é linha de comando, que é simbolizada pelo prompt de comando “>”. Este símbolo significa que o R está pronto para receber os comandos usuário. O prompt de comando está localizado console R. Vejamos o console R seguir, que é o local que recebe linhas de comando usuário, Figura 3.3.O R ao ser iniciado, está pronto para receber linhas de comando desejadas. Uma forma simples de armazernar os seus comandos é por meio de um script, isto é, um arquivo de texto com extensão .R. Para criar, basta ir em: Arquivo > Novo script…. Veremos muitas outras informações ao longo curso.O RStudio se apresenta como uma interface para facilitar utilização R, tendo por padrão quatro quadrantes, demonstrado na Figura 3.4Muitas coisas na interface R podem se tornar problemas para os usuários, uma vez que janelas gráficas, janelas de scripts, dentre outras, se sobrepõe. Uma vantagem RStudio foi essa divisão de quadrantes, que torna muito mais organizado atividades realizadas R.De um modo geral, diremos que o primeiro quadrante é responsável pela entrada de dados, comandos, isto é, o input. O segundo quadrante, que é o console R , representa tanto entrada como saída de informações (input/output). Dependendo atividades abas podem aumentar. O terceiro quadrante representa informações básicas como objetos ambiente global, memória de comandos na aba History, dentre outras, e também representa entrada como saída de informações (input/output). Por fim, o quarto quadrante é responsável por representação gráficas, instalação de pacotes, renderização de páginas web.\nFIGURA 3.3: Console R (Versão 4.0.3).\n\nFIGURA 3.4: Interface RStudio (Versão 1.4.1103).\n","code":"\nknitr::include_graphics(\"img/Console_do_R.PNG\")\nknitr::include_graphics(\"img/Interface_RStudio.PNG\")"},{"path":"como-o-r-trabalha.html","id":"comandos-no-r","chapter":"Capítulo 3 Como o R trabalha?","heading":"3.2 Comandos no R","text":"","code":""},{"path":"como-o-r-trabalha.html","id":"console-e-prompt-de-comando","chapter":"Capítulo 3 Como o R trabalha?","heading":"3.2.1 Console e Prompt de comando","text":"Como falado anteriormente, o R é uma linguagem baseada em linhas de comando, e linhas de comando, são executadas uma de cada vez, console. Assim que o prompt de comando está visível na tela console, o R indica que o usuário está pronto para inserir linhas de comando. O símbolo padrão prompt de comando é “>”, porém, ele pode ser alterado. Para isso, use linha de comando, por exemplo ??O conjunto de símbolos que podem ser utilizados R depende sistema operacional e país em que o R está sendo executado. Basicamente, todos os símbolos alfanuméricos podem ser utilizados, mas para evitar problemas quanto ao uso das letras aos nomes, opte pelos caracteres ASCII.escolha nome associado um objeto tem algumas regras:Deve consistir em letras, dígitos, “.” e “_”;Deve consistir em letras, dígitos, “.” e “_”;Os nomes devem ser iniciado por uma letra ou um ponto não seguido de um número, isto é, Ex.: .123, 1n, dentre outros;Os nomes devem ser iniciado por uma letra ou um ponto não seguido de um número, isto é, Ex.: .123, 1n, dentre outros;letras maiúsculas se distinguem das letras minúsculas;letras maiúsculas se distinguem das letras minúsculas;Não pode inicia por “_” ou dígito, é retornado um erro console caso isso ocorra;Não pode inicia por “_” ou dígito, é retornado um erro console caso isso ocorra;Não pode usar qualquer uma das palavras reservadas pela linguagem, isto é, TRUE, FALSE, ,\n, dentre outras, que pode ser consultado usando o comando ?Reserved().Não pode usar qualquer uma das palavras reservadas pela linguagem, isto é, TRUE, FALSE, ,\n, dentre outras, que pode ser consultado usando o comando ?Reserved().Um nome que não segue essas regras é chamado de um nome não sintático. Um comando que pode ser usado para converter nomes não sintatícos em nomes sintáticos é make.names.Apesar dessas justificativas, algumas situações como apresentadas nos exemplos anteriores são possíveis, ver Wickham (2019) na Seção 2.2.1.","code":"R>options(prompt = \"R>\")\nR># Toda vez que o console iniciar, começarar por 'R>'\nR>10## [1] 10# Nome nao sintatico\n.123 <- 50\n## Error in 0.123 <- 50 : lado esquerdo da atribuicao inválida (do_set)\n# Qual a sugestao de nome sintatico para '.123'?\nmake.names(.123)\n[1] \"X0.123\""},{"path":"como-o-r-trabalha.html","id":"comandos-elementares","chapter":"Capítulo 3 Como o R trabalha?","heading":"3.2.2 Comandos elementares","text":"Os comandos elementares podem ser divididos em expressões e atribuições. Por exemplo, podemos estar interessados em resolver seguinte expressão \\(10+15=25\\). console quando passamos pelo comando:console quando passamos pelo comando Código R 4.2, o R avalia essa expressão internamente e imprime o resultado na tela, após apertar o botão ENTER teclado. Esse fato é o que ocorre segundo princípio mencionado por Chambers (2016), tudo em R acontece por uma chamada de função. Na realidade o símbolo + é uma função interna R , que chamamos de função primitiva, porque foi implementada em outra linguagem. Assim, esse é o resultado de três objetos (“10”, “+”, “15”) que são avaliados internamente, qual função ’+’(e1, e2) é chamada, e em seguida o resultado é impresso console. Intrinsecamente, podemos também afirmar que função print() também trabalha nessa situação, fazendo o papel de imprimir o resultado console.mesmo modo, se houver algum problema em algum dos objetos o retorno da avaliação pode ser uma mensagem de erro. Um caso muito prático é quando utilizamos o separador de casas decimais, sendo vírgula “,”, para os números. Quando na realidade deve ser um ponto “.”, respeitando o sistema internacional de medidas. vírgula é utilizada para separar elementos, argumentos em uma função, etc. Vejamos um exemplo Código R 4.3.Porém, tem que ficar claro que uma expressão é qualquer comando repassado console. Este comando é avaliado e seu resultado impresso, há menos que explicitamente o usuário queira tornálo invisível. Caso algum elemento comando não seja reconhecido pelo R, há um retorno de alguma mensagem em forma de “erro” ou “alerta”, tentando indicar o possível problema. Todos esses processos ocorrem na memória ativa computador, e uma vez o resultado impresso console, o valor é perdido, há menos que você atribua essa expressão um nome, que erroneamento usamos o termo: “criamos um objeto!”. atribuição dessa expressão será dada pela junção de dois símbolos <-, falado mais frente. Um comando em forma de atribuição também avalia sua expressão, um nome se associa ao seu resultado, e o resultado será mostrado, se posteriormente, após execução você digitar o “nome” atribuído esse resultado. Vejamos um exemplo o Código R 4.4.","code":"\nR>10 + 15## [1] 25\n10.5 + 15.5## [1] 26\n# Foi criado um objeto do tipo caractere e o nome \"meu_nome\" foi associado a ele\n# O 'R' avalia essa expressão, mas não imprime no console!\nmeu_nome <- \"Ben\"\n# Para imprimir o resultado da expressão, digitamos o nome \"meu_nome\" no console\n# e apertamos o botão ENTER do teclado!\nmeu_nome## [1] \"Ben\""},{"path":"como-o-r-trabalha.html","id":"execução-de-comandos","chapter":"Capítulo 3 Como o R trabalha?","heading":"3.2.3 Execução de comandos","text":"Quando inserimos um comando console, executamos uma linha de comando por vez ou separados por “;” em uma mesma linha. Vejamos o CódigoSe um comando muito grande e não couber em uma linha, ou caso deseje completar um\ncomando em mais de uma linha, após primeira linha haverá o símbolo “+” iniciando linha seguinte ao invés símbolo de prompt de comando (“>”), até que o comando esteja sintaticamente\ncompleto. Vejamos o Código R 4.6, seguir.Por fim, todas linhas de comando quando iniciam pelo símbolo jogo da velha, “#” indica um comentário e essa linha de comando não é avaliada pelo console, apenas impressa na tela. E ainda, linhas de comandos console são limitadas aproximadamente 4095 bytes (não caracteres).","code":"\n# Uma linha de comando por vez\nmeu_nome <- \"Ben\" # Criamos e associamos um nome ao objeto\nmeu_nome # Imprimos o objeto## [1] \"Ben\"\n# Tudo em uma linha de comando\nmeu_nome <- \"Ben\"; meu_nome## [1] \"Ben\"\n# Uma linha de comando em mais de uma linha\n(10 + 10) /\n  2## [1] 10"},{"path":"como-o-r-trabalha.html","id":"chamada-e-correção-de-comandos-anteriores","chapter":"Capítulo 3 Como o R trabalha?","heading":"3.2.4 Chamada e correção de comandos anteriores","text":"Uma vez que um comando foi executado console, esse comando por ser recuperado usando teclas de setas para cima e para baixo teclado, recuperando os comandos anteriorermente executados, e que os caracteres podem ser alterados usando teclas esquerda e direita teclado, removidas com o botão Delete ou Backspace teclado, ou acrescentadas digitando os caracteres necessários. Uma outra forma de completar determinados comandos já existentes, como por exemplo, uma função que já existe nas bibliotecas de instalação R, usando o botão Tab teclado. O usuário começa digitando iniciais, e para completar o nome aperta tecla Tab. Posteriormente, basta completar linha de comando e apertar ENTER para executá-la. Para entender mais detalhes, acesse o link: https://youtu./0MRPmVsPvk4, e veja em vídeo-aula mais detalhes.Esses recursos RStudio são mais dinâmicos e vão mais além. Por exemplo, quando usamos um objeto tipo função, estes apresentam o que chamamos de argumento(s) dentro parêntese de uma função, qual são elementos necessários, para que função seja executada corretamente. Nesse caso, ao inseri o nome dessas funções console, usando o RStudio, ao iniciá-la com abertura parêntese, abre-se uma janela informando todos os argumentos possíveis dessa função. Isso torna muito dinâmico escrever linhas de comando, porque não precisaremos estar lembrando nome dos argumentos de uma função, mas apenas entender o objetivo dessa função. Para entender mais detalhes, acesse o link: https://youtu./KL3WAB_GFNI, e veja em vídeo-aula mais detalhes.","code":""},{"path":"como-o-r-trabalha.html","id":"ambiente-global-área-de-trabalho-ou-workspace","chapter":"Capítulo 3 Como o R trabalha?","heading":"3.3 Ambiente Global (área de trabalho ou Workspace)","text":"Quando usamos um comando de atribuição console, o R armazena o nome associado ao objeto\ncriado na área de trabalho (Workspace), que nós chamamos de Ambiente Global. Teremos uma seção\nintrodutória na seção Ambientes e caminhos de busca, mas entendamos inicialmente que o objetivo\nde um ambiente é associar um conjunto de nomes um conjunto de valores. Vejamos o Código R\n4.7.Observemos que todos os objetos criados até o momento estão listados, e o que é mais surpreendente é que ambientes podem conter outros ambientes e até mesmo se conterem. Observe o objeto meu_nome é um ambiente e está contido Ambiente global. Será sempre dessa forma que recuperaremos um objeto criado console R . Caso contrário, se console esse comando não de atribuição esse objeto é perdido.","code":"\n# Nomes criados no ambiente \nx <- 10 - 6; y <- 10 + 4; w <- \"Maria Isabel\"\n# Verificando o nomes contidos no ambiente global\nls()## [1] \"meu_nome\" \"w\"        \"x\"        \"y\""},{"path":"como-o-r-trabalha.html","id":"arquivos-.rdata-e-.rhistory","chapter":"Capítulo 3 Como o R trabalha?","heading":"3.4 Arquivos .RData e .Rhistory","text":"Ao final que falamos até agora, todo o processo ao inserir linhas de comando console, e desejarmos finalizar os trabalhos ambiente R , dois arquivos são criados, sob instrução usuário em querer aceitar ou não, um .RData e outro .Rhistory, cujas finalidades são:.RData: salvar todos os objetos criados que estão atualmente disponíveis;.RData: salvar todos os objetos criados que estão atualmente disponíveis;.Rhistory: salvar todas linhas de comandos inseridas console..Rhistory: salvar todas linhas de comandos inseridas console.Ao iniciar o R mesmo diretório onde esses arquivos foram salvos, é carregado toda sua área de trabalho anteriormente, bem como o histórico das linhas de comando utilizadas anteriormente.","code":""},{"path":"como-o-r-trabalha.html","id":"criando-e-salvando-um-script","chapter":"Capítulo 3 Como o R trabalha?","heading":"3.5 Criando e salvando um script","text":"melhor forma de armazenarmos nossas linhas de código inseridas console é criando um Script. Este é um arquivo de texto com extensão .R. Uma vez criada, poderemos ao final salvar o arquivo e guardá-lo para utilizar futuramente.R , ao ser iniciado poderemos ir menu em Arquivo > Novo script…. Posteriormente, pode ser inserido linhas de comando, executadas console pela tecla de atalho F5. janelas Script e console possivelmente ficarão sobrepostas. Para uma melhor utilização, estas janelas podem ficar lado lado, configurando-menu em Janelas > Dividir na horizontal (ou Dividir lado lado).RStudio, poderemos criar um Script menu em File > New File > R Script, ou diretamente ícone abaixo da opção File menu, cujo o símbolo é um arquivo com o símbolo “+” em verde, que é o ícone New File, e escolher R Script. Esse arquivo abrirá primeiro quadrante na interface RStudio.Para salvar, devemos clicar botão com o símbolo de disquete (R/RStudio), escolher o nome arquivo e o diretório onde o arquivo será armazenado seu computador. Algumas ressalvas devem ser feitas:Escolha sempre um nome sem caracteres especiais, com acentos, etc.;Escolha sempre um nome sem caracteres especiais, com acentos, etc.;Escolha sempre um nome curto ou abreviado, que identifique finalidade das linhas de comando escritas;Escolha sempre um nome curto ou abreviado, que identifique finalidade das linhas de comando escritas;Evite espaços se o nome arquivo composto. Para isso, use o símbolo underline “_“;Evite espaços se o nome arquivo composto. Para isso, use o símbolo underline “_“;Quando escrever um código, evite também escrever caracteres especiais, exceto em casos de necessidade, como imprimir um texto na tela, títulos na criação de gráficos, dentre outras. Nos referimos especificamente, nos comentários código.Quando escrever um código, evite também escrever caracteres especiais, exceto em casos de necessidade, como imprimir um texto na tela, títulos na criação de gráficos, dentre outras. Nos referimos especificamente, nos comentários código.Um ponto bem interessante é o diretório. Quando criamos um Script primeira vez, e trabalhamos nele pós criação, muitos erros podem ser encontrados de início. Um problema clássico é importação de dados. O usuário tem um conjunto de de dados e deseja fazer importação para o R , porém, mesmo com todos os comandos corretos, o console retorna um erro, informando que não existe esse arquivo que contém os dados para serem informados. Isso é devido ao diretório de trabalho atual. Para verificar qual o diretório que está trabalhando momento, use linha de comando:Para alterar o diretório de trabalho, o usuário deve usar seguinte função setwd(“Aqui, deve ser apontado para o local desejado!”). Supomos que salvamos o nosso Script em C:_scripts_r. Assim, usamos função setwd() e ao apontarmos o local, barras devem ser inseridas de modo invertido, isto é, setwd(“C:/meu_scripts_r”), além de estar entre aspas.RStudio , isso pode ser feito em Session > Set Working Directory > Source File Location. Isso levará ao diretório corrente Script. Se desejar escolher outro diretório, vá em Session > Set Working Directory > Choose Directory…. Porém, uma vez criado um Script, e utilizado novamente, se o usuário estiver abrindo o RStudio também naquele primeiro momento, por padrão, o diretório de trabalho corrente será o mesmo diretório Script. Isso acaba otimizando o trabalho.Devemos nos atentar também, quando trabalhamos utilizando Scripts ou arquivos de banco de dados, em locais diferentes diretório corrente. Um outro recurso interessante é função source(), que tem o objetivo de executar todas linhas de comando de um Script sem precisar abri-lo. Isso pode ser útil, quando criamos funções para nossas atividades, porém elas não se encontram Script de trabalho para o momento. Assim, podemos criar um Script auxiliar que armazenas todas funções criadas para análises desejadas, e Script corrente, poderemos chamá-las sem precisar abri o Script auxiliar. Todos os objetos passam estar disponíveis ambiente global.Por fim, algo de muita importância para um programador e usuário de linguagem, comente suas linhas de comando. Mas faça isso partir primeiro dia em que foi desenvolvido o primeiro Script. Isso criará um hábito, uma vez que o arquivo não está sendo criado apenas para um momento, mas para futuras consultas. E quando voltamos Scripts com muitas linhas de comando, principalmente depois de algum tempo, e sem comentários, possivelmente você passará alguns instantes para tentar\nentender o que foi escrito.Outra coisa importante, é boa prática de escrita de um código, Capítulo ??, e o RStudio nos proporciona algumas ferramentas interessantes. Mas isso será visto mais frente.","code":"\ngetwd()"},{"path":"objetos-e-estrutura-de-dados.html","id":"objetos-e-estrutura-de-dados","chapter":"Capítulo 4 Objetos e estrutura de dados","heading":"Capítulo 4 Objetos e estrutura de dados","text":"","code":""},{"path":"objetos-e-estrutura-de-dados.html","id":"atributos","chapter":"Capítulo 4 Objetos e estrutura de dados","heading":"4.1 Atributos","text":"","code":""},{"path":"objetos-e-estrutura-de-dados.html","id":"atributos-intrínsecos","chapter":"Capítulo 4 Objetos e estrutura de dados","heading":"4.1.1 Atributos intrínsecos","text":"","code":""},{"path":"objetos-e-estrutura-de-dados.html","id":"coersão","chapter":"Capítulo 4 Objetos e estrutura de dados","heading":"4.2 Coersão","text":"","code":""},{"path":"objetos-e-estrutura-de-dados.html","id":"tipo-de-objetos","chapter":"Capítulo 4 Objetos e estrutura de dados","heading":"4.3 Tipo de objetos","text":"","code":""},{"path":"objetos-e-estrutura-de-dados.html","id":"vetores","chapter":"Capítulo 4 Objetos e estrutura de dados","heading":"4.3.1 Vetores","text":"","code":""},{"path":"objetos-e-estrutura-de-dados.html","id":"vetores-escalares","chapter":"Capítulo 4 Objetos e estrutura de dados","heading":"4.3.1.1 Vetores escalares","text":"","code":""},{"path":"objetos-e-estrutura-de-dados.html","id":"vetores-longos","chapter":"Capítulo 4 Objetos e estrutura de dados","heading":"4.3.1.2 Vetores longos","text":"","code":""},{"path":"objetos-e-estrutura-de-dados.html","id":"manipulando-vetores","chapter":"Capítulo 4 Objetos e estrutura de dados","heading":"4.3.1.3 Manipulando vetores","text":"","code":""},{"path":"objetos-e-estrutura-de-dados.html","id":"matrizes-bidimensionais","chapter":"Capítulo 4 Objetos e estrutura de dados","heading":"4.3.2 Matrizes bidimensionais","text":"","code":""},{"path":"objetos-e-estrutura-de-dados.html","id":"matrizes-multidimensionais","chapter":"Capítulo 4 Objetos e estrutura de dados","heading":"4.3.3 Matrizes multidimensionais","text":"","code":""},{"path":"objetos-e-estrutura-de-dados.html","id":"listas","chapter":"Capítulo 4 Objetos e estrutura de dados","heading":"4.3.4 Listas","text":"","code":""},{"path":"objetos-e-estrutura-de-dados.html","id":"quadro-de-dados","chapter":"Capítulo 4 Objetos e estrutura de dados","heading":"4.3.5 Quadro de dados","text":"","code":""},{"path":"objetos-e-estrutura-de-dados.html","id":"funções","chapter":"Capítulo 4 Objetos e estrutura de dados","heading":"4.3.6 Funções","text":"","code":""},{"path":"objetos-e-estrutura-de-dados.html","id":"estruturas-de-controle","chapter":"Capítulo 4 Objetos e estrutura de dados","heading":"4.3.6.1 Estruturas de controle","text":"","code":""},{"path":"objetos-e-estrutura-de-dados.html","id":"como-criar-funções","chapter":"Capítulo 4 Objetos e estrutura de dados","heading":"4.3.6.2 Como criar funções","text":"","code":""},{"path":"objetos-e-estrutura-de-dados.html","id":"escopo-léxico","chapter":"Capítulo 4 Objetos e estrutura de dados","heading":"4.3.6.3 Escopo léxico","text":"","code":""},{"path":"importação-e-exportação-de-dados.html","id":"importação-e-exportação-de-dados","chapter":"Capítulo 5 Importação e exportação de dados","heading":"Capítulo 5 Importação e exportação de dados","text":"","code":""},{"path":"importação-e-exportação-de-dados.html","id":"introdução","chapter":"Capítulo 5 Importação e exportação de dados","heading":"5.1 Introdução","text":"importação/exportação de dados era algo que em poucas linhas conseguíamos explicar sobre o ambiente R , sentido de análise de dados. Entretanto, observando o terceiro princípio R, afirmado por Chambers (2016): “Interfaces para outros programas são parte R”. Hoje é uma realidade interação que o ambiente R tem com outras interfaces (programas, linguagens, etc.). facilidade em utilizar outras linguagens dentro ambiente R torna assim mais complexo importação/exportação de dados, uma vez que o objetivo R , apesar R Core Team ainda limitar sua definição como o ambiente para computação estatística, ferramenta se tornou tão versátil, que hoje torna humilde essa definição. Para mais detalhes acesse o manual ??R Data Import/Export (R CORE TEAM, 2021a). Um outro fator e tema atual é era dos grandes bancos de dados (Big Data), qual se tem um grande conjunto de variáveis e necessitamos fazer importação por APIs1 ,por exemplo, ou outras vias. Temas como esses, serão abordados em outros volumes da coleção Estudando o Ambiente R. Nesse momento, limitaremos esse assunto ao objetivo de termos um conjunto de dados em arquivos de texto (extensões tipo .txt, .csv, .xls), formato binário (.xls ou .xlsx) ou digitados manualmente pelo teclado computador. Assim, primeira forma de como os dados estão dispostos, precisaremos importá-los e armazená-los em um quadro de dados (data frame), para que esteja disponível na área de trabalho (ambiente global) R , e dessa forma, possamos utilizá-lo. Ao final tratamento dos dados, podemos exportar essas informações para arquivos externos, e daí também, usaremos os arquivos de textos e o formato binário (.xls), mensionados anteriormente.","code":""},{"path":"importação-e-exportação-de-dados.html","id":"preparação-dos-dados","chapter":"Capítulo 5 Importação e exportação de dados","heading":"5.2 Preparação dos dados","text":"primeira coisa que devemos entender quando desejamos construir o arquivo de dados, é entender que sempre organizaremos variáveis em colunas, com os seus valores em linhas, Figura ??fig:bdados). Sempre primeira linha das colunas representarar o nome das variáveis. Esse é outro ponto importante, pois devemos ter noção que alguma linguagem irá ler esse banco de dados. Assim, quanto mais caracteres diferentes padrão ASCII, mais difícil será leitura desses dados. Assim, sugerimos alguns padrões:Evitem símbolos fora padrão alfanumérico;Evitem símbolos fora padrão alfanumérico;Evitem mistura de letras minúsculas com letras maiúsculas. Isso facilitará o acesso essas variáveis. Contudo, lembremos padrão de nomes sintéticos permissíveis observados na seção 3.3.2;Evitem mistura de letras minúsculas com letras maiúsculas. Isso facilitará o acesso essas variáveis. Contudo, lembremos padrão de nomes sintéticos permissíveis observados na seção 3.3.2;Lembremos que o banco de dados será utilizado para que um programa faça sua leitura, portanto, deixemos formatação da apresentação dos dados para arquivos específico. Sendo assim, evitem comentários nesses arquivos, ou qualquer outro tipo de informação que não seja o banco de dados;Lembremos que o banco de dados será utilizado para que um programa faça sua leitura, portanto, deixemos formatação da apresentação dos dados para arquivos específico. Sendo assim, evitem comentários nesses arquivos, ou qualquer outro tipo de informação que não seja o banco de dados;Evitem palavras longas, por exemplo, segundavariavel (má escolha), segvar (boa escolha), seg_var (boa escolha);Evitem palavras longas, por exemplo, segundavariavel (má escolha), segvar (boa escolha), seg_var (boa escolha);Evitem palavras compostas com espaço entre elas. Para isso use o símbolo _, por exemplo, var 2 (má escolha), var2 (boa escolha), var_2 (boa escolha);Evitem palavras compostas com espaço entre elas. Para isso use o símbolo _, por exemplo, var 2 (má escolha), var2 (boa escolha), var_2 (boa escolha);\nFIGURA 5.1:  Modelo estrutural de um banco de dados.\n","code":"\nknitr::include_graphics(\"img/Modelo_Estrutural_Banco_Dados.png\")"},{"path":"importação-e-exportação-de-dados.html","id":"importando-dados","chapter":"Capítulo 5 Importação e exportação de dados","heading":"5.3 Importando dados","text":"função primária responável pela importação de dados é função scan(). Por exemplo, funções\ncomo read.table(), read.csv() e read.delim(), usam função scan() em seu algoritmo. primeira ideia sobre importação de dados pode ser inserindo-os pelo teclado próprio ambiente R . Para isso, usaremos função scan(), isto é,Após executado essa linha de comando, aparecerá console 1: que significa, digitar o primeiro valor objeto x, e depois clicar em ENTER. Depois 2:, que significa digitar o segundo valor, e clicar em ENTER. Depois de inserido todos os valores necessários, aperte tecla ENTER duas vezes console, para sair da função scan().O mais tradicional é usar programa para criação de banco de dados e deixá-lo pronto para o R lê-lo. O tipo de arquivo de texto que melhor controla separação de variáveis é com extensão .csv, uma vez que separamos variáveis por “;”, é o padrão. O arquivo de texto com extensão .txt, geralmente usa espaços. Isso acaba gerando problema de leitura R , porque muitos usuários usam nomes de variáveis muito grandes, palavras compostas, de forma desalinhar colunas das variáveis. Daí, como separação das variáveis é por meio de espaços, acaba gerando problema de leitura. Uma outra forma, é fazer importação de dados gerados pelo próprio R , extensão .RData.Temos opção de usar um editor de banco de dados para essas extensões por meio de programas como MS Excel, Libre Office, dentre outros. Estes exportam arquivos binários tipo .xls, .xlsx, dentre outros. Uma sugestão para diminuir complicações, é exportar os bancos de dados para arquivos de texto sitados acima, que também é possível ser exportado por esses programas. Isso evita necessidade de ser instalado mais pacotes e dor de cabeça. Porém, para quem ainda deseja enfrentar, sugerimos leitura pacote readr, como exemplo, porém existem diversos outros pacotes para este mesmo fim.Uma vez que o banco de dados está pronto, leitura destes pode ser feita por alguns caminhos. Mostraremos o mais trivial que é o botão Import Dataset, terceiro quadrante, aba Environment, na IDE RStudio , como observado na Figura 5.2.\nFIGURA 5.2: Usando o RStudio para importar dados\nPosteriormente, indique o arquivo para leitura. Aparece algumas opções de tipo de arquivo. Em\nnosso caso, usaremos opção Text (base), que significa realizar leitura para os tipos de arquivo\n.txt ou .csv. Daí os passos seguintes são:Escolher o arquivo para leitura dos dados Figura 5.2;Escolher o arquivo para leitura dos dados Figura 5.2;Configurar leitura banco de dados. Uma prévia pode ser vista quadro Data Frame. Se visualizado, algum problema, isso significa que deve ser informado opções adicionais como separador de variáveis (Separator), símbolo para casas decimais (Decimal), dentre outras opções. Por fim, digitar o nome associado ao objeto (Name) que será criado tipo quadro de dados (data frame), e clicar botão Import Figura 5.3;Configurar leitura banco de dados. Uma prévia pode ser vista quadro Data Frame. Se visualizado, algum problema, isso significa que deve ser informado opções adicionais como separador de variáveis (Separator), símbolo para casas decimais (Decimal), dentre outras opções. Por fim, digitar o nome associado ao objeto (Name) que será criado tipo quadro de dados (data frame), e clicar botão Import Figura 5.3;Uma vez inserido, o RStudio apresenta linha de comando utilizada para importar os dados \nconsole (2º quadrante), o conjunto de dados (1º quadrante), e ligação entre o nome e o objeto \nambiente global (3º quadrante), Figura 5.4;Uma vez inserido, o RStudio apresenta linha de comando utilizada para importar os dados \nconsole (2º quadrante), o conjunto de dados (1º quadrante), e ligação entre o nome e o objeto \nambiente global (3º quadrante), Figura 5.4;outra forma é utilizar linhas de comando. Para isso utilizaremos função read.table(). Antes de importarmos o banco de dados, algo interessante é inserir o arquivo de dados diretório de trabalho ambiente R . Para verificar o ambiente de trabalho use função getwd(). Para alterar o local ambiente de trabalho use setwd(). Se esse procedimento não realizado, o usuário deve informar na função read.table(), o local exato arquivo de texto.Vamos usar como diretório o local C:. Lembre-se que R , barra deve ser invertida. Vamos inserir nesse diretório três arquivos alfafa.txt, datast1980.txt e producao.csv.Os três conjuntos de dados são:\nFIGURA 5.3: Usando o RStudio para importar dados\n\nFIGURA 5.4: Usando o RStudio para importar dados\n\nFIGURA 5.5: Usando o RStudio para importar dados\nVejamos linhas de comando para importar os dados, Código R 5.1.Na última linha de comando, mostramos que também é possível importar dados de arquivos de texto da internet, e claro considerando que o usuário está com acesso internet momento da importação. E um recurso interessante que pode ser feito, principalmente para este caso, é salvar o banco de dados em um arquivo de dados ’.RData‘. Dessa forma, todos os dados, inclusive os importados da internet serão agora armazenados nesse tipo de arquivo, e não precisaremos, nesse caso, de acesso internet. Para salvar, usamos função save(). Para carregar os dados e armazenálo ambiente global, usamos função load(), Código R 5.2.Percebemos que extensões .txt e .csv são idênticos, exceto pela estrutura de como os dados estão dispostos. Para comprovar isso, o usuário manualmente poderá mudar extensão de um arquivo tipo .csv para um arquivo .txt e observar em um bloco de notas. Até agora, usamos funções R, em algumas situações, sem apresentar os argumentos dessas funções dentro dos parênteses. Isso porque quando inserimos os valores dos argumentos na posição correta destes, não precisaremos inserir o nome dos argumentos. Por exemplo, já usamos anteriormente função mean() que calcula média de um conjunto de valores, por exemplo, valores <- 1:10. Temos como primeiro argumento para essa função o x que representa um objeto R que recebe os valores para o cálculo. Assim, como sabemos que x é o primeiro argumento dessa função, podemos omitir o seu nome e calcular média por mean(valores), que é o mesmo que mean(x = valores). Para mais detalhes, ?mean(), como também, para mais detalhes sobre função read.table(), use ?read.table()","code":"> # Criando e inserido os elementos do objeto dados\n> x <- scan()\nknitr::include_graphics(\"img/Importando_Dados_01.png\")\nknitr::include_graphics(\"img/Importando_Dados_02.png\")\nknitr::include_graphics(\"img/Importando_Dados_03.png\")\nknitr::include_graphics(\"img/Importando_Dados_04.png\")>  # Diretorio\n>  getwd()\n> # Mudadando para o diretorio de interesse\n> setwd(\"C:/cursor\")\n>  # Verificando os arquivos no diretorio de trabalho\n> list.files()\n>  # Importando os dados apontando para o diretorio do arquivo\n>  dados1 <- read.table(file = \"C:/cursor/alfafa.txt\", header = TRUE)\n>  # Considerando que o arquivo esta no diretorio de\n>  # trabalho, isto eh, getwd()\n>  dados2 <- read.table(\"alfafa.txt\", header = TRUE)\n>  # Importando os dados com decimais com ',' apontando para o diretorio do\n> arquivo\n>  dados3 <- read.table(file = \"C:/cursor/dadost1980.txt\", header = TRUE, dec =\n+ \",\")\n>  # Considerando que o arquivo esta no diretorio de\n>  # trabalho, isto eh, getwd()\n>  dados4 <- read.table(file = \"dadost1980.txt\", header = TRUE, dec = \",\")\n>  # Importando os dados com decimais ',', e separados por ';' apontando para o diretorio do arquivo\n>  dados5 <- read.table(file = \"C:/cursor/producao.csv\", header = TRUE, dec =\n+ \",\", sep = \";\")\n>  # Considerando que o arquivo esta no diretorio de\n>  # trabalho, isto eh, getwd()\n>  dados6 <- read.table(file = \"producao.csv\", header = TRUE, dec = \",\", sep =\n+ \";\")\n>  # Importando da internet\n>  dados7 <- read.table(file =\n+ \"https://raw.githubusercontent.com/bendeivide/book-eambr01/main/files/␣\n+ alfafa.txt\", header = TRUE)>  # Diretorio\n>  getwd()\n> \n>  # Verificando os arquivos do diretorio de trabalho\n>  list.files()\n> \n>  # Importando os dados da internet\n>  dados7 <- read.table(file =\n+ \"https://raw.githubusercontent.com/bendeivide/book-eambr01/main/files/alfafa.txt\", header = TRUE)\n> \n>  # Salvando em '.RData'\n>  save(dados7, file = \"alfafa.RData\")\n> \n>  # Carregando '.RData' para o ambiente global\n>  load(\"alfafa.RData\")"},{"path":"importação-e-exportação-de-dados.html","id":"exportando-dados","chapter":"Capítulo 5 Importação e exportação de dados","heading":"5.4 Exportando dados","text":"","code":""},{"path":"funções-no-r.html","id":"funções-no-r","chapter":"Capítulo 6 Funções no R","heading":"Capítulo 6 Funções no R","text":"","code":""},{"path":"funções-no-r.html","id":"introdução-1","chapter":"Capítulo 6 Funções no R","heading":"6.1 Introdução","text":"Mais uma vez, nos reportamos aos princípios R (CHAMBERS, 2016), mais especificamente ao segundo princípio, “Tudo que acontece R é uma chamada de função”. Quando associamos um nome um objeto (x <- 10) pelo símbolo de atribuição (<-), o que temos é uma chamada de função realizando esse processo, isto é, ’<-’(x, 10). Ao digitar x console e posteriormente apertando o botão ENTER teclado, nos bastidores, estamos na realidade chamando função print(x) para imprimir o valor que o nome se associa. Desde coisas básicas como essas, até coisas mais complexas, temos sempre por trás uma chamada de função.","code":""},{"path":"funções-no-r.html","id":"o-que-é-uma-função-no-r","chapter":"Capítulo 6 Funções no R","heading":"6.2 O que é uma função no R?","text":"Os princípios falados por Chambers (2016) são interligados, principalmente os dois primeiros, porque apesar de tudo que acontece R ser uma chamada de função, função é um objeto, com estrutura definida como qualquer outro objeto, de modo function()1 ,assim como os vetores. Ainda mais, dizemos que linguagem R tem um estilo funcional, devido esse fato. Mais isso é assunto para o Volume II.ideia de função aqui não é pensada como uma relação matemática, mas como um sistema que tem uma entrada e saída. Podemos ter funções ambiente R que organiza dados, e não operações matemáticas por exemplo. Vejamos função sort() pacote base que ordena de forma crescente ou descrescente um conjunto de valores, como pode ser observado Código R 6.1.funções de modo closure (funções criadas por meio de function(), qual o seu modo pode ser verificado por typeof()), apresenta três estruturas básicas: argumento, corpo e ambiente, que será abordada seguir.","code":""},{"path":"funções-no-r.html","id":"estrutura-básica-de-uma-função","chapter":"Capítulo 6 Funções no R","heading":"6.3 Estrutura básica de uma função","text":"funções podem ser dividas em três componentes:Argumentos, função formals(),Corpo, função body() eAmbiente, função environment().Para o caso das funções primitivas, escritas na linguagem C, essa regra foge excessão, e será detalhado Volume II. Dizemos que funções são primitivas de modo builtin ou special. Para verificarmos tipagem desses objetos, devemos sempre usar typeof() ou invés de mode().Nesse caso, os argumentos x, decreascing e …, são nomes que aguardam receber objetos para execução da função sort(). Nem todos os argumentos necessitam receber objetos, estes chamamos de argumentos padrão, como o caso argumento decreascing com padrão igual FALSE, que significa que o ordenamento dos dados será de forma não-decrescente. Observe que na função sort() entramos apenas com o argumento x = y, não precisando inserir decreascing = FALSE. Agora, para modificar o argumento padrão, basta acrescentar alteração na função, isto é,O ’…’ é um argumento especial e significa que pode conter qualquer número de argumentos. Geralmente é utilizado em uma função quando não se sabe o número exato de argumentos. Veremos ainda nesse capítulo mais sobre esse argumento.O próximo item é o corpo da função. É nele que inserirmos instruções, isto é, linhas de comandos necessárias que se destina sua criação. Uma outra forma de acessarmos o corpo das funções é digitar console apenas o seu nome sem o parêntese, isto é, sort.Por fim, o ambiente que caso da função sort() representa o ambiente pacote base, isto é, o namespace base.","code":">  # Vetor\n>  y <- c(5, 3, 4); y## [1] 5 3 4>  # Funcao\n>  sort(x = y)## [1] 3 4 5>  # Argumentos da funcao sort\n>  formals(sort)## $x\n## \n## \n## $decreasing\n## [1] FALSE\n## \n## $...>  # Corpo da funcao\n>  body(sort)## {\n##     if (!is.logical(decreasing) || length(decreasing) != 1L) \n##         stop(\"'decreasing' must be a length-1 logical vector.\\nDid you intend to set 'partial'?\")\n##     UseMethod(\"sort\")\n## }>  # Ambiente\n>  environment(sort)## <environment: namespace:base>>  # Funcao\n>  sort(x = y, decreasing = TRUE)## [1] 5 4 3"},{"path":"funções-no-r.html","id":"funções-em-pacotes","chapter":"Capítulo 6 Funções no R","heading":"6.4 Funções em pacotes","text":"Podemos observar que essas funções utilizadas até agora, não foram criadas pelo usuário. Estas funções vieram que chamamos de pacotes2. Alguns pacotes estão disponíveis quando instalamos o R , dizemos que estes são os pacotes nativos R , para linguagem. O principal pacote deles é o base. Os demais pacotes desenvolvidos podem ser obtidos via CRAN, e falaremos mais adiante.O ambiente R apresenta uma versatilidade de manuais para linguagem. Por exemplo, para verificar informações sobre um determinado pacote como o base, use help(package = ’base’). função help() pode ser utilizada para funções de pacotes anexados. Por exemplo, help(’sort’). Uma outra função que pode ser usada para procurar por funções com determinado parte de nome é apropos(), isto é, para o exemplo anterior, temos apropost(’sort’). O pacote base sempre estará anexado, isto é, disponível caminho de busca para utilização. Para os que não estão anexados, função help deve informar o nome da função que necessita de ajuda, bem como o seu pacote. Por exemplo, temos uma função read.dbf() pacote foreign, Base R , porém, esse pacote não está anexado3 ao inicializar o R. Assim, caso não seja anexado o pacote, basta executar library(’foreign’) console. ajuda sobre função pode ser realizada com help(’read.dbf’, package = ’foreign’). Outras sintaxes para função help() é usar ? antes nome de uma função de um pacote anexado, isto é, ?sort()‘ para o caso da função estudada.Para os manuais de ajuda na internet, use ?? antes nome da função, por exemplo ??sort(), read.dbf(), etc. Essa sintaxe não precisa dos pacotes estarem anexados para ajuda de determinada função, porém o pacote necessita estar instalado. Para mais detalhes sobre pacotes, leia o Capítulo 9.","code":""},{"path":"funções-no-r.html","id":"chamadas-de-funções","chapter":"Capítulo 6 Funções no R","heading":"6.5 Chamadas de funções","text":"chamadas de funções podem ocorrer de três formas: aninhada, intermediária ou de forma pipe. Todas essas formas estão implementadas R de forma nativa, porém este último, foi implementado inicialmente pelo pacote magrittr, e na versão R 4.1, foi implementado o operador pipe nativo (|>), sendo aprofundado Volume II.Suponha que desejamos calcular o desvio padrão de um conjunto de valores. Vamos utilizar três formas de chamadas de função, que segue:Aninhado:Intermediária:Pipe:ideia da chamada de função aninhada é inserir função como argumento de funções sem necessidade de associar nomes aos objetos. ordem de execução começa sempre da direita para esquerda. caso da chamada de função intermediária, associamos nomes cada função, e os passos seguem. Por fim, o operador especial pipe (%>%) tem como primeiro operando o primeiro argumento da função segundo operando.Quando desenvolvemos pacotes, preferimos os dois primeiros, pois é forma tradicional de chamadas de função R . chamada de função pipe é muito utilizada para ciência de dados, uma vez que trabalhamos com manipulações de dados, visualizações gráficas, sem necessariamente precisarmos associar nomes aos objetos, de modo armazenar seus resultados. Dessa forma é preferível o operador pipe.","code":"> # Gerando 100 numeros aleatorios de uma distribuicao normal\n> set.seed(10) # Semente\n>  x <- rnorm(100)\n>  # Calculando o desvio padrao\n>  sqrt(var(x))## [1] 0.9412359>  # Calculando o desvio padrao\n>  vari <- var(x)\n>  desvpad <- sqrt(vari); desvpad## [1] 0.9412359> # Para usar o pipe (magrittr), substitua |> por %>%, e instale e anexe o pacote:\n> # install.packages(magrittr)\n>  library(magrittr)\n> # Calculando o desvio padrao\n>  x  %>% \n+   var()%>%\n+  sqrt()## [1] 0.9412359"},{"path":"funções-no-r.html","id":"estruturas-de-controle-1","chapter":"Capítulo 6 Funções no R","heading":"6.6 Estruturas de controle","text":"funções que utilizaremos, seguir, são utilizadas quando desejamos realizar processos repetitivos para um determinado fim ou condicionado, famosas estruturas de controle. Assim, como em outras linguagens, funções utilizadas são: (), switch(), ifelse(), (), repeat, (). Todos esses nomes são reservados ambiente R, isto é, não podemos associar esses nomes objetos. Esses objetos tem modo special4 ,porque expressão não são necessariamente avaliadas. Já função ifelse() é de modo closure. Este último é um tipo de objeto que é uma função criada por function(), e será o mesmo tipo de objeto que os usuários terão quando desenvolverem suas próprias funções.sintaxe das estruturas de controle de tipo special é:sintaxe das funções repeat e swicth() foge um pouco desse padrão, e explicaremos em sua aplicação, mais frente. Apesar da linguagem R ser interpretada, acaba ganhando fama de que funções loops são mais lentas. Em alguns casos, construção algoritmo proporciona isso e não implementação dessas funções em si. Um exemplo que podemos citar, são cópias de objetos que podem ter um gasto de memória ativa imenso processo e proporcionar um gasto computacional. E isso foi devido forma de como o algoritmo copiou os objetos, e não o desempenho das funções loops. Veremos isso em detalhes Volume II.primeira estrutura é o (), com sintaxe:O fluxograma para o entendimento da função () pode ser observado na Figura 6.1. Podemos também representar função () sintaticamente com função else da seguinte forma:Agora, acrescentando função else trabalhando conjuntamente com função (), temos sua forma sintática dada por:em que o fluxograma da combinação dessas duas funções podem ser representados pela Figura 6.1.Uma forma mais simplificada unindo funções () e else, resultaram na função ifelse(), que pode ser representada sintaticamente da seguinte forma:\nFIGURA 6.1: Fluxograma da função ()\n\nFIGURA 6.2:  Modelo estrutural de um banco de dados\nComo observado Código R 6.2, após associado o nome x associado ao objeto 5, isto é <- 5, função () foi chamada e condição foi verificada se < 3. Como essa condição era verdadeira, expressão sob condição verdadeira é impressa, e função é encerrada. Vejamos mais um exemplo Código R 6.3, seguir.Observamos na primeira forma que condição para () avaliar, nós não precisamos perguntar se .numeric(x) == TRUE, porque isso já é implícito na função, e acaba levando primeira expressão print(“Isso é um número”). De todo modo, em um segundo momento explicitamos condição, e verificamos que o resultado para este caso será o mesmo. R , essa estrutura de controle não é vetorizado, isto é, se condição houver um vetor lógico maior que 1, apenas os primeiros itens serão usados. Para entender, vejamos o Código R 6.4.Observamos que o fato de x < y ser vetorizado, tivemos problema com condição (). partir de w > 5, o resultado era para ter retornado sempre o valor 5, isto é, o valor verdadeiro (x) para condição. Isso implica que condição deve ser sempre entre vetores escalares. Uma saída seria utilizar função (), conjugada com () e else. Porém, como forma de vetorizar essa condição, foi criado função ifelse(), em que o fluxograma dessa função pode ser observado pela Figura , cuja forma sintática é dada seguir.Podemos ver que aplicação Código R 6.4 retornou um resultado que não se esperaria como o desejado, pelo fato da função () não ser vetorizada. Assim, por meio Código R 6.5 usando\nFIGURA 6.3: Fluxograma da função ifelse()\nfunção ifelse(), verificaremos que esta por ser vetorizada, o resultado retornado ocorre como\nesperado.Podemos estar interessados em resultados específicos para determinadas condições, e daí, usar o que chamamos de programação defensiva, podendo ser apresentado Código R 6.6.ideia Código R 6.6 é escolher um numero inteiro o algoritmo verificar se este é par ou ímpar. O que pode ocorrer como supostos erros que foram protegidos pelo código, o primeiro é de se avaliar um valor que não seja número. Nesse caso, primeira condição (!.numeric(x)) retornar uma mensagem que o valor não é um número. O segundo erro que poderia ocorrer é valor inserido não ser um número inteiro. Nesse caso, truncamos o número apenas usando sua parte inteira e desprezando decimal, sem o arredondamento. Tentar evitar erros previsíveis, é o que chamamos de programação defensiva, uma forma próprio usuário conseguir identificar o erro mais facilmente.Um próximo exemplo, apresentado Código R 6.6, mostrará inicialmente por meio da condição () e else pode se apresentar um código mais complexo, sendo simplificado na sequência com o uso da função switch(), Código R 6.8. O fluxograma da função switch() pode ser observado pela Figura 6.4.\nFIGURA 6.4: Fluxograma da função switch().\ntrês estruturas básicas de loop R são: repeat, () e (). Dizemos que um loop é um conjunto de instruções (expressões) em um algoritmo que se repete um número de vezes até que sejam alcançados os objetivos desejados. repetição é controlada pelo contador, um objeto R . Cada repetição represeta um ciclo loop. Enquanto condição loop verdadeira, os ciclos se repetem atualizando o contador, Figura 6.5. Algumas funções não têm condição explícita (repeat e ), e precisam de funções adicionais em suas expressões.\nFIGURA 6.5: Fluxograma loop\nprimeira função loop é repeat, apresentamos sua sintaxe:Juntamente com o repeat, usamos funções break e next, pois função repeat não tem uma\ncondição explícita. Para o entendimento, criamos dois fluxogramas, sendo o primeiro entendendo função repeat junto com função break e o outro função repeat juntamente com função next, dos quais podem ser verificadas pelas Figuras 6.6 e 6.7, respectivamente. Vejamos, alguns exemplos para essas funções, iniciando pelo Código R 6.9.\nFIGURA 6.6: Fluxograma das funções repeat e break\n\nFIGURA 6.7: Fluxograma das funções repeat e next\nObservamos que condição em repeat se repete até > 5, ou seja, será impresso apenas os\nvalores de 1 5. Para que isso ocorra, nós quebramos o ciclo de repetição com função break,\nem que o objeto <- 1 [linha 1, Código R 6.9] é o contador ciclo. Percebemos que cada ciclo apresenta console como resultado execução print() [linha 8, Código R 6.9], e que na sequência, o contador se atualiza, <- + 1 [linha 9, Código R 6.9]. Essa situação se repete enquanto < 6, porque nessa situação condição em else é sempre executada. Assim, momento em que o contador é igual 5, esse valor é impresso console, e na sequência este é atualizado para <- 5 + 1, isto é, o contador assume valor igual 6. Nesse momento, o ciclo recomeça e quando linha 5 é avaliada, condição > 5 passa ser verdadeira, então linha 6 é avaliado e função break entra em ação. Isso resulta na quebra ciclo, e então função repeat é encerrada. O próximo exemplo Código 6.10, apresentamos função next.O que diferencia o Código R 6.9 para o Código R 6.10 é o acréscimo da função next ao código. Quando condição (== 3) [linha 9, Código R 6.10] é verdadeira, linhas 10 e 11 são executadas. Primeiro atualizamos o contador <- 3 + 1 [linha 10, Código R 6.10] e posteriormente, função next [linha 10, Código R 6.10] é executada. Inserimos linha 12 Código R 6.10] para termos ideia da função next, que é avançar o ciclo quando esta função é executada, ou seja, quando o contador quando assume valor 3, linhas 10 e 11 são executadas, e após função next ser chamada, linhas 12, 14 e 15 não são executadas, porque se fossem, o valor 5 seria impresso duas vezes, e isso não ocorreu. O que aconteceu foi o avanço de ciclo. Devemos ter uma atenção função repeat, porque como ela não tem um critério de parada explícito, podemos incorrer em um loop infinito.Similar função repeat(), temos função (), que agora, temos uma condição de parada, cujo fluxograma é dado pela Figura 6.8, com sintaxe dada por:\nFIGURA 6.8: Fluxograma da função \nNessa função, também podemos usar funções break e next, como usados na função repeat. Vejamos o exemplo Código R 6.11.Nesse caso, não foi necessário utilizar função break, devido condição que ela permite impor\nao ciclo. Vejamos um outro exemplo, Código R 6.12.Observamos utilização da função next, similar ao que foi realizado com função repeat. Por\nfim, função (), com cuja sintaxe é dada por:Com essa função, também podemos utilizar break e next. Porém, o controle ciclo nessa\nsituação é maior, e menos necessário essas funções. Vejamos Figura 6.9.\nFIGURA 6.9: Fluxograma da função ()\nObservamos que implementação, dos algoritmos anteriores, é bem mais simples usando função (). Vejamos um próximo exemplo, Código R 6.14.Mais uma vez, foi utilizado função next, sem necessidade agora, de atualizar o contador , uma vez que já está definido na função (). Veremos na próxima subseção, que temos funções de alto nível que podem substituir funções loops. São chamadas funções da família apply.","code":"função (condição) {\n expressão\n}if (condição) {\n # Corpo do if()\n #instruções sob condição = TRUE\n}\nif (condição) {\n # Corpo do if()\n # instruções sob condição = TRUE\n} else {\n # Corpo do else\n # instruções sob condição = FALSE\n}\nknitr::include_graphics(\"img/Fluxograma_da_Funcao_if.png\")\nknitr::include_graphics(\"img/Fluxograma_da_Funcao_if_else.png\")if (condição) instr1\nif (condição) instr1 else instr2>  # Objeto\n>  i <- 5\n>  # Estrutura if()\n>  if (i > 3) {\n+  print(\"Maior␣que␣3!\")\n+  }## [1] \"Maior<U+2423>que<U+2423>3!\">  # Objeto numerico\n>  x <- 10\n>  # Estrutura 'if'\n>  if (is.numeric(x)) {\n+  print(\"Isso␣é␣um␣número\")\n+  } else {\n+  print(\"Isso␣não␣é␣um␣número\")\n+  }## [1] \"Isso<U+2423>é<U+2423>um<U+2423>número\">  # eh o mesmo que\n>  if (is.numeric(x) == TRUE) {\n+  print(\"Isso␣é␣um␣número\")\n+  } else {\n+  print(\"Isso␣não␣é␣um␣número\")\n+  }## [1] \"Isso<U+2423>é<U+2423>um<U+2423>número\">  # Objetos\n>  x <- 5\n>  w <- 3:8\n>  # Primeira sintaxe (Preferivel)\n>  if (x < w) {\n+  x\n+  } else {\n+  w\n+  }## Warning in if (x < w) {: a condição tem comprimento > 1 e somente o primeiro\n## elemento será usado## [1] 3 4 5 6 7 8>  # Segunda forma\n>  if (x < w) x else w## Warning in if (x < w) x else w: a condição tem comprimento > 1 e somente o\n## primeiro elemento será usado## [1] 3 4 5 6 7 8ifelse (condição, expressão sob TRUE, expressão sob FALSE)\n\nknitr::include_graphics(\"img/Fluxograma_da_Funcao_ifelse.png\")>  # Objetos\n>  x <- 5\n>  w <- 3:8\n>  # Primeira sintaxe (Preferivel)\n>  ifelse(x < w, x, w)## [1] 3 4 5 5 5 5>  x <- 2 # numero\n> \n>  # Estrutura 'if'\n>  if (!is.numeric(x)) {\n+  \"Nao_eh_numero\"\n+  } else {\n+  if ((trunc(x) %% 2) == 0) {\n+  cat(\"numero_par:␣\", trunc(x))\n+  } else {\n+  if ((trunc(x) %% 2) == 1) {\n+  cat(\"numero_impar:␣\", trunc(x))\n+  }\n+  }\n+  }## numero_par:<U+2423> 2\nknitr::include_graphics(\"img/Fluxograma_Funcao_switch.png\")>  # Objeto\n>  set.seed(15) # Fixando a semente\n>  x <- rnorm(1000) # Gerando 1000 numeros aleatorios\n>  # medida descritiva\n>  opcao <- \"media\" # opcoes: \"media\", \"mediana\", \"medapar\" (media aparada)\n>  if (opcao == \"media\") {\n+  cat(\"A␣média␣aritmética␣é:\", round(mean(x), 4))\n+  } else {\n+  if (opcao == \"mediana\") {\n+  cat(\"A␣mediana␣é:\", round(mean(x), 4))\n+  } else {\n+  if (opcao == \"medapar\") {\n+  cat(\"A␣média␣aparada␣é:\", round(mean(x, trim = 0.1), 4))\n+  }\n+  }\n+  }## A<U+2423>média<U+2423>aritmética<U+2423>é: 0.037>  # Objeto\n>  set.seed(15) # Fixando a semente\n>  x <- rnorm(1000) # Gerando 1000 numeros aleatorios\n>  # medida descritiva\n>  opcao <- \"media\" # opcoes: \"media\", \"mediana\", \"medapar\" (media aparada)\n>  switch(opcao,\n+  media = cat(\"A␣média␣aritmética␣é:\", round(mean(x), 4)),\n+  mediana = cat(\"A␣mediana␣é:\", round(mean(x), 4)),\n+  medapar = cat(\"A␣média␣aparada␣é:\", round(mean(x, trim = 0.1), 4)) )## A<U+2423>média<U+2423>aritmética<U+2423>é: 0.037\nknitr::include_graphics(\"img/Fluxograma_loop.png\")repeat {\n expressão ...\n}\nknitr::include_graphics(\"img/Fluxograma_Funcao_repeat_break.png\")\nknitr::include_graphics(\"img/Fluxograma_Funcao_repeat_next.png\")>  # Contador\n>  i <- 1\n>  # Loop repeat\n>  repeat {\n+  if (i > 5) {\n+  break\n+  } else {\n+  print(i)\n+  i <- i + 1\n+  }\n+  }## [1] 1\n## [1] 2\n## [1] 3\n## [1] 4\n## [1] 5>  # Contador\n>  i <- 1\n>  # Loop repeat\n>  repeat {\n+  if (i > 5) {\n+  break\n+ }\n+  else {\n+  if (i == 3) {\n+  i <- i + 1\n+   next\n+  print(i + 1)\n+  }\n+  print(i)\n+  i <- i + 1\n+  }\n+  }## [1] 1\n## [1] 2\n## [1] 4\n## [1] 5while (condição) {\n expressão ...\n}\nknitr::include_graphics(\"img/Fluxograma_Funcao_while.png\")>  # Contador\n>  i <- 1\n>  # Loop while\n>  while (i <= 5) {\n+  print(i)\n+  i <- i + 1\n+  }## [1] 1\n## [1] 2\n## [1] 3\n## [1] 4\n## [1] 5>  # Contador\n>  i <- 1\n>  # Loop while\n>  while (i <= 5) {\n+  if (i == 3) {\n+  i <- i + 1\n+  next\n+  }\n+  print(i)\n+  i <- i + 1\n+  }## [1] 1\n## [1] 2\n## [1] 4\n## [1] 5for (contador in lista) {\n expressão ...\n}\nknitr::include_graphics(\"img/Fluxograma_Funcao_for.png\")>  # Loop for\n>  for (i in 1:5) {\n+  print(i)\n+  }## [1] 1\n## [1] 2\n## [1] 3\n## [1] 4\n## [1] 5>  # Loop for\n>  for (i in 1:5) {\n+  if (i == 3) {\n+  next\n+  }\n+  print(i)\n+  }## [1] 1\n## [1] 2\n## [1] 4\n## [1] 5"},{"path":"funções-no-r.html","id":"criando-funções","chapter":"Capítulo 6 Funções no R","heading":"6.7 Criando funções","text":"Até esse momento, usamos funções já desenvolvidas R, seja dos pacotes nativos, seja via instalação dos pacotes via CRAN. Agora, iremos desenvolver nossas próprias funções.Como falado anteriormente, início, estrutura da função criada se mantém, argumento, corpo e ambiente. Para isso, usaremos função function(). O modo desse objeto é closure5. Vejamos sua sintaxe,Desse modo, apresentamos o primeiro exemplo Código R 6.15, seguirNesse caso, temos uma função chamada fun1(), cujo argumento de entrada é x. Observemos que uma função é como um objeto tipo vector, associamos um nome ao objeto da mesma forma. O corpo apresenta uma delimitação por chaves …, em que apresenta um comando de atribuição, cujo nome res se associa ao resultado da soma x + 1. Por fim, o resultado dessa função, imprime res, por meio da função return(). Para executar fun1(), fazemos:O que aconteceu foi que ao assumir x = 5 argumento, essa informação foi repassada para o corpo da função fun1(), aonde existia o nome x, que se associou ao objeto 5, para esse caso. função + é chamada, e expressão x + 1 é avaliada, cujo nome res se associa ao resultado dessa expressão. Por fim, quando função fun1() é chamada, o resultado de res é impressa console, por meio de return(res). Vamos verificar os três componentes da função fun1() console, isto é,O corpo da função é executado de forma sequencial, partir da primeira linha de comando até última. Apesar de recomendado, também não é obrigatório o uso da função return(), são chamadas saídas explícitas6, sendo observado como segue,","code":">  # Forma usual\n>  nome_funcao <- function(arg1, arg2, ...) {\n+  corpo: comandos..\n+  }\n>  # Forma simplificada\n>  nome_funcao <- function(arg1, arg2, ...) corpo> # Criando a funcao 'fun1'\n> fun1 <- function(x) {\n+  res <- x + 1\n+  return(res)\n+ }> fun1(x = 5)## [1] 6> # Argumentos\n> formals(fun1)## $x> # Corpo\n> body(fun1)## {\n##     res <- x + 1\n##     return(res)\n## }> # Ambiente\n> environment(fun1)## <environment: R_GlobalEnv>>   # Funcao\n>   fun2 <- function(x) x + 1\n>   # Executando"},{"path":"funções-no-r.html","id":"função-anônima","chapter":"Capítulo 6 Funções no R","heading":"6.7.1 Função anônima","text":"Podemos também ter o que chamamos de função anônima, da qual não associamos nome funções. Contudo, sendo criada esta não pode ser recuperada como qualquer outro objeto. Essa forma é interessante quando não precisamos dela após o seu uso. Por exemplo, queremos calcular integral,\\[ \\int_{0}^{1} x^2 \\,dx=\\frac{1}{3} \\]\ne criamos uma função \\(x^2\\). Então,função integrate() é utilizada para o cálculo de integral, qual, passamos os argumentos, função (f), limite inferior (lower) e limite superior (upper) da integração, respectivamente. Observemos que não houve necessidade de nomear função argumento, pois não há objetivo de ser reutilizado. Isso também ocorre muito na área de ciência de dados, quando muitas vezes fazemos manipulações com os dados ao mesmo tempo, sem necessidade de associar nomes aos resultados intermediários.","code":">  integrate(f = function(x) x^2,\n+  lower = 0,\n+  upper = 1)## 0.3333333 with absolute error < 3.7e-15"},{"path":"funções-no-r.html","id":"chamadas-de-função","chapter":"Capítulo 6 Funções no R","heading":"6.7.2 Chamadas de função","text":"chamadas de funções ocorrem de três formas: aninhado, intermediário e via pipe. Vejamos o cálculo desvio padrão novamente, Código R 6.16.Mais detalhes sobre esses três aspectos serão abordados Volume II.","code":">  # Funcao auxiliar 1\n>  aux1 <- function(x) x - mean(x)\n>  # Funcao auxiliar 2\n>  aux2 <- function(x) x^2\n>  # Funcao auxiliar 3\n>  aux3 <- function(x) {\n+  sum(x) / (length(x) - 1)\n+  }\n>  # Gerando 100 numeros aleatorios de uma distribuicao normal\n>  set.seed(10)\n>  x <- rnorm(100)\n>  # Calculo do desvio padrao (aninhado)\n>  sqrt(aux3(aux2(aux1(x))))## [1] 0.9412359>  # Calculo do desvio padrao (intemediario)\n>  dp <- aux1(x)\n>  dp <- aux2(dp)\n>  dp <- aux3(dp)\n>  dp <- sqrt(dp)\n>  dp## [1] 0.9412359>  # Calculo do desvio padrao (pipe)\n>  x |>\n+  aux1() |>\n+  aux2() |>\n+  aux3() |>\n+  sqrt()## [1] 0.9412359"},{"path":"funções-no-r.html","id":"ordenação-de-argumentos","chapter":"Capítulo 6 Funções no R","heading":"6.7.3 Ordenação de argumentos","text":"Os argumentos nas funções podem ser nomeados ou não. Quando nomeados, ordem como são\ninseridos na função não importa. Já os argumentos não nomeados, seus valores precisam estar na ordem como função foi desenvolvida. Vejamos o Código R 6.17, para entender melhor.","code":"> estdesc <- function(x, opcao) {\n+  res <- switch(opcao,\n+  media = round(mean(x), 4),\n+  mediana = round(mean(x), 4),\n+  medapar = round(mean(x, trim = 0.1), 4))\n+  return(res)\n+ }\n> # Objeto\n> set.seed(15)\n> x <- rnorm(1000)\n> # Argumentos nomeados na funcao\n> estdesc(x = x, opcao = \"media\")## [1] 0.037> estdesc(opcao = \"media\", x = x)## [1] 0.037> # Argumentos não nomeados ordenados\n> estdesc(x, \"media\")## [1] 0.037> # Argumentos não ordenados (Gera erro)\n> estdesc(\"media\", x)## Error in switch(opcao, media = round(mean(x), 4), mediana = round(mean(x), : EXPR deve ser um vetor de comprimento 1"},{"path":"funções-no-r.html","id":"objeto-reticências","chapter":"Capítulo 6 Funções no R","heading":"6.7.4 Objeto reticências (“…”)","text":"O objeto reticências é tipo pairlist, um tipo de objeto usado bastante internamente R , e dificilmente utilizado código interpretado. Desse modo, não temos acesso direto estrutura objeto …. Contudo, esse objeto tem um papel fundamental nas funções, quando damos liberdade de inserir mais argumentos além dos definidos na criação da função. Esse argumento é usado na função plot(), por exemplo, pacote nativo base. Vejamos como o argumento … pode ser usado em uma função, Código R 6.18.Isso ocorre, porque temos função plot() corpo da função grafico() que apresenta muitos\nargumentos. Dessa forma, criamos função grafico(), com os argumentos que representam coordenadas, mas reticências (‘…’) garantem que os demais argumentos da função plot, omitidos, possam ser utilizados.","code":">  # Funcao que plota um grafico\n>  grafico <- function(x, y, ...) {\n+  plot(x = x, y = y, ...)\n+  }\n>  # Vetores\n>  x <- 1:10; y <- rnorm(10)\n>  # Chamada 1, com os argumentos definidos\n>  grafico(x = x, y = y)>  # Chamada 2, inserindo argumentos nao definidos\n>  grafico(x = x, y = y, main = \"Título\")"},{"path":"funções-no-r.html","id":"escopo-léxico-1","chapter":"Capítulo 6 Funções no R","heading":"6.8 Escopo léxico","text":"Vamos retornar aos componentes da função fun1(), desenvolvido Código R 6.15, reapresentando novamente três estruturas de uma função,Observemos que o último componente é o ambiente onde o nome fun1 foi associado função.\nEste ambiente é chamado de ambiente envolvente. Nesse caso é o ambiente global. Contudo, quando função é executada, momentaneamente é criado o ambiente de execução. É neste ambiente que os nomes que estão corpo da função são associados aos objetos. Vejamos um primeiro exemplo, Código R 6.19.Por causa ambiente de execução que o objeto x dentro da função é retornado, ao invés que foi definido fora da função. Isso porque o ambiente de execução mascara os nomes definidos dentro da função dos nomes definidos fora da função. Esse é uma primeira característica escopo léxico nas funções em R . Anteriormente, falamos sobre atribuição, que representa forma como os nomes se associam aos objetos. Agora, o escopo vem ser forma como os nomes encontram seus valores associados. O termo léxico significa que funções podem encontrar nomes e seus respectivos valores associados, definidos ambiente onde função foi definida, isto é, ambiente de função. Claro que isso segue regras, e primeira foi máscara de nome falada anteriormente.\nPorém quando não existe um nome vinculado um objeto, e este foi definido ambiente de função, o valor é repassado para o corpo da função, como pode ser observado Código R 6.20.O resultado de fun() foi 10, porque como função procurou ambiente de execuções e não encontrou esse nome, função foi até o ambiente superior, caso, o ambiente de execuções. Como falado anteriormente, todo ambiente tem um pai (ou ambiente superior). Essa hierarquização é observada caminho de busca, que pode ser acessado por search(), ou seja,O ambiente corrente R sempre será o ambiente ambiente global (.GlobalEnv). O ambiente de execução não aparece, porque ele é momentâneo. Então, após buscar ambiente de execução e não encontrar, é pelo caminho de busca que função irá procurar pelos objetos inseridos corpo da função. Ele só existe quando função é chamada e não quando ela é definida, isto é,Observe que após ser criada função fun(), o nome x se associou ao objeto 10. Posteriormente, fun() foi chamada e o resultado foi 20. Contudo, o nome x se associou outro objeto 20, e após segunda chamada da função fun(), o resultado foi 30, porque função procura os valores quando ela é executada, e não quando é criada, é característica de pesquisa dinâmica escopo léxico. Uma outra situação pode ser observada Código R 6.21.Nessas linhas de comando, poderíamos pensar que após ter executado primeira chamada, o\nvalor retornado seria 2, e segunda chamada retornaria o valor 3, como ocorre com variáveis estáticas na linguagem C, por exemplo. Aqui nesse caso, o resultado independente número de chamadas, será sempre o mesmo porque uma outra característica escopo léxico R é o novo começo, porque cada vez que função é executada um novo ambiente de execução é criado, e portanto, cada execução dos comandos de atribuição e expressão são executados de forma independentes nas chamadas de funções.Algo que não havíamos falado anteriormente, é que função function() não necessariamente\nnecessita de definição de argumentos, devido flexibilidade escopo léxico das funções em R. É essa característica que faz com que os comandos corpo das funções encontrem os objetos que não estão definidos na própria função. Mais detalhes, serão encontrado Volume II: Nível Intermediário da coleção Estudando o Ambiente R.","code":"> # Argumentos\n> formals(fun1)## $x> # Corpo\n> body(fun1)## {\n##     res <- x + 1\n##     return(res)\n## }> # Ambiente\n> environment(fun1)## <environment: R_GlobalEnv>>  x <- 10\n> fun <- function() {\n+  x <- 2\n+  x\n+  }\n>  # Chamando a funcao fun\n>  fun()## [1] 2>  x <- 10\n>  fun <- function() {\n+  x\n+  }\n>  # Chamando a funcao fun\n>  fun()## [1] 10>  search()##  [1] \".GlobalEnv\"        \"package:magrittr\"  \"package:stats\"    \n##  [4] \"package:graphics\"  \"package:grDevices\" \"package:utils\"    \n##  [7] \"package:datasets\"  \"package:methods\"   \"Autoloads\"        \n## [10] \"package:base\">  # Funcao\n>  fun <- function() x + 10\n>  # Objeto 1\n>  x <- 10\n>  # Chamada1\n>  fun()## [1] 20>  # Objeto 2\n>  x <- 20\n>  # Chamada 2\n>  fun()## [1] 30>  # Objeto\n>  n <- 1\n>  # Funcao\n>  fun <- function() {\n+    n <- n + 1\n+    n\n+  }\n>  # Chamada 1\n>  fun()## [1] 2>  # Chamada 2\n>  fun()## [1] 2"},{"path":"boas-práticas-de-como-escrever-um-código.html","id":"boas-práticas-de-como-escrever-um-código","chapter":"Capítulo 7 Boas práticas de como escrever um código","heading":"Capítulo 7 Boas práticas de como escrever um código","text":"","code":""},{"path":"pacotes.html","id":"pacotes","chapter":"Capítulo 8 Pacotes","heading":"Capítulo 8 Pacotes","text":"","code":""},{"path":"pacotes.html","id":"estrutura-básica-de-um-pacote","chapter":"Capítulo 8 Pacotes","heading":"8.1 Estrutura básica de um pacote","text":"","code":""},{"path":"pacotes.html","id":"instalação-de-um-pacote","chapter":"Capítulo 8 Pacotes","heading":"8.2 Instalação de um pacote","text":"","code":""},{"path":"pacotes.html","id":"objetivos-de-um-pacote","chapter":"Capítulo 8 Pacotes","heading":"8.3 Objetivos de um pacote","text":"","code":""},{"path":"pacotes.html","id":"utilizando-funções-de-um-pacote","chapter":"Capítulo 8 Pacotes","heading":"8.4 Utilizando funções de um pacote","text":"","code":""},{"path":"pacotes.html","id":"carregando-e-anexando-um-pacote","chapter":"Capítulo 8 Pacotes","heading":"8.5 Carregando e anexando um pacote","text":"","code":""},{"path":"pacotes.html","id":"namespace-de-um-pacote","chapter":"Capítulo 8 Pacotes","heading":"8.6 NAMESPACE de um pacote","text":"","code":""},{"path":"pacotes.html","id":"usando-os-operadores-e","chapter":"Capítulo 8 Pacotes","heading":"8.7 Usando os operadores :: e :::","text":"","code":""},{"path":"boas-práticas-de-como-escrever-um-código-1.html","id":"boas-práticas-de-como-escrever-um-código-1","chapter":"Capítulo 9 Boas práticas de como escrever um código","heading":"Capítulo 9 Boas práticas de como escrever um código","text":"","code":""},{"path":"boas-práticas-de-como-escrever-um-código-1.html","id":"introdução-2","chapter":"Capítulo 9 Boas práticas de como escrever um código","heading":"9.1 Introdução","text":"Nesse momento, entendemos os principais objetos para escrevermos os nossos scripts. Quando escrevemos um código, duas consequências ocorrem:guardá-lo para futuras consultas, ouguardá-lo para futuras consultas, oucompartilhamento.compartilhamento.Nesses dois casos, percebemos que alguém irá ler esse código, ou até mesmo o próprio usuário, irá retornar àquelas linhas de código e tentar raciocinar quais ideias por trás disso tudo. Para um melhor entendimento de seu script, nada mais importante que uma boa escrita, separação das estruturas por hierarquização, comentários, etc.Uma primeira ferramenta que pode ser configurada para quem usa o RStudio é acionar todas opções de diagnóstico seu código. Para isso menu:Tools > Global options > Code > Editing. Marque todas opções em General;Tools > Global options > Code > Editing. Marque todas opções em General;Tools > Global options > Code > Display, Marque todas opções;Tools > Global options > Code > Display, Marque todas opções;Tools > Global options > Code > Diagnostics. Marque todas opções em R Diagnostics.Tools > Global options > Code > Diagnostics. Marque todas opções em R Diagnostics.Com isso, colorações nas linhas de comando ocorrerão, distinguindo diversas estruturas, como linhas de comentário, funções, espaçamentos, dentre outras coisas.Uma vez feito isso, vamos para o passo seguinte que são boas práticas de como se escrever um script. Temos algumas ferramentas prontas, como o pacote styler e como alternativa o pacote formatR, que automatiza todo o nosso código seja em script, contido em um pacote, ou diretório. Acesse https://yihui.org/formatr, para mais detalhes. Para instalar e anexar o pacote styler, use linhas de comando:Vejamos Figura 9.1, para entendermos funcionabilidade desse pacote.\nFIGURA 9.1: Passos para configurar o pacote styler.\n","code":"> # Instalando pacote\n> install.packages(styler)\n> # Carregando e anexando\n> library(styler)\nknitr::include_graphics(\"img/Configuracao_Styler.png\")"},{"path":"pacotes-1.html","id":"pacotes-1","chapter":"Capítulo 10 Pacotes","heading":"Capítulo 10 Pacotes","text":"","code":""},{"path":"pacotes-1.html","id":"introdução-3","chapter":"Capítulo 10 Pacotes","heading":"10.1 Introdução","text":"Um pacote em R é um diretório de arquivos necessários para carregar um código de funções, dados, documentações de ajuda, testes, etc. O próprio R em sua instalação, contém 30 pacotes nativos, que contém funções mínimas para utilização ambiente. pacote, não há apenas códigos em R , mas um pacote fonte (inglês, source package), contendo os arquivos mencionados acima, ou um arquivo compactado, de extensão .tar.gz pacote fonte, ou um pacote instalado, resultado comando R CMD INSTALL, que será visto Volume V: Desenvolvimento de Pacotes R, coleção Estudando o Ambiente R. Isso acontece Linux. Para plataformas Windows e Macintosh, existem também os pacotes binários ou compactados com extensão .zip ou .tgz, respectivamente.Um pacote, portanto é unidade básica para o compartilhamento de um código. Atualmente, até 01/12/2021, o número de pacotes disponíveis CRAN é 18.524. Podemos encontrar lista de pacotes por data de publicação ou por ordem alfabética. Qualquer usuário pode publicar um pacote e disponibilizá-lo sob o CRAN. Para isso, uma série de testes iniciais são realizados próprio ambiente R , para verificar se o pacote em desenvolvimento não contém problemas previsíveis, e posteriormente, uma checagem mais aprofundada, após submissão, é realizada por algum dos mantenedores R (R Development Core Team). Isso significa dizer que se um pacote está disponível CRAN, além de sua estabilidade, o pacote será executável nas três plataformas mais usadas em sistema operacional, Linux ou sitemas Unix, Windows e Macintosh. Isso é um padrão hoje R.Há outros repositórios que podem ser disponibilizados os pacotes, como por exemplo, Biocondutor, R-forge, GitHub. Este último está sendo muito utilizado, nesses últimos anos. Porém, quando os pacotes estão em repositórios diferentes CRAN, não haverá garantias dos padrões mencionados anteriormente. Além mais, devemos entender que principal preocupação dos mantenedores R, é que os pacotes funcionem corretamente, naquilo em que os mesmos objetivam, mas em nada é discutido sobre metodologia científica, ou de análises, que o pacote se destina. Isso é verificado, quando o pacote após disponível CRAN, também é submetido para o journal R, o R Journal ou ao Journal Statistical Software, por exemplo. Aí sim, o pacote é esmiuçado tanto aspecto computacional, quanto metodológico.Portanto, entenda que nem todo pacote sob o CRAN é confiável naquilo que se propõe, o que não significa dizer, que um pacote é confiável se apenas tiver sido publicado nas revistas anteriores ou em qualquer outra específica para área de interesse, mas cautela é sempre necessária, tentando entender quem são os desenvolvedores, ou fazendo uma pesquisa mais ampla sobre o referido pacote, para que assim, decisão da escolha seja confiável. Fazemos esse adendo, porque quando se vai pesquisar sobre um determinado assunto poderá existir diversos pacotes para o mesmo, e pergunta será, qual pacote devemos escolher? Aquele que é mais fácil utilizar? E daí, uma boa pesquisa para escolha não deve ser levado apenas em consideração facilidade de utilização pacote, mas saber se funções pacote realmente retornam os resultados confiáveis para aquilo que se destina. Fica nossa dica.Para uma instalação mais rápida dos pacotes, optem pelos espelhos disponíveis nos países em que vivem, uma vez que transferência de dados ocorrem mais rapidamente. Aqui Brasil, por exemplo, o primeiro espelho desenvolvido e ativo até hoje é o da UFPR. Mas, temos mais quatro espelhos: dois na USP, uma na Fiocruz/RJ, e outra na UESC.Um termo que deve ficar claro, que erroneamente, alguns usuários chamam o termo biblioteca como um sinônimo de pacote. Nas documentações R , biblioteca é o diretório onde os pacotes são instalados, também chamados de diretório de biblioteca ou diretório de árvores. O outro sentido de biblioteca é o de biblioteca compartilhada (dinâmica ou estática), que armazenam código compilado que se vinculam aos pacotes, por exemplo, Windows são DLLs.","code":""},{"path":"pacotes-1.html","id":"estrutura-básica-de-um-pacote-1","chapter":"Capítulo 10 Pacotes","heading":"10.2 Estrutura básica de um pacote","text":"estrutura básica de um pacote é apresentada na Figura 10.1\nFIGURA 10.1: Esqueleto básico de um pacote\nVejamos ideias básicas desses subdiretórios e arquivos:DESCRIPTION: Esse é um arquivo de texto, contendo informações básicas como o título pacote, versão, licença, descrição, nome dos autores, e o mantenedor pacote, isto é, para quando um pacote estiver com problema ou o CRAN entre em contato, será para este último. Esses informações obrigatórias que devem ter nesse arquivo;DESCRIPTION: Esse é um arquivo de texto, contendo informações básicas como o título pacote, versão, licença, descrição, nome dos autores, e o mantenedor pacote, isto é, para quando um pacote estiver com problema ou o CRAN entre em contato, será para este último. Esses informações obrigatórias que devem ter nesse arquivo;NAMESPACE: Esse arquivo embora tenha tenha muita semelhança com linguagem R , o seu conteúdo, se destina importação e exportação de funções pacote. Será nesse arquivo, que diremos quais os pacotes que ele depende, isto é, funções, e quais funções exportadas, visíveis, que devem ser apresentadas aos usuários;NAMESPACE: Esse arquivo embora tenha tenha muita semelhança com linguagem R , o seu conteúdo, se destina importação e exportação de funções pacote. Será nesse arquivo, que diremos quais os pacotes que ele depende, isto é, funções, e quais funções exportadas, visíveis, que devem ser apresentadas aos usuários;R/: Esse subdiretório apresenta os scripts com funções em R . é o cérebro pacote;R/: Esse subdiretório apresenta os scripts com funções em R . é o cérebro pacote;man/: Esse subdiretório apresenta os arquivos de ajuda, com extensão .Rd. Isso significa, que uma vez instalado o pacote R , o acesso aos manuais de ajuda referido pacote, estarão disponíveis, graças esses arquivos.man/: Esse subdiretório apresenta os arquivos de ajuda, com extensão .Rd. Isso significa, que uma vez instalado o pacote R , o acesso aos manuais de ajuda referido pacote, estarão disponíveis, graças esses arquivos.Claro, que quando os pacotes se tornam mais complexos, outros subdiretórios e arquivos são\nnecessário. Mas isso é assunto para o Volume V: Desenvolvimento de Pacotes R, coleção Estudando o Ambiente R.","code":""},{"path":"pacotes-1.html","id":"instalação-de-um-pacote-1","chapter":"Capítulo 10 Pacotes","heading":"10.3 Instalação de um pacote","text":"instalação de um pacote via R pode ser feito pela função install.packages(pkgs = “nome_pacote”). Por exemplo, vamos tentar instalar o pacote midrangeMCP, da seguinte forma:Pode ser que nesse processo, dependendo de onde o usuário esteja executando essa linha de comando, interface R ou RStudio, que seja solicitado o espelho por onde deseja fazer instalação. Isso é apenas um atalho para ter um acesso mais rápido na instalação pacote. sugestão é escolher um espelho de seu país de origem.Uma forma simples de se ter detalhes pacote na internet, tais como, baixar o pacote fonte ou o pacote binário midrangeMCP, por exemplo, é sempre usar essa url: <http://cran.r-project. org/package=midrangeMCP>. Para qualquer outro pacote, basta mudar o nome pacote na url, e assim, estaremos na página repositório pacote. O pacote fonte, como falado anteriormente, é compactado com extensão .tar.gz, caso, midrangeMCP_3.1.1.tar.gz. O pacote binário tem compactação zipada, midrangeMCP_3.1.1.tar.zip para o Windows e midrangeMCP_3.1.1.tgz para o Macintosh. O acesso aos arquivos pacote mencionados esqueleto são disponíveis pacote fonte.Uma outra forma possível de instalação é baixar o arquivo pacote fonte para o seu computador e instalá-lo, via comando:Consideramos que o arquivo pacote esteja diretório de trabalho usuário. Caso contrário, deve ser informado o local onde pacote se encontra computador. Para o Window ou Macintosh, é possível instalar também, partir dos pacotes binários.Muitos dos desenvolvedores, estão disponibilizando seus projetos de pacotes, principalmente GitHub, inclusive com manuals de ajuda com maiores detalhes. Pode ser possível instalar esses pacotes por esse repositório. Precisamos inicialmente pacote devtools, e posteriormente instalação pacote. Segue linhas de comando:Contudo, devemos dar preferência pela instalação via CRAN. Por lá, teremos garantia que os pacotes estão estáveis para utilização nas referidas plataformas mencionadas acima.Alguns pacotes, por falta de manutenção, seja por atualizações R ou por qualquer outro motivo, podem se tornar incompatíveis para utilização sobre alguns dos três sistemas operacionais básicos (Windows, Unix e Mac) exigidos pelo R. Dessa forma, se correções não forem feitas, estes pacotes e tornam órfãos, ou seja, desativados sob o CRAN. O primeiros pacotes sob o CRAN, por exemplo, não tinham o arquivo NAMESPACE, que hoje é exigido. Qualquer tentativa de instalação desses pacotes nessas situações, não serão bem sucedidas. Dessa forma, fizemos uma vídeo-aula, como tentativa de recuperar os pacotes desativados. Porém, deixemos claro que nem sempre é possível instalação de pacotes desativados.","code":"> install.packages(\"midrangeMCP\")>  install.packages(pkgs = \"./midrangeMCP.tar.gz\", repos = NULL, type = \"source\")## Installing package into 'C:/Users/MABENLA/Documents/R/win-library/4.1'\n## (as 'lib' is unspecified)## Warning in install.packages(pkgs = \"./midrangeMCP.tar.gz\", repos = NULL, :\n## installation of package './midrangeMCP.tar.gz' had non-zero exit status> install.packages(\"devtools\")\n> install_github(\"bendeivide/midrangeMCP\")"},{"path":"pacotes-1.html","id":"objetivos-de-um-pacote-1","chapter":"Capítulo 10 Pacotes","heading":"10.4 Objetivos de um pacote","text":"ideia de um pacote para um usuário R deve representar como uma ferramenta para otimizar suas atividades dia--dia na utilização da linguagem. Suponha que o usuário seja um cientista de dados, e todos os dias ele carrega uma sequência de scripts, via source, para disponibilizar suas funções ambiente global. Isso acaba gerando processos repetitivos de trabalho desnecessários.Ao invés, o cientista de dados pode desenvolver um pacote, e esse pacote conter todas funções necessárias para suas análises. De uma vez, o pacote instalado e anexado caminho de busca, todas suas funções estarão disponíveis para utilização. Portanto, o entendimento disso, permite uma maior eficiência de trabalho.Outro ponto é que experiência contida em um pacote pode ser propagada mais facilmente para outros usuários, mostrando que o conhecimento é uma liberdade necessária. Tanto pelo CRAN, quanto por outras plataformas, o pacote pode ser disponibilizado.","code":""},{"path":"pacotes-1.html","id":"utilizar-as-funções-de-um-pacote","chapter":"Capítulo 10 Pacotes","heading":"10.5 Utilizar as funções de um pacote","text":"Uma vez instalado o pacote, precisamos carregar e anexá-lo, para que possamos utilizar os recursos disponíveis pacote, como funções, dados, etc. Isso significa, disponibilizar na memória e inseri-lo caminho de busca, respectivamente. Para fazer essas duas ações ao mesmo tempo, use função library() ou require(). primeira função se utilizada sem argumento algum, retorna todos os pacotes instalados na biblioteca de pacotes R . Vejamos o exemplo pacote midrangeMCP, Código R 9.1.","code":">  # Carregando e anexando o pacote midrangeMCP\n> library(midrangeMCP)\n> # Usando a função MRtest() desse pacote\n>  #-----\n>  # Dados simulados de um experimento em DIC (Delineamento Inteiramente Casualizado)\n> # Variavel resposta\n>  rv <- c(100.08, 105.66, 97.64, 100.11, 102.60, 121.29, 100.80,\n+ 8 + 99.11, 104.43, 122.18, 119.49, 124.37, 123.19, 134.16,\n+ 9 + 125.67, 128.88, 148.07, 134.27, 151.53, 127.31)\n>  # Tratamento\n>  treat <- factor(rep(LETTERS[1:5], each = 4))\n>  # Anava\n>  res <- anova(aov(rv~treat))\n>  DFerror <- res$Df[2]\n>  MSerror <- res$`Mean Sq`[2]\n>  # Aplicando testes\n>  results <- midrangeMCP::MRtest(y = rv,\n+  trt = treat,\n+  dferror = DFerror,\n+  mserror = MSerror,\n+  alpha = 0.05,\n+  main = \"PCMs\",\n+  MCP = c(\"all\"))## MCP's based on distributions of the studentized midrange and range\n## \n## Study:  PCMs \n## \n## Summary:\n##    Means   std r    Min    Max\n## A 100.87  3.40 4  97.64 105.66\n## B 107.95  9.28 4 100.80 121.29\n## C 117.62  9.02 4 104.43 124.37\n## D 130.22  5.37 4 123.19 134.67\n## E 140.30 11.42 4 127.31 151.53\n## \n##  Mean Grouping Midrange Test\n## \n## Statistics: \n##   Exp.Mean       CV  MSerror Df n Stud.Midrange  Ext.DMS  Int.DMS\n##    119.392 6.889695 67.66288 15 5      1.089968 5.783505 4.482901\n## \n## Groups: \n##    Means Groups\n## E 140.30     g1\n## D 130.22     g2\n## C 117.62     g3\n## B 107.95     g4\n## A 100.87     g4\n## \n## Mean Grouping Range Test\n## \n## Statistics: \n##   Exp.Mean       CV  MSerror Df n Stud.Range      DMS\n##    119.392 6.889695 67.66288 15 5   4.366985 17.96085\n## \n## Groups: \n##    Means Groups\n## E 140.30     g1\n## D 130.22     g1\n## C 117.62     g2\n## B 107.95     g2\n## A 100.87     g2\n## \n## SNK Midrange Test\n## \n## Statistics: \n##       Exp.Mean     CV MSerror Df n Stud.Midrange    DMS\n## comp1  119.392 6.8897 67.6629 15 5        1.0900 5.7835\n## comp2  119.392 6.8897 67.6629 15 4        1.1646 6.0906\n## comp3  119.392 6.8897 67.6629 15 3        1.2828 6.5768\n## comp4  119.392 6.8897 67.6629 15 2        1.5072 7.4994\n## \n## Groups: \n##    Means Groups\n## E 140.30     g1\n## D 130.22   g1g2\n## C 117.62 g1g2g3\n## B 107.95   g2g3\n## A 100.87     g3\n## \n## Tukey Midrange Test\n## \n## Statistics: \n##   Exp.Mean       CV  MSerror Df n Stud.Midrange  Ext.DMS  Int.DMS\n##    119.392 6.889695 67.66288 15 5      1.089968 5.783505 4.482901\n## \n## Groups: \n##    Means Groups\n## E 140.30     g1\n## D 130.22     g2\n## C 117.62     g3\n## B 107.95     g4\n## A 100.87     g4> midrangeMCP::MRbarplot(results)"},{"path":"pacotes-1.html","id":"carregando-e-anexando-um-pacote-1","chapter":"Capítulo 10 Pacotes","heading":"10.6 Carregando e anexando um pacote","text":"Anteriormente, falamos que usamos função library() ou require() para carregar e anexar um pacote para utilizar suas funções, após instalação. Carregar um pacote significa disponibilizar na memória ativa. Para acessar uma função de um pacote após ter sido carregado, usamos o operador ::, isto é, nome_pacote::nome_função. Isto significa, que será chamado função necessária sem anexar o pacote caminho de busca. Estudaremos Capítulo 10, um pouco mais sobre caminho de busca. Para esse momento, entendamos que é um caminho hierarquizado de ambientes, isto é, objetos que armazenam, em forma de lista, nomes associados objetos. função para ver o caminho de busca é search(), como pode ser observado Código R 9.2.Com linhas de comando apresentadas anteriormente, percebemos ao executar função MRwrite() pacote midrangeMCP, usando :: que o caminho de busca não foi alterado. Isso significa que o pacote não foi anexado, apenas carregado, ou seja, se o usuário desejar usar alguma função pacote digitando apenas o nome console, não será possível, porque o pacote não está anexado ao caminho de busca. Vejamos outra situação pelo Código R 9.3.Com o uso da função library(), percebemos que o caminho de busca foi alterado, porque agora temos o ambiente de pacote package:midrangeMCP. Isso significa que agora poderemos acessar os objetos desse pacote apenas digitando o nome associado eles. Por fim, última linha de comando, representa interface gráfica ao usuário para o pacote, o que chamamos de GUI (inglês, Graphical User Interface).","code":">  # Caminho de busca\n>   search()##  [1] \".GlobalEnv\"          \"package:midrangeMCP\" \"package:stats\"      \n##  [4] \"package:graphics\"    \"package:grDevices\"   \"package:utils\"      \n##  [7] \"package:datasets\"    \"package:methods\"     \"Autoloads\"          \n## [10] \"package:base\"> # Carregando e chamando uma função de um pacote\n> midrangeMCP::MRwrite(results, extension = \"latex\")## Table in latex of results of the MGM test\n## \n## % latex table generated in R 4.1.3 by xtable 1.8-4 package\n## % Thu Nov 17 06:20:02 2022\n## \\begin{table}[ht]\n## \\centering\n## \\begin{tabular}{lrl}\n##   \\hline\n## trt & Means & Groups \\\\ \n##   \\hline\n## E & 140.30 & g1 \\\\ \n##   D & 130.22 & g2 \\\\ \n##   C & 117.62 & g3 \\\\ \n##   B & 107.95 & g4 \\\\ \n##   A & 100.87 & g4 \\\\ \n##    \\hline\n## \\end{tabular}\n## \\end{table}\n## \n## \n## Table in latex of results of the MGR test\n## \n## % latex table generated in R 4.1.3 by xtable 1.8-4 package\n## % Thu Nov 17 06:20:02 2022\n## \\begin{table}[ht]\n## \\centering\n## \\begin{tabular}{lrl}\n##   \\hline\n## trt & Means & Groups \\\\ \n##   \\hline\n## E & 140.30 & g1 \\\\ \n##   D & 130.22 & g1 \\\\ \n##   C & 117.62 & g2 \\\\ \n##   B & 107.95 & g2 \\\\ \n##   A & 100.87 & g2 \\\\ \n##    \\hline\n## \\end{tabular}\n## \\end{table}\n## \n## \n## Table in latex of results of the SNKM test\n## \n## % latex table generated in R 4.1.3 by xtable 1.8-4 package\n## % Thu Nov 17 06:20:02 2022\n## \\begin{table}[ht]\n## \\centering\n## \\begin{tabular}{lrl}\n##   \\hline\n## trt & Means & Groups \\\\ \n##   \\hline\n## E & 140.30 & g1 \\\\ \n##   D & 130.22 & g1g2 \\\\ \n##   C & 117.62 & g1g2g3 \\\\ \n##   B & 107.95 & g2g3 \\\\ \n##   A & 100.87 & g3 \\\\ \n##    \\hline\n## \\end{tabular}\n## \\end{table}\n## \n## \n## Table in latex of results of the TM test\n## \n## % latex table generated in R 4.1.3 by xtable 1.8-4 package\n## % Thu Nov 17 06:20:02 2022\n## \\begin{table}[ht]\n## \\centering\n## \\begin{tabular}{lrl}\n##   \\hline\n## trt & Means & Groups \\\\ \n##   \\hline\n## E & 140.30 & g1 \\\\ \n##   D & 130.22 & g2 \\\\ \n##   C & 117.62 & g3 \\\\ \n##   B & 107.95 & g4 \\\\ \n##   A & 100.87 & g4 \\\\ \n##    \\hline\n## \\end{tabular}\n## \\end{table}\n## \n## \n## Table in latex of results of descriptive statistics\n## \n## % latex table generated in R 4.1.3 by xtable 1.8-4 package\n## % Thu Nov 17 06:20:02 2022\n## \\begin{table}[ht]\n## \\centering\n## \\begin{tabular}{lrrrrr}\n##   \\hline\n## trt & Means & std & r & Min & Max \\\\ \n##   \\hline\n## A & 100.87 & 3.40 & 4.00 & 97.64 & 105.66 \\\\ \n##   B & 107.95 & 9.28 & 4.00 & 100.80 & 121.29 \\\\ \n##   C & 117.62 & 9.02 & 4.00 & 104.43 & 124.37 \\\\ \n##   D & 130.22 & 5.37 & 4.00 & 123.19 & 134.67 \\\\ \n##   E & 140.30 & 11.42 & 4.00 & 127.31 & 151.53 \\\\ \n##    \\hline\n## \\end{tabular}\n## \\end{table}\n## \n## See yours tables in Console\n##  Format: latex>  # Caso o pacote midrangeMCP esteja anexado, use:\n>  # detach(\"package:midrangeMCP\", unload = TRUE)\n>  # Caminho de busca\n>  search()##  [1] \".GlobalEnv\"          \"package:midrangeMCP\" \"package:stats\"      \n##  [4] \"package:graphics\"    \"package:grDevices\"   \"package:utils\"      \n##  [7] \"package:datasets\"    \"package:methods\"     \"Autoloads\"          \n## [10] \"package:base\">  # Carregando e anexando um pacote\n>  library(midrangeMCP)\n>  # Verificando novamente o caminho de busca\n>  search()##  [1] \".GlobalEnv\"          \"package:midrangeMCP\" \"package:stats\"      \n##  [4] \"package:graphics\"    \"package:grDevices\"   \"package:utils\"      \n##  [7] \"package:datasets\"    \"package:methods\"     \"Autoloads\"          \n## [10] \"package:base\">  # Chamando uma funcao do pacote\n>  guimidrangeMCP()"},{"path":"pacotes-1.html","id":"namespace-de-um-pacote-1","chapter":"Capítulo 10 Pacotes","heading":"10.7 NAMESPACE de um pacote","text":"início da seção sobre pacotes, falamos sobre o esqueleto de um pacote, isto é, os componentes básicos de um pacote. Um dos arquivos foi o NAMESPACE. Esse arquivo é responsável pela exportação e importação de funções. funções exportadas de um pacote, por meio desse arquivo, são aquelas visíveis após anexação pacote ao caminho de busca, ou por meio operador ::. funções importadas são aquelas utilizadas de outros pacotes, utilizadas internamente ao referido pacote.funções ditas internas são aquelas não mencionadas NAMESPACE. Em muitas situações, precisamos de funções internas necessárias para finalidade pacote, que muitas vezes não é objetivo final para disponibilidade dos usuários, mas códigos intermediários para boa funcionabilidade pacote. Dessa forma, uma boa escolha para que não haja conflitos em nomes associados objetos ambiente de trabalho, é decisão de não exportá-los.Porém, quando se cria um pacote, por exemplo, pelo RStudio , o padrão NAMESPACE\né o comando: exportPattern(’‘3’’), que significa que todas funções pacote serão\nexportadas que não iniciam por um ponto (“.”).","code":""},{"path":"pacotes-1.html","id":"documentações-de-um-pacote","chapter":"Capítulo 10 Pacotes","heading":"10.8 Documentações de um pacote","text":"Toda função exportada de um pacote precisa de um arquivo de ajuda (.Rd). Rodas funções deverão ter esses tipos arquivos inseridos subdiretório man/. Mais detalhes sobre o desenvolvimento de pacotes será abordado Volume V: Desenvolvimento de Pacotes R, coleção Estudando o Ambiente R.","code":""},{"path":"pacotes-1.html","id":"operadores-e","chapter":"Capítulo 10 Pacotes","heading":"10.9 Operadores :: e :::","text":"Como falamos anteriormente, para chamarmos uma função sem necessidade de anexar o pacote, usamos o operador ::. Comentamos também, que algumas funções não eram exportadas pelo NAMESPACE de um pacote. Contudo, se desejarmos visualizar ou executá-las, poderemos utilizar o operador ’:::’. Vejamos um exemplo, nas linhas de comando seguir.funções internas dos pacotes devem ser utilizadas com muita cautela, uma vez que são funções que podem passar por atualizações, mudanças. Isso porque, como não são funções exportadas, alguns pacotes podem passar por atualizações, e desse modo, estas funções também podem ser atualizadas ou até mesmo alteradas.Outro ponto interessante é que não se recomenda utilização de importação de funções internas de outros pacotes desenvolvimento de pacotes, uma vez que são funções que podem passar por mudanças drásticas, e portanto, gerar problemas nas rotinas. Se uma função em um pacote não foi exportada, é porque o desenvolvedor tem um bom motivo para tal situação. funções exportadas são de fato essência objetivo de um pacote, e por isso que elas são exportadas.","code":">  # Instale o pacote SMR\n>  # install.packages(SMR) # Descomente a linha de comando para instalar\n>  # Carregando e chamando funcoes exportadas do pacote SMR\n>  SMR::pSMR(q = 2, size = 10, df = 3)## [1] 0.9905216>  # Carregando e chamando funcoes nao exportadas ao pacote\n>  SMR:::GaussLegendre(size = 4)## $nodes\n## [1] -0.8611363 -0.3399810  0.3399810  0.8611363\n## \n## $weights\n## [1] 0.3478548 0.6521452 0.6521452 0.3478548"},{"path":"considerações-e-preparação-para-programação-em-r-nível-intermediário.html","id":"considerações-e-preparação-para-programação-em-r-nível-intermediário","chapter":"Capítulo 11 Considerações e preparação para Programação em R (Nível Intermediário)","heading":"Capítulo 11 Considerações e preparação para Programação em R (Nível Intermediário)","text":"","code":""},{"path":"referências.html","id":"referências","chapter":"Referências","heading":"Referências","text":"","code":""}]
